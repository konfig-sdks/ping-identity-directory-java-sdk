/*
 * PingData Config - OpenAPI 3.0
 * This is the PingData Configuration API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.EnumconnectionHandlerSslClientAuthPolicyProp;
import com.konfigthis.client.model.EnumldapConnectionHandlerSchemaUrn;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * LdapConnectionHandlerShared
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class LdapConnectionHandlerShared {
  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_SCHEMAS = "schemas";
  @SerializedName(SERIALIZED_NAME_SCHEMAS)
  private List<EnumldapConnectionHandlerSchemaUrn> schemas = new ArrayList<>();

  public static final String SERIALIZED_NAME_LISTEN_ADDRESS = "listenAddress";
  @SerializedName(SERIALIZED_NAME_LISTEN_ADDRESS)
  private List<String> listenAddress = null;

  public static final String SERIALIZED_NAME_LISTEN_PORT = "listenPort";
  @SerializedName(SERIALIZED_NAME_LISTEN_PORT)
  private Integer listenPort;

  public static final String SERIALIZED_NAME_USE_S_S_L = "useSSL";
  @SerializedName(SERIALIZED_NAME_USE_S_S_L)
  private Boolean useSSL;

  public static final String SERIALIZED_NAME_ALLOW_START_T_L_S = "allowStartTLS";
  @SerializedName(SERIALIZED_NAME_ALLOW_START_T_L_S)
  private Boolean allowStartTLS;

  public static final String SERIALIZED_NAME_SSL_CERT_NICKNAME = "sslCertNickname";
  @SerializedName(SERIALIZED_NAME_SSL_CERT_NICKNAME)
  private String sslCertNickname;

  public static final String SERIALIZED_NAME_KEY_MANAGER_PROVIDER = "keyManagerProvider";
  @SerializedName(SERIALIZED_NAME_KEY_MANAGER_PROVIDER)
  private String keyManagerProvider;

  public static final String SERIALIZED_NAME_TRUST_MANAGER_PROVIDER = "trustManagerProvider";
  @SerializedName(SERIALIZED_NAME_TRUST_MANAGER_PROVIDER)
  private String trustManagerProvider;

  public static final String SERIALIZED_NAME_ALLOW_L_D_A_P_V2 = "allowLDAPV2";
  @SerializedName(SERIALIZED_NAME_ALLOW_L_D_A_P_V2)
  private Boolean allowLDAPV2;

  public static final String SERIALIZED_NAME_USE_T_C_P_KEEP_ALIVE = "useTCPKeepAlive";
  @SerializedName(SERIALIZED_NAME_USE_T_C_P_KEEP_ALIVE)
  private Boolean useTCPKeepAlive;

  public static final String SERIALIZED_NAME_SEND_REJECTION_NOTICE = "sendRejectionNotice";
  @SerializedName(SERIALIZED_NAME_SEND_REJECTION_NOTICE)
  private Boolean sendRejectionNotice;

  public static final String SERIALIZED_NAME_FAILED_BIND_RESPONSE_DELAY = "failedBindResponseDelay";
  @SerializedName(SERIALIZED_NAME_FAILED_BIND_RESPONSE_DELAY)
  private String failedBindResponseDelay;

  public static final String SERIALIZED_NAME_MAX_REQUEST_SIZE = "maxRequestSize";
  @SerializedName(SERIALIZED_NAME_MAX_REQUEST_SIZE)
  private String maxRequestSize;

  public static final String SERIALIZED_NAME_MAX_CANCEL_HANDLERS = "maxCancelHandlers";
  @SerializedName(SERIALIZED_NAME_MAX_CANCEL_HANDLERS)
  private Integer maxCancelHandlers;

  public static final String SERIALIZED_NAME_NUM_ACCEPT_HANDLERS = "numAcceptHandlers";
  @SerializedName(SERIALIZED_NAME_NUM_ACCEPT_HANDLERS)
  private Integer numAcceptHandlers;

  public static final String SERIALIZED_NAME_NUM_REQUEST_HANDLERS = "numRequestHandlers";
  @SerializedName(SERIALIZED_NAME_NUM_REQUEST_HANDLERS)
  private Integer numRequestHandlers;

  public static final String SERIALIZED_NAME_REQUEST_HANDLER_PER_CONNECTION = "requestHandlerPerConnection";
  @SerializedName(SERIALIZED_NAME_REQUEST_HANDLER_PER_CONNECTION)
  private Boolean requestHandlerPerConnection;

  public static final String SERIALIZED_NAME_SSL_CLIENT_AUTH_POLICY = "sslClientAuthPolicy";
  @SerializedName(SERIALIZED_NAME_SSL_CLIENT_AUTH_POLICY)
  private EnumconnectionHandlerSslClientAuthPolicyProp sslClientAuthPolicy;

  public static final String SERIALIZED_NAME_ACCEPT_BACKLOG = "acceptBacklog";
  @SerializedName(SERIALIZED_NAME_ACCEPT_BACKLOG)
  private Integer acceptBacklog;

  public static final String SERIALIZED_NAME_SSL_PROTOCOL = "sslProtocol";
  @SerializedName(SERIALIZED_NAME_SSL_PROTOCOL)
  private List<String> sslProtocol = null;

  public static final String SERIALIZED_NAME_SSL_CIPHER_SUITE = "sslCipherSuite";
  @SerializedName(SERIALIZED_NAME_SSL_CIPHER_SUITE)
  private List<String> sslCipherSuite = null;

  public static final String SERIALIZED_NAME_MAX_BLOCKED_WRITE_TIME_LIMIT = "maxBlockedWriteTimeLimit";
  @SerializedName(SERIALIZED_NAME_MAX_BLOCKED_WRITE_TIME_LIMIT)
  private String maxBlockedWriteTimeLimit;

  public static final String SERIALIZED_NAME_AUTO_AUTHENTICATE_USING_CLIENT_CERTIFICATE = "autoAuthenticateUsingClientCertificate";
  @SerializedName(SERIALIZED_NAME_AUTO_AUTHENTICATE_USING_CLIENT_CERTIFICATE)
  private Boolean autoAuthenticateUsingClientCertificate;

  public static final String SERIALIZED_NAME_CLOSE_CONNECTIONS_WHEN_UNAVAILABLE = "closeConnectionsWhenUnavailable";
  @SerializedName(SERIALIZED_NAME_CLOSE_CONNECTIONS_WHEN_UNAVAILABLE)
  private Boolean closeConnectionsWhenUnavailable;

  public static final String SERIALIZED_NAME_CLOSE_CONNECTIONS_ON_EXPLICIT_G_C = "closeConnectionsOnExplicitGC";
  @SerializedName(SERIALIZED_NAME_CLOSE_CONNECTIONS_ON_EXPLICIT_G_C)
  private Boolean closeConnectionsOnExplicitGC;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_ALLOWED_CLIENT = "allowedClient";
  @SerializedName(SERIALIZED_NAME_ALLOWED_CLIENT)
  private List<String> allowedClient = null;

  public static final String SERIALIZED_NAME_DENIED_CLIENT = "deniedClient";
  @SerializedName(SERIALIZED_NAME_DENIED_CLIENT)
  private List<String> deniedClient = null;

  public LdapConnectionHandlerShared() {
  }

  public LdapConnectionHandlerShared description(String description) {
    
    
    
    
    this.description = description;
    return this;
  }

   /**
   * A description for this Connection Handler
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A description for this Connection Handler")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    
    
    
    this.description = description;
  }


  public LdapConnectionHandlerShared schemas(List<EnumldapConnectionHandlerSchemaUrn> schemas) {
    
    
    
    
    this.schemas = schemas;
    return this;
  }

  public LdapConnectionHandlerShared addSchemasItem(EnumldapConnectionHandlerSchemaUrn schemasItem) {
    this.schemas.add(schemasItem);
    return this;
  }

   /**
   * Get schemas
   * @return schemas
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public List<EnumldapConnectionHandlerSchemaUrn> getSchemas() {
    return schemas;
  }


  public void setSchemas(List<EnumldapConnectionHandlerSchemaUrn> schemas) {
    
    
    
    this.schemas = schemas;
  }


  public LdapConnectionHandlerShared listenAddress(List<String> listenAddress) {
    
    
    
    
    this.listenAddress = listenAddress;
    return this;
  }

  public LdapConnectionHandlerShared addListenAddressItem(String listenAddressItem) {
    if (this.listenAddress == null) {
      this.listenAddress = new ArrayList<>();
    }
    this.listenAddress.add(listenAddressItem);
    return this;
  }

   /**
   * Specifies the address or set of addresses on which this LDAP Connection Handler should listen for connections from LDAP clients.
   * @return listenAddress
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the address or set of addresses on which this LDAP Connection Handler should listen for connections from LDAP clients.")

  public List<String> getListenAddress() {
    return listenAddress;
  }


  public void setListenAddress(List<String> listenAddress) {
    
    
    
    this.listenAddress = listenAddress;
  }


  public LdapConnectionHandlerShared listenPort(Integer listenPort) {
    
    
    
    
    this.listenPort = listenPort;
    return this;
  }

   /**
   * Specifies the port number on which the LDAP Connection Handler will listen for connections from clients.
   * @return listenPort
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the port number on which the LDAP Connection Handler will listen for connections from clients.")

  public Integer getListenPort() {
    return listenPort;
  }


  public void setListenPort(Integer listenPort) {
    
    
    
    this.listenPort = listenPort;
  }


  public LdapConnectionHandlerShared useSSL(Boolean useSSL) {
    
    
    
    
    this.useSSL = useSSL;
    return this;
  }

   /**
   * Indicates whether the LDAP Connection Handler should use SSL.
   * @return useSSL
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the LDAP Connection Handler should use SSL.")

  public Boolean getUseSSL() {
    return useSSL;
  }


  public void setUseSSL(Boolean useSSL) {
    
    
    
    this.useSSL = useSSL;
  }


  public LdapConnectionHandlerShared allowStartTLS(Boolean allowStartTLS) {
    
    
    
    
    this.allowStartTLS = allowStartTLS;
    return this;
  }

   /**
   * Indicates whether clients are allowed to use StartTLS.
   * @return allowStartTLS
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether clients are allowed to use StartTLS.")

  public Boolean getAllowStartTLS() {
    return allowStartTLS;
  }


  public void setAllowStartTLS(Boolean allowStartTLS) {
    
    
    
    this.allowStartTLS = allowStartTLS;
  }


  public LdapConnectionHandlerShared sslCertNickname(String sslCertNickname) {
    
    
    
    
    this.sslCertNickname = sslCertNickname;
    return this;
  }

   /**
   * Specifies the nickname (also called the alias) of the certificate that the LDAP Connection Handler should use when performing SSL communication.
   * @return sslCertNickname
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the nickname (also called the alias) of the certificate that the LDAP Connection Handler should use when performing SSL communication.")

  public String getSslCertNickname() {
    return sslCertNickname;
  }


  public void setSslCertNickname(String sslCertNickname) {
    
    
    
    this.sslCertNickname = sslCertNickname;
  }


  public LdapConnectionHandlerShared keyManagerProvider(String keyManagerProvider) {
    
    
    
    
    this.keyManagerProvider = keyManagerProvider;
    return this;
  }

   /**
   * Specifies the name of the key manager that should be used with this LDAP Connection Handler .
   * @return keyManagerProvider
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the name of the key manager that should be used with this LDAP Connection Handler .")

  public String getKeyManagerProvider() {
    return keyManagerProvider;
  }


  public void setKeyManagerProvider(String keyManagerProvider) {
    
    
    
    this.keyManagerProvider = keyManagerProvider;
  }


  public LdapConnectionHandlerShared trustManagerProvider(String trustManagerProvider) {
    
    
    
    
    this.trustManagerProvider = trustManagerProvider;
    return this;
  }

   /**
   * Specifies the name of the trust manager that should be used with the LDAP Connection Handler .
   * @return trustManagerProvider
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the name of the trust manager that should be used with the LDAP Connection Handler .")

  public String getTrustManagerProvider() {
    return trustManagerProvider;
  }


  public void setTrustManagerProvider(String trustManagerProvider) {
    
    
    
    this.trustManagerProvider = trustManagerProvider;
  }


  public LdapConnectionHandlerShared allowLDAPV2(Boolean allowLDAPV2) {
    
    
    
    
    this.allowLDAPV2 = allowLDAPV2;
    return this;
  }

   /**
   * Indicates whether connections from LDAPv2 clients are allowed.
   * @return allowLDAPV2
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether connections from LDAPv2 clients are allowed.")

  public Boolean getAllowLDAPV2() {
    return allowLDAPV2;
  }


  public void setAllowLDAPV2(Boolean allowLDAPV2) {
    
    
    
    this.allowLDAPV2 = allowLDAPV2;
  }


  public LdapConnectionHandlerShared useTCPKeepAlive(Boolean useTCPKeepAlive) {
    
    
    
    
    this.useTCPKeepAlive = useTCPKeepAlive;
    return this;
  }

   /**
   * Indicates whether the LDAP Connection Handler should use TCP keep-alive.
   * @return useTCPKeepAlive
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the LDAP Connection Handler should use TCP keep-alive.")

  public Boolean getUseTCPKeepAlive() {
    return useTCPKeepAlive;
  }


  public void setUseTCPKeepAlive(Boolean useTCPKeepAlive) {
    
    
    
    this.useTCPKeepAlive = useTCPKeepAlive;
  }


  public LdapConnectionHandlerShared sendRejectionNotice(Boolean sendRejectionNotice) {
    
    
    
    
    this.sendRejectionNotice = sendRejectionNotice;
    return this;
  }

   /**
   * Indicates whether the LDAP Connection Handler should send a notice of disconnection extended response message to the client if a new connection is rejected for some reason.
   * @return sendRejectionNotice
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the LDAP Connection Handler should send a notice of disconnection extended response message to the client if a new connection is rejected for some reason.")

  public Boolean getSendRejectionNotice() {
    return sendRejectionNotice;
  }


  public void setSendRejectionNotice(Boolean sendRejectionNotice) {
    
    
    
    this.sendRejectionNotice = sendRejectionNotice;
  }


  public LdapConnectionHandlerShared failedBindResponseDelay(String failedBindResponseDelay) {
    
    
    
    
    this.failedBindResponseDelay = failedBindResponseDelay;
    return this;
  }

   /**
   * Specifies the length of time that the server should delay the response to non-successful bind operations. A value of zero milliseconds indicates that non-successful bind operations should not be delayed.
   * @return failedBindResponseDelay
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the length of time that the server should delay the response to non-successful bind operations. A value of zero milliseconds indicates that non-successful bind operations should not be delayed.")

  public String getFailedBindResponseDelay() {
    return failedBindResponseDelay;
  }


  public void setFailedBindResponseDelay(String failedBindResponseDelay) {
    
    
    
    this.failedBindResponseDelay = failedBindResponseDelay;
  }


  public LdapConnectionHandlerShared maxRequestSize(String maxRequestSize) {
    
    
    
    
    this.maxRequestSize = maxRequestSize;
    return this;
  }

   /**
   * Specifies the size of the largest LDAP request message that will be allowed by this LDAP Connection handler.
   * @return maxRequestSize
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the size of the largest LDAP request message that will be allowed by this LDAP Connection handler.")

  public String getMaxRequestSize() {
    return maxRequestSize;
  }


  public void setMaxRequestSize(String maxRequestSize) {
    
    
    
    this.maxRequestSize = maxRequestSize;
  }


  public LdapConnectionHandlerShared maxCancelHandlers(Integer maxCancelHandlers) {
    
    
    
    
    this.maxCancelHandlers = maxCancelHandlers;
    return this;
  }

   /**
   * Specifies the maximum number of threads that are used to process cancel and abandon requests from clients.
   * @return maxCancelHandlers
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of threads that are used to process cancel and abandon requests from clients.")

  public Integer getMaxCancelHandlers() {
    return maxCancelHandlers;
  }


  public void setMaxCancelHandlers(Integer maxCancelHandlers) {
    
    
    
    this.maxCancelHandlers = maxCancelHandlers;
  }


  public LdapConnectionHandlerShared numAcceptHandlers(Integer numAcceptHandlers) {
    
    
    
    
    this.numAcceptHandlers = numAcceptHandlers;
    return this;
  }

   /**
   * Specifies the number of threads that are used to accept new client connections, and to perform any initial preparation on those connections that may be needed before the connection can be used to read requests and send responses.
   * @return numAcceptHandlers
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the number of threads that are used to accept new client connections, and to perform any initial preparation on those connections that may be needed before the connection can be used to read requests and send responses.")

  public Integer getNumAcceptHandlers() {
    return numAcceptHandlers;
  }


  public void setNumAcceptHandlers(Integer numAcceptHandlers) {
    
    
    
    this.numAcceptHandlers = numAcceptHandlers;
  }


  public LdapConnectionHandlerShared numRequestHandlers(Integer numRequestHandlers) {
    
    
    
    
    this.numRequestHandlers = numRequestHandlers;
    return this;
  }

   /**
   * Specifies the number of request handlers that are used to read requests from clients.
   * @return numRequestHandlers
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the number of request handlers that are used to read requests from clients.")

  public Integer getNumRequestHandlers() {
    return numRequestHandlers;
  }


  public void setNumRequestHandlers(Integer numRequestHandlers) {
    
    
    
    this.numRequestHandlers = numRequestHandlers;
  }


  public LdapConnectionHandlerShared requestHandlerPerConnection(Boolean requestHandlerPerConnection) {
    
    
    
    
    this.requestHandlerPerConnection = requestHandlerPerConnection;
    return this;
  }

   /**
   * Indicates whether a separate request handler thread should be created for each client connection, which can help avoid starvation of client connections for cases in which one or more clients send large numbers of concurrent asynchronous requests. This should only be used for cases in which a relatively small number of connections will be established at any given time, the connections established will generally be long-lived, and at least one client may send high volumes of asynchronous requests. This property can be used to alleviate possible blocking during long-running TLS negotiation on a single request handler which can result in it being unable to acknowledge further client requests until the TLS negotation completes or times out.
   * @return requestHandlerPerConnection
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether a separate request handler thread should be created for each client connection, which can help avoid starvation of client connections for cases in which one or more clients send large numbers of concurrent asynchronous requests. This should only be used for cases in which a relatively small number of connections will be established at any given time, the connections established will generally be long-lived, and at least one client may send high volumes of asynchronous requests. This property can be used to alleviate possible blocking during long-running TLS negotiation on a single request handler which can result in it being unable to acknowledge further client requests until the TLS negotation completes or times out.")

  public Boolean getRequestHandlerPerConnection() {
    return requestHandlerPerConnection;
  }


  public void setRequestHandlerPerConnection(Boolean requestHandlerPerConnection) {
    
    
    
    this.requestHandlerPerConnection = requestHandlerPerConnection;
  }


  public LdapConnectionHandlerShared sslClientAuthPolicy(EnumconnectionHandlerSslClientAuthPolicyProp sslClientAuthPolicy) {
    
    
    
    
    this.sslClientAuthPolicy = sslClientAuthPolicy;
    return this;
  }

   /**
   * Get sslClientAuthPolicy
   * @return sslClientAuthPolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumconnectionHandlerSslClientAuthPolicyProp getSslClientAuthPolicy() {
    return sslClientAuthPolicy;
  }


  public void setSslClientAuthPolicy(EnumconnectionHandlerSslClientAuthPolicyProp sslClientAuthPolicy) {
    
    
    
    this.sslClientAuthPolicy = sslClientAuthPolicy;
  }


  public LdapConnectionHandlerShared acceptBacklog(Integer acceptBacklog) {
    
    
    
    
    this.acceptBacklog = acceptBacklog;
    return this;
  }

   /**
   * Specifies the maximum number of pending connection attempts that are allowed to queue up in the accept backlog before the server starts rejecting new connection attempts.
   * @return acceptBacklog
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of pending connection attempts that are allowed to queue up in the accept backlog before the server starts rejecting new connection attempts.")

  public Integer getAcceptBacklog() {
    return acceptBacklog;
  }


  public void setAcceptBacklog(Integer acceptBacklog) {
    
    
    
    this.acceptBacklog = acceptBacklog;
  }


  public LdapConnectionHandlerShared sslProtocol(List<String> sslProtocol) {
    
    
    
    
    this.sslProtocol = sslProtocol;
    return this;
  }

  public LdapConnectionHandlerShared addSslProtocolItem(String sslProtocolItem) {
    if (this.sslProtocol == null) {
      this.sslProtocol = new ArrayList<>();
    }
    this.sslProtocol.add(sslProtocolItem);
    return this;
  }

   /**
   * Specifies the names of the TLS protocols that are allowed for use in SSL or StartTLS communication. The set of supported ssl protocols can be viewed via the ssl context monitor entry.
   * @return sslProtocol
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the names of the TLS protocols that are allowed for use in SSL or StartTLS communication. The set of supported ssl protocols can be viewed via the ssl context monitor entry.")

  public List<String> getSslProtocol() {
    return sslProtocol;
  }


  public void setSslProtocol(List<String> sslProtocol) {
    
    
    
    this.sslProtocol = sslProtocol;
  }


  public LdapConnectionHandlerShared sslCipherSuite(List<String> sslCipherSuite) {
    
    
    
    
    this.sslCipherSuite = sslCipherSuite;
    return this;
  }

  public LdapConnectionHandlerShared addSslCipherSuiteItem(String sslCipherSuiteItem) {
    if (this.sslCipherSuite == null) {
      this.sslCipherSuite = new ArrayList<>();
    }
    this.sslCipherSuite.add(sslCipherSuiteItem);
    return this;
  }

   /**
   * Specifies the names of the TLS cipher suites that are allowed for use in SSL or StartTLS communication. The set of supported cipher suites can be viewed via the ssl context monitor entry.
   * @return sslCipherSuite
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the names of the TLS cipher suites that are allowed for use in SSL or StartTLS communication. The set of supported cipher suites can be viewed via the ssl context monitor entry.")

  public List<String> getSslCipherSuite() {
    return sslCipherSuite;
  }


  public void setSslCipherSuite(List<String> sslCipherSuite) {
    
    
    
    this.sslCipherSuite = sslCipherSuite;
  }


  public LdapConnectionHandlerShared maxBlockedWriteTimeLimit(String maxBlockedWriteTimeLimit) {
    
    
    
    
    this.maxBlockedWriteTimeLimit = maxBlockedWriteTimeLimit;
    return this;
  }

   /**
   * Specifies the maximum length of time that attempts to write data to LDAP clients should be allowed to block.
   * @return maxBlockedWriteTimeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum length of time that attempts to write data to LDAP clients should be allowed to block.")

  public String getMaxBlockedWriteTimeLimit() {
    return maxBlockedWriteTimeLimit;
  }


  public void setMaxBlockedWriteTimeLimit(String maxBlockedWriteTimeLimit) {
    
    
    
    this.maxBlockedWriteTimeLimit = maxBlockedWriteTimeLimit;
  }


  public LdapConnectionHandlerShared autoAuthenticateUsingClientCertificate(Boolean autoAuthenticateUsingClientCertificate) {
    
    
    
    
    this.autoAuthenticateUsingClientCertificate = autoAuthenticateUsingClientCertificate;
    return this;
  }

   /**
   * Indicates whether to attempt to automatically authenticate a client connection that has established a secure communication channel (using either SSL or StartTLS) and presented its own client certificate. Generally, clients should use the SASL EXTERNAL mechanism to authenticate using a client certificate, but some clients may not support that capability and/or may expect automatic authentication.
   * @return autoAuthenticateUsingClientCertificate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether to attempt to automatically authenticate a client connection that has established a secure communication channel (using either SSL or StartTLS) and presented its own client certificate. Generally, clients should use the SASL EXTERNAL mechanism to authenticate using a client certificate, but some clients may not support that capability and/or may expect automatic authentication.")

  public Boolean getAutoAuthenticateUsingClientCertificate() {
    return autoAuthenticateUsingClientCertificate;
  }


  public void setAutoAuthenticateUsingClientCertificate(Boolean autoAuthenticateUsingClientCertificate) {
    
    
    
    this.autoAuthenticateUsingClientCertificate = autoAuthenticateUsingClientCertificate;
  }


  public LdapConnectionHandlerShared closeConnectionsWhenUnavailable(Boolean closeConnectionsWhenUnavailable) {
    
    
    
    
    this.closeConnectionsWhenUnavailable = closeConnectionsWhenUnavailable;
    return this;
  }

   /**
   * Indicates whether all connections associated with this LDAP Connection Handler should be closed and no new connections accepted when the server has determined that it is \&quot;unavailable.\&quot; This allows clients (or a network load balancer) to route requests to another server.
   * @return closeConnectionsWhenUnavailable
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether all connections associated with this LDAP Connection Handler should be closed and no new connections accepted when the server has determined that it is \"unavailable.\" This allows clients (or a network load balancer) to route requests to another server.")

  public Boolean getCloseConnectionsWhenUnavailable() {
    return closeConnectionsWhenUnavailable;
  }


  public void setCloseConnectionsWhenUnavailable(Boolean closeConnectionsWhenUnavailable) {
    
    
    
    this.closeConnectionsWhenUnavailable = closeConnectionsWhenUnavailable;
  }


  public LdapConnectionHandlerShared closeConnectionsOnExplicitGC(Boolean closeConnectionsOnExplicitGC) {
    
    
    
    
    this.closeConnectionsOnExplicitGC = closeConnectionsOnExplicitGC;
    return this;
  }

   /**
   * Indicates whether all connections associated with this LDAP Connection Handler should be closed before an explicit garbage collection is performed to allow clients to route requests to another server.
   * @return closeConnectionsOnExplicitGC
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether all connections associated with this LDAP Connection Handler should be closed before an explicit garbage collection is performed to allow clients to route requests to another server.")

  public Boolean getCloseConnectionsOnExplicitGC() {
    return closeConnectionsOnExplicitGC;
  }


  public void setCloseConnectionsOnExplicitGC(Boolean closeConnectionsOnExplicitGC) {
    
    
    
    this.closeConnectionsOnExplicitGC = closeConnectionsOnExplicitGC;
  }


  public LdapConnectionHandlerShared enabled(Boolean enabled) {
    
    
    
    
    this.enabled = enabled;
    return this;
  }

   /**
   * Indicates whether the Connection Handler is enabled.
   * @return enabled
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates whether the Connection Handler is enabled.")

  public Boolean getEnabled() {
    return enabled;
  }


  public void setEnabled(Boolean enabled) {
    
    
    
    this.enabled = enabled;
  }


  public LdapConnectionHandlerShared allowedClient(List<String> allowedClient) {
    
    
    
    
    this.allowedClient = allowedClient;
    return this;
  }

  public LdapConnectionHandlerShared addAllowedClientItem(String allowedClientItem) {
    if (this.allowedClient == null) {
      this.allowedClient = new ArrayList<>();
    }
    this.allowedClient.add(allowedClientItem);
    return this;
  }

   /**
   * Specifies a set of address masks that determines the addresses of the clients that are allowed to establish connections to this connection handler.
   * @return allowedClient
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies a set of address masks that determines the addresses of the clients that are allowed to establish connections to this connection handler.")

  public List<String> getAllowedClient() {
    return allowedClient;
  }


  public void setAllowedClient(List<String> allowedClient) {
    
    
    
    this.allowedClient = allowedClient;
  }


  public LdapConnectionHandlerShared deniedClient(List<String> deniedClient) {
    
    
    
    
    this.deniedClient = deniedClient;
    return this;
  }

  public LdapConnectionHandlerShared addDeniedClientItem(String deniedClientItem) {
    if (this.deniedClient == null) {
      this.deniedClient = new ArrayList<>();
    }
    this.deniedClient.add(deniedClientItem);
    return this;
  }

   /**
   * Specifies a set of address masks that determines the addresses of the clients that are not allowed to establish connections to this connection handler.
   * @return deniedClient
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies a set of address masks that determines the addresses of the clients that are not allowed to establish connections to this connection handler.")

  public List<String> getDeniedClient() {
    return deniedClient;
  }


  public void setDeniedClient(List<String> deniedClient) {
    
    
    
    this.deniedClient = deniedClient;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the LdapConnectionHandlerShared instance itself
   */
  public LdapConnectionHandlerShared putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LdapConnectionHandlerShared ldapConnectionHandlerShared = (LdapConnectionHandlerShared) o;
    return Objects.equals(this.description, ldapConnectionHandlerShared.description) &&
        Objects.equals(this.schemas, ldapConnectionHandlerShared.schemas) &&
        Objects.equals(this.listenAddress, ldapConnectionHandlerShared.listenAddress) &&
        Objects.equals(this.listenPort, ldapConnectionHandlerShared.listenPort) &&
        Objects.equals(this.useSSL, ldapConnectionHandlerShared.useSSL) &&
        Objects.equals(this.allowStartTLS, ldapConnectionHandlerShared.allowStartTLS) &&
        Objects.equals(this.sslCertNickname, ldapConnectionHandlerShared.sslCertNickname) &&
        Objects.equals(this.keyManagerProvider, ldapConnectionHandlerShared.keyManagerProvider) &&
        Objects.equals(this.trustManagerProvider, ldapConnectionHandlerShared.trustManagerProvider) &&
        Objects.equals(this.allowLDAPV2, ldapConnectionHandlerShared.allowLDAPV2) &&
        Objects.equals(this.useTCPKeepAlive, ldapConnectionHandlerShared.useTCPKeepAlive) &&
        Objects.equals(this.sendRejectionNotice, ldapConnectionHandlerShared.sendRejectionNotice) &&
        Objects.equals(this.failedBindResponseDelay, ldapConnectionHandlerShared.failedBindResponseDelay) &&
        Objects.equals(this.maxRequestSize, ldapConnectionHandlerShared.maxRequestSize) &&
        Objects.equals(this.maxCancelHandlers, ldapConnectionHandlerShared.maxCancelHandlers) &&
        Objects.equals(this.numAcceptHandlers, ldapConnectionHandlerShared.numAcceptHandlers) &&
        Objects.equals(this.numRequestHandlers, ldapConnectionHandlerShared.numRequestHandlers) &&
        Objects.equals(this.requestHandlerPerConnection, ldapConnectionHandlerShared.requestHandlerPerConnection) &&
        Objects.equals(this.sslClientAuthPolicy, ldapConnectionHandlerShared.sslClientAuthPolicy) &&
        Objects.equals(this.acceptBacklog, ldapConnectionHandlerShared.acceptBacklog) &&
        Objects.equals(this.sslProtocol, ldapConnectionHandlerShared.sslProtocol) &&
        Objects.equals(this.sslCipherSuite, ldapConnectionHandlerShared.sslCipherSuite) &&
        Objects.equals(this.maxBlockedWriteTimeLimit, ldapConnectionHandlerShared.maxBlockedWriteTimeLimit) &&
        Objects.equals(this.autoAuthenticateUsingClientCertificate, ldapConnectionHandlerShared.autoAuthenticateUsingClientCertificate) &&
        Objects.equals(this.closeConnectionsWhenUnavailable, ldapConnectionHandlerShared.closeConnectionsWhenUnavailable) &&
        Objects.equals(this.closeConnectionsOnExplicitGC, ldapConnectionHandlerShared.closeConnectionsOnExplicitGC) &&
        Objects.equals(this.enabled, ldapConnectionHandlerShared.enabled) &&
        Objects.equals(this.allowedClient, ldapConnectionHandlerShared.allowedClient) &&
        Objects.equals(this.deniedClient, ldapConnectionHandlerShared.deniedClient)&&
        Objects.equals(this.additionalProperties, ldapConnectionHandlerShared.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, schemas, listenAddress, listenPort, useSSL, allowStartTLS, sslCertNickname, keyManagerProvider, trustManagerProvider, allowLDAPV2, useTCPKeepAlive, sendRejectionNotice, failedBindResponseDelay, maxRequestSize, maxCancelHandlers, numAcceptHandlers, numRequestHandlers, requestHandlerPerConnection, sslClientAuthPolicy, acceptBacklog, sslProtocol, sslCipherSuite, maxBlockedWriteTimeLimit, autoAuthenticateUsingClientCertificate, closeConnectionsWhenUnavailable, closeConnectionsOnExplicitGC, enabled, allowedClient, deniedClient, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LdapConnectionHandlerShared {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    schemas: ").append(toIndentedString(schemas)).append("\n");
    sb.append("    listenAddress: ").append(toIndentedString(listenAddress)).append("\n");
    sb.append("    listenPort: ").append(toIndentedString(listenPort)).append("\n");
    sb.append("    useSSL: ").append(toIndentedString(useSSL)).append("\n");
    sb.append("    allowStartTLS: ").append(toIndentedString(allowStartTLS)).append("\n");
    sb.append("    sslCertNickname: ").append(toIndentedString(sslCertNickname)).append("\n");
    sb.append("    keyManagerProvider: ").append(toIndentedString(keyManagerProvider)).append("\n");
    sb.append("    trustManagerProvider: ").append(toIndentedString(trustManagerProvider)).append("\n");
    sb.append("    allowLDAPV2: ").append(toIndentedString(allowLDAPV2)).append("\n");
    sb.append("    useTCPKeepAlive: ").append(toIndentedString(useTCPKeepAlive)).append("\n");
    sb.append("    sendRejectionNotice: ").append(toIndentedString(sendRejectionNotice)).append("\n");
    sb.append("    failedBindResponseDelay: ").append(toIndentedString(failedBindResponseDelay)).append("\n");
    sb.append("    maxRequestSize: ").append(toIndentedString(maxRequestSize)).append("\n");
    sb.append("    maxCancelHandlers: ").append(toIndentedString(maxCancelHandlers)).append("\n");
    sb.append("    numAcceptHandlers: ").append(toIndentedString(numAcceptHandlers)).append("\n");
    sb.append("    numRequestHandlers: ").append(toIndentedString(numRequestHandlers)).append("\n");
    sb.append("    requestHandlerPerConnection: ").append(toIndentedString(requestHandlerPerConnection)).append("\n");
    sb.append("    sslClientAuthPolicy: ").append(toIndentedString(sslClientAuthPolicy)).append("\n");
    sb.append("    acceptBacklog: ").append(toIndentedString(acceptBacklog)).append("\n");
    sb.append("    sslProtocol: ").append(toIndentedString(sslProtocol)).append("\n");
    sb.append("    sslCipherSuite: ").append(toIndentedString(sslCipherSuite)).append("\n");
    sb.append("    maxBlockedWriteTimeLimit: ").append(toIndentedString(maxBlockedWriteTimeLimit)).append("\n");
    sb.append("    autoAuthenticateUsingClientCertificate: ").append(toIndentedString(autoAuthenticateUsingClientCertificate)).append("\n");
    sb.append("    closeConnectionsWhenUnavailable: ").append(toIndentedString(closeConnectionsWhenUnavailable)).append("\n");
    sb.append("    closeConnectionsOnExplicitGC: ").append(toIndentedString(closeConnectionsOnExplicitGC)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    allowedClient: ").append(toIndentedString(allowedClient)).append("\n");
    sb.append("    deniedClient: ").append(toIndentedString(deniedClient)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("description");
    openapiFields.add("schemas");
    openapiFields.add("listenAddress");
    openapiFields.add("listenPort");
    openapiFields.add("useSSL");
    openapiFields.add("allowStartTLS");
    openapiFields.add("sslCertNickname");
    openapiFields.add("keyManagerProvider");
    openapiFields.add("trustManagerProvider");
    openapiFields.add("allowLDAPV2");
    openapiFields.add("useTCPKeepAlive");
    openapiFields.add("sendRejectionNotice");
    openapiFields.add("failedBindResponseDelay");
    openapiFields.add("maxRequestSize");
    openapiFields.add("maxCancelHandlers");
    openapiFields.add("numAcceptHandlers");
    openapiFields.add("numRequestHandlers");
    openapiFields.add("requestHandlerPerConnection");
    openapiFields.add("sslClientAuthPolicy");
    openapiFields.add("acceptBacklog");
    openapiFields.add("sslProtocol");
    openapiFields.add("sslCipherSuite");
    openapiFields.add("maxBlockedWriteTimeLimit");
    openapiFields.add("autoAuthenticateUsingClientCertificate");
    openapiFields.add("closeConnectionsWhenUnavailable");
    openapiFields.add("closeConnectionsOnExplicitGC");
    openapiFields.add("enabled");
    openapiFields.add("allowedClient");
    openapiFields.add("deniedClient");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("schemas");
    openapiRequiredFields.add("listenPort");
    openapiRequiredFields.add("enabled");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to LdapConnectionHandlerShared
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!LdapConnectionHandlerShared.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LdapConnectionHandlerShared is not found in the empty JSON string", LdapConnectionHandlerShared.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LdapConnectionHandlerShared.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("schemas") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("schemas").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `schemas` to be an array in the JSON string but got `%s`", jsonObj.get("schemas").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("listenAddress") != null && !jsonObj.get("listenAddress").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `listenAddress` to be an array in the JSON string but got `%s`", jsonObj.get("listenAddress").toString()));
      }
      if ((jsonObj.get("sslCertNickname") != null && !jsonObj.get("sslCertNickname").isJsonNull()) && !jsonObj.get("sslCertNickname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sslCertNickname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sslCertNickname").toString()));
      }
      if ((jsonObj.get("keyManagerProvider") != null && !jsonObj.get("keyManagerProvider").isJsonNull()) && !jsonObj.get("keyManagerProvider").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `keyManagerProvider` to be a primitive type in the JSON string but got `%s`", jsonObj.get("keyManagerProvider").toString()));
      }
      if ((jsonObj.get("trustManagerProvider") != null && !jsonObj.get("trustManagerProvider").isJsonNull()) && !jsonObj.get("trustManagerProvider").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trustManagerProvider` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trustManagerProvider").toString()));
      }
      if ((jsonObj.get("failedBindResponseDelay") != null && !jsonObj.get("failedBindResponseDelay").isJsonNull()) && !jsonObj.get("failedBindResponseDelay").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `failedBindResponseDelay` to be a primitive type in the JSON string but got `%s`", jsonObj.get("failedBindResponseDelay").toString()));
      }
      if ((jsonObj.get("maxRequestSize") != null && !jsonObj.get("maxRequestSize").isJsonNull()) && !jsonObj.get("maxRequestSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxRequestSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxRequestSize").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sslProtocol") != null && !jsonObj.get("sslProtocol").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sslProtocol` to be an array in the JSON string but got `%s`", jsonObj.get("sslProtocol").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sslCipherSuite") != null && !jsonObj.get("sslCipherSuite").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sslCipherSuite` to be an array in the JSON string but got `%s`", jsonObj.get("sslCipherSuite").toString()));
      }
      if ((jsonObj.get("maxBlockedWriteTimeLimit") != null && !jsonObj.get("maxBlockedWriteTimeLimit").isJsonNull()) && !jsonObj.get("maxBlockedWriteTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxBlockedWriteTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxBlockedWriteTimeLimit").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedClient") != null && !jsonObj.get("allowedClient").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedClient` to be an array in the JSON string but got `%s`", jsonObj.get("allowedClient").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("deniedClient") != null && !jsonObj.get("deniedClient").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `deniedClient` to be an array in the JSON string but got `%s`", jsonObj.get("deniedClient").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LdapConnectionHandlerShared.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LdapConnectionHandlerShared' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LdapConnectionHandlerShared> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LdapConnectionHandlerShared.class));

       return (TypeAdapter<T>) new TypeAdapter<LdapConnectionHandlerShared>() {
           @Override
           public void write(JsonWriter out, LdapConnectionHandlerShared value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public LdapConnectionHandlerShared read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             LdapConnectionHandlerShared instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LdapConnectionHandlerShared given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LdapConnectionHandlerShared
  * @throws IOException if the JSON string is invalid with respect to LdapConnectionHandlerShared
  */
  public static LdapConnectionHandlerShared fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LdapConnectionHandlerShared.class);
  }

 /**
  * Convert an instance of LdapConnectionHandlerShared to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

