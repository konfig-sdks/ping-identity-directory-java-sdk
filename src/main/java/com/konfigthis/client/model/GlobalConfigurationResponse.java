/*
 * PingData Config - OpenAPI 3.0
 * This is the PingData Configuration API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.EnumglobalConfigurationAllowedInsecureTLSProtocolProp;
import com.konfigthis.client.model.EnumglobalConfigurationAttributesModifiableWithIgnoreNoUserModificationRequestControlProp;
import com.konfigthis.client.model.EnumglobalConfigurationDisabledPrivilegeProp;
import com.konfigthis.client.model.EnumglobalConfigurationInvalidAttributeSyntaxBehaviorProp;
import com.konfigthis.client.model.EnumglobalConfigurationJmxValueBehaviorProp;
import com.konfigthis.client.model.EnumglobalConfigurationSchemaUrn;
import com.konfigthis.client.model.EnumglobalConfigurationSingleStructuralObjectclassBehaviorProp;
import com.konfigthis.client.model.EnumglobalConfigurationStartupErrorLoggerOutputLocationProp;
import com.konfigthis.client.model.EnumglobalConfigurationUnrecoverableDatabaseErrorModeProp;
import com.konfigthis.client.model.EnumglobalConfigurationWritabilityModeProp;
import com.konfigthis.client.model.MetaMeta;
import com.konfigthis.client.model.MetaUrnPingidentitySchemasConfigurationMessages20;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * GlobalConfigurationResponse
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class GlobalConfigurationResponse {
  public static final String SERIALIZED_NAME_SCHEMAS = "schemas";
  @SerializedName(SERIALIZED_NAME_SCHEMAS)
  private List<EnumglobalConfigurationSchemaUrn> schemas = null;

  public static final String SERIALIZED_NAME_INSTANCE_NAME = "instanceName";
  @SerializedName(SERIALIZED_NAME_INSTANCE_NAME)
  private String instanceName;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_CONFIGURATION_SERVER_GROUP = "configurationServerGroup";
  @SerializedName(SERIALIZED_NAME_CONFIGURATION_SERVER_GROUP)
  private String configurationServerGroup;

  public static final String SERIALIZED_NAME_FORCE_AS_MASTER_FOR_MIRRORED_DATA = "forceAsMasterForMirroredData";
  @SerializedName(SERIALIZED_NAME_FORCE_AS_MASTER_FOR_MIRRORED_DATA)
  private Boolean forceAsMasterForMirroredData;

  public static final String SERIALIZED_NAME_ENCRYPT_DATA = "encryptData";
  @SerializedName(SERIALIZED_NAME_ENCRYPT_DATA)
  private Boolean encryptData;

  public static final String SERIALIZED_NAME_ENCRYPTION_SETTINGS_CIPHER_STREAM_PROVIDER = "encryptionSettingsCipherStreamProvider";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_SETTINGS_CIPHER_STREAM_PROVIDER)
  private String encryptionSettingsCipherStreamProvider;

  public static final String SERIALIZED_NAME_ENCRYPT_BACKUPS_BY_DEFAULT = "encryptBackupsByDefault";
  @SerializedName(SERIALIZED_NAME_ENCRYPT_BACKUPS_BY_DEFAULT)
  private Boolean encryptBackupsByDefault;

  public static final String SERIALIZED_NAME_BACKUP_ENCRYPTION_SETTINGS_DEFINITION_I_D = "backupEncryptionSettingsDefinitionID";
  @SerializedName(SERIALIZED_NAME_BACKUP_ENCRYPTION_SETTINGS_DEFINITION_I_D)
  private String backupEncryptionSettingsDefinitionID;

  public static final String SERIALIZED_NAME_ENCRYPT_L_D_I_F_EXPORTS_BY_DEFAULT = "encryptLDIFExportsByDefault";
  @SerializedName(SERIALIZED_NAME_ENCRYPT_L_D_I_F_EXPORTS_BY_DEFAULT)
  private Boolean encryptLDIFExportsByDefault;

  public static final String SERIALIZED_NAME_LDIF_EXPORT_ENCRYPTION_SETTINGS_DEFINITION_I_D = "ldifExportEncryptionSettingsDefinitionID";
  @SerializedName(SERIALIZED_NAME_LDIF_EXPORT_ENCRYPTION_SETTINGS_DEFINITION_I_D)
  private String ldifExportEncryptionSettingsDefinitionID;

  public static final String SERIALIZED_NAME_AUTOMATICALLY_COMPRESS_ENCRYPTED_L_D_I_F_EXPORTS = "automaticallyCompressEncryptedLDIFExports";
  @SerializedName(SERIALIZED_NAME_AUTOMATICALLY_COMPRESS_ENCRYPTED_L_D_I_F_EXPORTS)
  private Boolean automaticallyCompressEncryptedLDIFExports;

  public static final String SERIALIZED_NAME_REDACT_SENSITIVE_VALUES_IN_CONFIG_LOGS = "redactSensitiveValuesInConfigLogs";
  @SerializedName(SERIALIZED_NAME_REDACT_SENSITIVE_VALUES_IN_CONFIG_LOGS)
  private Boolean redactSensitiveValuesInConfigLogs;

  public static final String SERIALIZED_NAME_SENSITIVE_ATTRIBUTE = "sensitiveAttribute";
  @SerializedName(SERIALIZED_NAME_SENSITIVE_ATTRIBUTE)
  private List<String> sensitiveAttribute = null;

  public static final String SERIALIZED_NAME_REJECT_INSECURE_REQUESTS = "rejectInsecureRequests";
  @SerializedName(SERIALIZED_NAME_REJECT_INSECURE_REQUESTS)
  private Boolean rejectInsecureRequests;

  public static final String SERIALIZED_NAME_ALLOWED_INSECURE_REQUEST_CRITERIA = "allowedInsecureRequestCriteria";
  @SerializedName(SERIALIZED_NAME_ALLOWED_INSECURE_REQUEST_CRITERIA)
  private String allowedInsecureRequestCriteria;

  public static final String SERIALIZED_NAME_REJECT_UNAUTHENTICATED_REQUESTS = "rejectUnauthenticatedRequests";
  @SerializedName(SERIALIZED_NAME_REJECT_UNAUTHENTICATED_REQUESTS)
  private Boolean rejectUnauthenticatedRequests;

  public static final String SERIALIZED_NAME_ALLOWED_UNAUTHENTICATED_REQUEST_CRITERIA = "allowedUnauthenticatedRequestCriteria";
  @SerializedName(SERIALIZED_NAME_ALLOWED_UNAUTHENTICATED_REQUEST_CRITERIA)
  private String allowedUnauthenticatedRequestCriteria;

  public static final String SERIALIZED_NAME_BIND_WITH_D_N_REQUIRES_PASSWORD = "bindWithDNRequiresPassword";
  @SerializedName(SERIALIZED_NAME_BIND_WITH_D_N_REQUIRES_PASSWORD)
  private Boolean bindWithDNRequiresPassword;

  public static final String SERIALIZED_NAME_DISABLED_PRIVILEGE = "disabledPrivilege";
  @SerializedName(SERIALIZED_NAME_DISABLED_PRIVILEGE)
  private List<EnumglobalConfigurationDisabledPrivilegeProp> disabledPrivilege = null;

  public static final String SERIALIZED_NAME_DEFAULT_PASSWORD_POLICY = "defaultPasswordPolicy";
  @SerializedName(SERIALIZED_NAME_DEFAULT_PASSWORD_POLICY)
  private String defaultPasswordPolicy;

  public static final String SERIALIZED_NAME_MAXIMUM_USER_DATA_PASSWORD_POLICIES_TO_CACHE = "maximumUserDataPasswordPoliciesToCache";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_USER_DATA_PASSWORD_POLICIES_TO_CACHE)
  private Integer maximumUserDataPasswordPoliciesToCache;

  public static final String SERIALIZED_NAME_PROXIED_AUTHORIZATION_IDENTITY_MAPPER = "proxiedAuthorizationIdentityMapper";
  @SerializedName(SERIALIZED_NAME_PROXIED_AUTHORIZATION_IDENTITY_MAPPER)
  private String proxiedAuthorizationIdentityMapper;

  public static final String SERIALIZED_NAME_VERIFY_ENTRY_DIGESTS = "verifyEntryDigests";
  @SerializedName(SERIALIZED_NAME_VERIFY_ENTRY_DIGESTS)
  private Boolean verifyEntryDigests;

  public static final String SERIALIZED_NAME_ALLOWED_INSECURE_T_L_S_PROTOCOL = "allowedInsecureTLSProtocol";
  @SerializedName(SERIALIZED_NAME_ALLOWED_INSECURE_T_L_S_PROTOCOL)
  private List<EnumglobalConfigurationAllowedInsecureTLSProtocolProp> allowedInsecureTLSProtocol = null;

  public static final String SERIALIZED_NAME_ALLOW_INSECURE_LOCAL_J_M_X_CONNECTIONS = "allowInsecureLocalJMXConnections";
  @SerializedName(SERIALIZED_NAME_ALLOW_INSECURE_LOCAL_J_M_X_CONNECTIONS)
  private Boolean allowInsecureLocalJMXConnections;

  public static final String SERIALIZED_NAME_DEFAULT_INTERNAL_OPERATION_CLIENT_CONNECTION_POLICY = "defaultInternalOperationClientConnectionPolicy";
  @SerializedName(SERIALIZED_NAME_DEFAULT_INTERNAL_OPERATION_CLIENT_CONNECTION_POLICY)
  private String defaultInternalOperationClientConnectionPolicy;

  public static final String SERIALIZED_NAME_SIZE_LIMIT = "sizeLimit";
  @SerializedName(SERIALIZED_NAME_SIZE_LIMIT)
  private Integer sizeLimit;

  public static final String SERIALIZED_NAME_UNAUTHENTICATED_SIZE_LIMIT = "unauthenticatedSizeLimit";
  @SerializedName(SERIALIZED_NAME_UNAUTHENTICATED_SIZE_LIMIT)
  private Integer unauthenticatedSizeLimit;

  public static final String SERIALIZED_NAME_TIME_LIMIT = "timeLimit";
  @SerializedName(SERIALIZED_NAME_TIME_LIMIT)
  private String timeLimit;

  public static final String SERIALIZED_NAME_UNAUTHENTICATED_TIME_LIMIT = "unauthenticatedTimeLimit";
  @SerializedName(SERIALIZED_NAME_UNAUTHENTICATED_TIME_LIMIT)
  private String unauthenticatedTimeLimit;

  public static final String SERIALIZED_NAME_IDLE_TIME_LIMIT = "idleTimeLimit";
  @SerializedName(SERIALIZED_NAME_IDLE_TIME_LIMIT)
  private String idleTimeLimit;

  public static final String SERIALIZED_NAME_UNAUTHENTICATED_IDLE_TIME_LIMIT = "unauthenticatedIdleTimeLimit";
  @SerializedName(SERIALIZED_NAME_UNAUTHENTICATED_IDLE_TIME_LIMIT)
  private String unauthenticatedIdleTimeLimit;

  public static final String SERIALIZED_NAME_LOOKTHROUGH_LIMIT = "lookthroughLimit";
  @SerializedName(SERIALIZED_NAME_LOOKTHROUGH_LIMIT)
  private Integer lookthroughLimit;

  public static final String SERIALIZED_NAME_UNAUTHENTICATED_LOOKTHROUGH_LIMIT = "unauthenticatedLookthroughLimit";
  @SerializedName(SERIALIZED_NAME_UNAUTHENTICATED_LOOKTHROUGH_LIMIT)
  private Integer unauthenticatedLookthroughLimit;

  public static final String SERIALIZED_NAME_LDAP_JOIN_SIZE_LIMIT = "ldapJoinSizeLimit";
  @SerializedName(SERIALIZED_NAME_LDAP_JOIN_SIZE_LIMIT)
  private Integer ldapJoinSizeLimit;

  public static final String SERIALIZED_NAME_MAXIMUM_CONCURRENT_CONNECTIONS = "maximumConcurrentConnections";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_CONCURRENT_CONNECTIONS)
  private Integer maximumConcurrentConnections;

  public static final String SERIALIZED_NAME_MAXIMUM_CONCURRENT_CONNECTIONS_PER_I_P_ADDRESS = "maximumConcurrentConnectionsPerIPAddress";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_CONCURRENT_CONNECTIONS_PER_I_P_ADDRESS)
  private Integer maximumConcurrentConnectionsPerIPAddress;

  public static final String SERIALIZED_NAME_MAXIMUM_CONCURRENT_CONNECTIONS_PER_BIND_D_N = "maximumConcurrentConnectionsPerBindDN";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_CONCURRENT_CONNECTIONS_PER_BIND_D_N)
  private Integer maximumConcurrentConnectionsPerBindDN;

  public static final String SERIALIZED_NAME_MAXIMUM_CONCURRENT_UNINDEXED_SEARCHES = "maximumConcurrentUnindexedSearches";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_CONCURRENT_UNINDEXED_SEARCHES)
  private Integer maximumConcurrentUnindexedSearches;

  public static final String SERIALIZED_NAME_MAXIMUM_ATTRIBUTES_PER_ADD_REQUEST = "maximumAttributesPerAddRequest";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_ATTRIBUTES_PER_ADD_REQUEST)
  private Integer maximumAttributesPerAddRequest;

  public static final String SERIALIZED_NAME_MAXIMUM_MODIFICATIONS_PER_MODIFY_REQUEST = "maximumModificationsPerModifyRequest";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_MODIFICATIONS_PER_MODIFY_REQUEST)
  private Integer maximumModificationsPerModifyRequest;

  public static final String SERIALIZED_NAME_BACKGROUND_THREAD_FOR_EACH_PERSISTENT_SEARCH = "backgroundThreadForEachPersistentSearch";
  @SerializedName(SERIALIZED_NAME_BACKGROUND_THREAD_FOR_EACH_PERSISTENT_SEARCH)
  private Boolean backgroundThreadForEachPersistentSearch;

  public static final String SERIALIZED_NAME_ALLOW_ATTRIBUTE_NAME_EXCEPTIONS = "allowAttributeNameExceptions";
  @SerializedName(SERIALIZED_NAME_ALLOW_ATTRIBUTE_NAME_EXCEPTIONS)
  private Boolean allowAttributeNameExceptions;

  public static final String SERIALIZED_NAME_INVALID_ATTRIBUTE_SYNTAX_BEHAVIOR = "invalidAttributeSyntaxBehavior";
  @SerializedName(SERIALIZED_NAME_INVALID_ATTRIBUTE_SYNTAX_BEHAVIOR)
  private EnumglobalConfigurationInvalidAttributeSyntaxBehaviorProp invalidAttributeSyntaxBehavior;

  public static final String SERIALIZED_NAME_PERMIT_SYNTAX_VIOLATIONS_FOR_ATTRIBUTE = "permitSyntaxViolationsForAttribute";
  @SerializedName(SERIALIZED_NAME_PERMIT_SYNTAX_VIOLATIONS_FOR_ATTRIBUTE)
  private List<String> permitSyntaxViolationsForAttribute = null;

  public static final String SERIALIZED_NAME_SINGLE_STRUCTURAL_OBJECTCLASS_BEHAVIOR = "singleStructuralObjectclassBehavior";
  @SerializedName(SERIALIZED_NAME_SINGLE_STRUCTURAL_OBJECTCLASS_BEHAVIOR)
  private EnumglobalConfigurationSingleStructuralObjectclassBehaviorProp singleStructuralObjectclassBehavior;

  public static final String SERIALIZED_NAME_ATTRIBUTES_MODIFIABLE_WITH_IGNORE_NO_USER_MODIFICATION_REQUEST_CONTROL = "attributesModifiableWithIgnoreNoUserModificationRequestControl";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTES_MODIFIABLE_WITH_IGNORE_NO_USER_MODIFICATION_REQUEST_CONTROL)
  private List<EnumglobalConfigurationAttributesModifiableWithIgnoreNoUserModificationRequestControlProp> attributesModifiableWithIgnoreNoUserModificationRequestControl = null;

  public static final String SERIALIZED_NAME_MAXIMUM_SERVER_OUT_LOG_FILE_SIZE = "maximumServerOutLogFileSize";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_SERVER_OUT_LOG_FILE_SIZE)
  private String maximumServerOutLogFileSize;

  public static final String SERIALIZED_NAME_MAXIMUM_SERVER_OUT_LOG_FILE_COUNT = "maximumServerOutLogFileCount";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_SERVER_OUT_LOG_FILE_COUNT)
  private Integer maximumServerOutLogFileCount;

  public static final String SERIALIZED_NAME_STARTUP_ERROR_LOGGER_OUTPUT_LOCATION = "startupErrorLoggerOutputLocation";
  @SerializedName(SERIALIZED_NAME_STARTUP_ERROR_LOGGER_OUTPUT_LOCATION)
  private EnumglobalConfigurationStartupErrorLoggerOutputLocationProp startupErrorLoggerOutputLocation;

  public static final String SERIALIZED_NAME_EXIT_ON_J_V_M_ERROR = "exitOnJVMError";
  @SerializedName(SERIALIZED_NAME_EXIT_ON_J_V_M_ERROR)
  private Boolean exitOnJVMError;

  public static final String SERIALIZED_NAME_SERVER_ERROR_RESULT_CODE = "serverErrorResultCode";
  @SerializedName(SERIALIZED_NAME_SERVER_ERROR_RESULT_CODE)
  private Integer serverErrorResultCode;

  public static final String SERIALIZED_NAME_RESULT_CODE_MAP = "resultCodeMap";
  @SerializedName(SERIALIZED_NAME_RESULT_CODE_MAP)
  private String resultCodeMap;

  public static final String SERIALIZED_NAME_RETURN_BIND_ERROR_MESSAGES = "returnBindErrorMessages";
  @SerializedName(SERIALIZED_NAME_RETURN_BIND_ERROR_MESSAGES)
  private Boolean returnBindErrorMessages;

  public static final String SERIALIZED_NAME_NOTIFY_ABANDONED_OPERATIONS = "notifyAbandonedOperations";
  @SerializedName(SERIALIZED_NAME_NOTIFY_ABANDONED_OPERATIONS)
  private Boolean notifyAbandonedOperations;

  public static final String SERIALIZED_NAME_DUPLICATE_ERROR_LOG_LIMIT = "duplicateErrorLogLimit";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_ERROR_LOG_LIMIT)
  private Integer duplicateErrorLogLimit;

  public static final String SERIALIZED_NAME_DUPLICATE_ERROR_LOG_TIME_LIMIT = "duplicateErrorLogTimeLimit";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_ERROR_LOG_TIME_LIMIT)
  private String duplicateErrorLogTimeLimit;

  public static final String SERIALIZED_NAME_DUPLICATE_ALERT_LIMIT = "duplicateAlertLimit";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_ALERT_LIMIT)
  private Integer duplicateAlertLimit;

  public static final String SERIALIZED_NAME_DUPLICATE_ALERT_TIME_LIMIT = "duplicateAlertTimeLimit";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_ALERT_TIME_LIMIT)
  private String duplicateAlertTimeLimit;

  public static final String SERIALIZED_NAME_WRITABILITY_MODE = "writabilityMode";
  @SerializedName(SERIALIZED_NAME_WRITABILITY_MODE)
  private EnumglobalConfigurationWritabilityModeProp writabilityMode;

  public static final String SERIALIZED_NAME_USE_SHARED_DATABASE_CACHE_ACROSS_ALL_LOCAL_D_B_BACKENDS = "useSharedDatabaseCacheAcrossAllLocalDBBackends";
  @SerializedName(SERIALIZED_NAME_USE_SHARED_DATABASE_CACHE_ACROSS_ALL_LOCAL_D_B_BACKENDS)
  private Boolean useSharedDatabaseCacheAcrossAllLocalDBBackends;

  public static final String SERIALIZED_NAME_SHARED_LOCAL_D_B_BACKEND_DATABASE_CACHE_PERCENT = "sharedLocalDBBackendDatabaseCachePercent";
  @SerializedName(SERIALIZED_NAME_SHARED_LOCAL_D_B_BACKEND_DATABASE_CACHE_PERCENT)
  private Integer sharedLocalDBBackendDatabaseCachePercent;

  public static final String SERIALIZED_NAME_UNRECOVERABLE_DATABASE_ERROR_MODE = "unrecoverableDatabaseErrorMode";
  @SerializedName(SERIALIZED_NAME_UNRECOVERABLE_DATABASE_ERROR_MODE)
  private EnumglobalConfigurationUnrecoverableDatabaseErrorModeProp unrecoverableDatabaseErrorMode;

  public static final String SERIALIZED_NAME_DATABASE_ON_VIRTUALIZED_OR_NETWORK_STORAGE = "databaseOnVirtualizedOrNetworkStorage";
  @SerializedName(SERIALIZED_NAME_DATABASE_ON_VIRTUALIZED_OR_NETWORK_STORAGE)
  private Boolean databaseOnVirtualizedOrNetworkStorage;

  public static final String SERIALIZED_NAME_AUTO_NAME_WITH_ENTRY_U_U_I_D_CONNECTION_CRITERIA = "autoNameWithEntryUUIDConnectionCriteria";
  @SerializedName(SERIALIZED_NAME_AUTO_NAME_WITH_ENTRY_U_U_I_D_CONNECTION_CRITERIA)
  private String autoNameWithEntryUUIDConnectionCriteria;

  public static final String SERIALIZED_NAME_AUTO_NAME_WITH_ENTRY_U_U_I_D_REQUEST_CRITERIA = "autoNameWithEntryUUIDRequestCriteria";
  @SerializedName(SERIALIZED_NAME_AUTO_NAME_WITH_ENTRY_U_U_I_D_REQUEST_CRITERIA)
  private String autoNameWithEntryUUIDRequestCriteria;

  public static final String SERIALIZED_NAME_SOFT_DELETE_POLICY = "softDeletePolicy";
  @SerializedName(SERIALIZED_NAME_SOFT_DELETE_POLICY)
  private String softDeletePolicy;

  public static final String SERIALIZED_NAME_SUBTREE_ACCESSIBILITY_ALERT_TIME_LIMIT = "subtreeAccessibilityAlertTimeLimit";
  @SerializedName(SERIALIZED_NAME_SUBTREE_ACCESSIBILITY_ALERT_TIME_LIMIT)
  private String subtreeAccessibilityAlertTimeLimit;

  public static final String SERIALIZED_NAME_WARN_FOR_BACKENDS_WITH_MULTIPLE_BASE_DNS = "warnForBackendsWithMultipleBaseDns";
  @SerializedName(SERIALIZED_NAME_WARN_FOR_BACKENDS_WITH_MULTIPLE_BASE_DNS)
  private Boolean warnForBackendsWithMultipleBaseDns;

  public static final String SERIALIZED_NAME_FORCED_G_C_PRIME_DURATION = "forcedGCPrimeDuration";
  @SerializedName(SERIALIZED_NAME_FORCED_G_C_PRIME_DURATION)
  private String forcedGCPrimeDuration;

  public static final String SERIALIZED_NAME_REPLICATION_SET_NAME = "replicationSetName";
  @SerializedName(SERIALIZED_NAME_REPLICATION_SET_NAME)
  private String replicationSetName;

  public static final String SERIALIZED_NAME_STARTUP_MIN_REPLICATION_BACKLOG_COUNT = "startupMinReplicationBacklogCount";
  @SerializedName(SERIALIZED_NAME_STARTUP_MIN_REPLICATION_BACKLOG_COUNT)
  private Integer startupMinReplicationBacklogCount;

  public static final String SERIALIZED_NAME_REPLICATION_BACKLOG_COUNT_ALERT_THRESHOLD = "replicationBacklogCountAlertThreshold";
  @SerializedName(SERIALIZED_NAME_REPLICATION_BACKLOG_COUNT_ALERT_THRESHOLD)
  private Integer replicationBacklogCountAlertThreshold;

  public static final String SERIALIZED_NAME_REPLICATION_BACKLOG_DURATION_ALERT_THRESHOLD = "replicationBacklogDurationAlertThreshold";
  @SerializedName(SERIALIZED_NAME_REPLICATION_BACKLOG_DURATION_ALERT_THRESHOLD)
  private String replicationBacklogDurationAlertThreshold;

  public static final String SERIALIZED_NAME_REPLICATION_ASSURANCE_SOURCE_TIMEOUT_SUSPEND_DURATION = "replicationAssuranceSourceTimeoutSuspendDuration";
  @SerializedName(SERIALIZED_NAME_REPLICATION_ASSURANCE_SOURCE_TIMEOUT_SUSPEND_DURATION)
  private String replicationAssuranceSourceTimeoutSuspendDuration;

  public static final String SERIALIZED_NAME_REPLICATION_ASSURANCE_SOURCE_BACKLOG_FAST_START_THRESHOLD = "replicationAssuranceSourceBacklogFastStartThreshold";
  @SerializedName(SERIALIZED_NAME_REPLICATION_ASSURANCE_SOURCE_BACKLOG_FAST_START_THRESHOLD)
  private Integer replicationAssuranceSourceBacklogFastStartThreshold;

  public static final String SERIALIZED_NAME_REPLICATION_HISTORY_LIMIT = "replicationHistoryLimit";
  @SerializedName(SERIALIZED_NAME_REPLICATION_HISTORY_LIMIT)
  private Integer replicationHistoryLimit;

  public static final String SERIALIZED_NAME_ALLOW_INHERITED_REPLICATION_OF_SUBORDINATE_BACKENDS = "allowInheritedReplicationOfSubordinateBackends";
  @SerializedName(SERIALIZED_NAME_ALLOW_INHERITED_REPLICATION_OF_SUBORDINATE_BACKENDS)
  private Boolean allowInheritedReplicationOfSubordinateBackends;

  public static final String SERIALIZED_NAME_REPLICATION_PURGE_OBSOLETE_REPLICAS = "replicationPurgeObsoleteReplicas";
  @SerializedName(SERIALIZED_NAME_REPLICATION_PURGE_OBSOLETE_REPLICAS)
  private Boolean replicationPurgeObsoleteReplicas;

  public static final String SERIALIZED_NAME_SMTP_SERVER = "smtpServer";
  @SerializedName(SERIALIZED_NAME_SMTP_SERVER)
  private List<String> smtpServer = null;

  public static final String SERIALIZED_NAME_MAX_S_M_T_P_CONNECTION_COUNT = "maxSMTPConnectionCount";
  @SerializedName(SERIALIZED_NAME_MAX_S_M_T_P_CONNECTION_COUNT)
  private Integer maxSMTPConnectionCount;

  public static final String SERIALIZED_NAME_MAX_S_M_T_P_CONNECTION_AGE = "maxSMTPConnectionAge";
  @SerializedName(SERIALIZED_NAME_MAX_S_M_T_P_CONNECTION_AGE)
  private String maxSMTPConnectionAge;

  public static final String SERIALIZED_NAME_SMTP_CONNECTION_HEALTH_CHECK_INTERVAL = "smtpConnectionHealthCheckInterval";
  @SerializedName(SERIALIZED_NAME_SMTP_CONNECTION_HEALTH_CHECK_INTERVAL)
  private String smtpConnectionHealthCheckInterval;

  public static final String SERIALIZED_NAME_ALLOWED_TASK = "allowedTask";
  @SerializedName(SERIALIZED_NAME_ALLOWED_TASK)
  private List<String> allowedTask = null;

  public static final String SERIALIZED_NAME_ENABLE_SUB_OPERATION_TIMER = "enableSubOperationTimer";
  @SerializedName(SERIALIZED_NAME_ENABLE_SUB_OPERATION_TIMER)
  private Boolean enableSubOperationTimer;

  public static final String SERIALIZED_NAME_MAXIMUM_SHUTDOWN_TIME = "maximumShutdownTime";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_SHUTDOWN_TIME)
  private String maximumShutdownTime;

  public static final String SERIALIZED_NAME_NETWORK_ADDRESS_CACHE_T_T_L = "networkAddressCacheTTL";
  @SerializedName(SERIALIZED_NAME_NETWORK_ADDRESS_CACHE_T_T_L)
  private String networkAddressCacheTTL;

  public static final String SERIALIZED_NAME_NETWORK_ADDRESS_OUTAGE_CACHE_ENABLED = "networkAddressOutageCacheEnabled";
  @SerializedName(SERIALIZED_NAME_NETWORK_ADDRESS_OUTAGE_CACHE_ENABLED)
  private Boolean networkAddressOutageCacheEnabled;

  public static final String SERIALIZED_NAME_TRACKED_APPLICATION = "trackedApplication";
  @SerializedName(SERIALIZED_NAME_TRACKED_APPLICATION)
  private List<String> trackedApplication = null;

  public static final String SERIALIZED_NAME_JMX_VALUE_BEHAVIOR = "jmxValueBehavior";
  @SerializedName(SERIALIZED_NAME_JMX_VALUE_BEHAVIOR)
  private EnumglobalConfigurationJmxValueBehaviorProp jmxValueBehavior;

  public static final String SERIALIZED_NAME_JMX_USE_LEGACY_MBEAN_NAMES = "jmxUseLegacyMbeanNames";
  @SerializedName(SERIALIZED_NAME_JMX_USE_LEGACY_MBEAN_NAMES)
  private Boolean jmxUseLegacyMbeanNames;

  public static final String SERIALIZED_NAME_META = "meta";
  @SerializedName(SERIALIZED_NAME_META)
  private MetaMeta meta;

  public static final String SERIALIZED_NAME_URN_COLON_PINGIDENTITY_COLON_SCHEMAS_COLON_CONFIGURATION_COLON_MESSAGES_COLON20 = "urn:pingidentity:schemas:configuration:messages:2.0";
  @SerializedName(SERIALIZED_NAME_URN_COLON_PINGIDENTITY_COLON_SCHEMAS_COLON_CONFIGURATION_COLON_MESSAGES_COLON20)
  private MetaUrnPingidentitySchemasConfigurationMessages20 urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;

  public GlobalConfigurationResponse() {
  }

  public GlobalConfigurationResponse schemas(List<EnumglobalConfigurationSchemaUrn> schemas) {
    
    
    
    
    this.schemas = schemas;
    return this;
  }

  public GlobalConfigurationResponse addSchemasItem(EnumglobalConfigurationSchemaUrn schemasItem) {
    if (this.schemas == null) {
      this.schemas = new ArrayList<>();
    }
    this.schemas.add(schemasItem);
    return this;
  }

   /**
   * Get schemas
   * @return schemas
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<EnumglobalConfigurationSchemaUrn> getSchemas() {
    return schemas;
  }


  public void setSchemas(List<EnumglobalConfigurationSchemaUrn> schemas) {
    
    
    
    this.schemas = schemas;
  }


  public GlobalConfigurationResponse instanceName(String instanceName) {
    
    
    
    
    this.instanceName = instanceName;
    return this;
  }

   /**
   * Specifies a name that may be used to uniquely identify this Directory Server instance among other instances in the environment.
   * @return instanceName
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies a name that may be used to uniquely identify this Directory Server instance among other instances in the environment.")

  public String getInstanceName() {
    return instanceName;
  }


  public void setInstanceName(String instanceName) {
    
    
    
    this.instanceName = instanceName;
  }


  public GlobalConfigurationResponse location(String location) {
    
    
    
    
    this.location = location;
    return this;
  }

   /**
   * Specifies the location for this Directory Server. Operations performed which involve communication with other servers may prefer servers in the same location to help ensure low-latency responses.
   * @return location
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the location for this Directory Server. Operations performed which involve communication with other servers may prefer servers in the same location to help ensure low-latency responses.")

  public String getLocation() {
    return location;
  }


  public void setLocation(String location) {
    
    
    
    this.location = location;
  }


  public GlobalConfigurationResponse configurationServerGroup(String configurationServerGroup) {
    
    
    
    
    this.configurationServerGroup = configurationServerGroup;
    return this;
  }

   /**
   * When this property is set, changes made to this server using the console or dsconfig can be automatically applied to all servers in the specified server group.
   * @return configurationServerGroup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When this property is set, changes made to this server using the console or dsconfig can be automatically applied to all servers in the specified server group.")

  public String getConfigurationServerGroup() {
    return configurationServerGroup;
  }


  public void setConfigurationServerGroup(String configurationServerGroup) {
    
    
    
    this.configurationServerGroup = configurationServerGroup;
  }


  public GlobalConfigurationResponse forceAsMasterForMirroredData(Boolean forceAsMasterForMirroredData) {
    
    
    
    
    this.forceAsMasterForMirroredData = forceAsMasterForMirroredData;
    return this;
  }

   /**
   * Indicates whether this server should be forced to assume the master role if no other suitable server is found to act as master or if multiple masters are detected. A master is only needed when changes are made to mirrored data, i.e. data specific to the topology itself and cluster-wide configuration data.
   * @return forceAsMasterForMirroredData
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether this server should be forced to assume the master role if no other suitable server is found to act as master or if multiple masters are detected. A master is only needed when changes are made to mirrored data, i.e. data specific to the topology itself and cluster-wide configuration data.")

  public Boolean getForceAsMasterForMirroredData() {
    return forceAsMasterForMirroredData;
  }


  public void setForceAsMasterForMirroredData(Boolean forceAsMasterForMirroredData) {
    
    
    
    this.forceAsMasterForMirroredData = forceAsMasterForMirroredData;
  }


  public GlobalConfigurationResponse encryptData(Boolean encryptData) {
    
    
    
    
    this.encryptData = encryptData;
    return this;
  }

   /**
   * Indicates whether the Directory Server should encrypt the data that it stores in all components that support it. This may include certain types of backends (including local DB and large attribute backends), the LDAP changelog, and the replication server database.
   * @return encryptData
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should encrypt the data that it stores in all components that support it. This may include certain types of backends (including local DB and large attribute backends), the LDAP changelog, and the replication server database.")

  public Boolean getEncryptData() {
    return encryptData;
  }


  public void setEncryptData(Boolean encryptData) {
    
    
    
    this.encryptData = encryptData;
  }


  public GlobalConfigurationResponse encryptionSettingsCipherStreamProvider(String encryptionSettingsCipherStreamProvider) {
    
    
    
    
    this.encryptionSettingsCipherStreamProvider = encryptionSettingsCipherStreamProvider;
    return this;
  }

   /**
   * Specifies the cipher stream provider that should be used to protect the contents of the encryption settings database.
   * @return encryptionSettingsCipherStreamProvider
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the cipher stream provider that should be used to protect the contents of the encryption settings database.")

  public String getEncryptionSettingsCipherStreamProvider() {
    return encryptionSettingsCipherStreamProvider;
  }


  public void setEncryptionSettingsCipherStreamProvider(String encryptionSettingsCipherStreamProvider) {
    
    
    
    this.encryptionSettingsCipherStreamProvider = encryptionSettingsCipherStreamProvider;
  }


  public GlobalConfigurationResponse encryptBackupsByDefault(Boolean encryptBackupsByDefault) {
    
    
    
    
    this.encryptBackupsByDefault = encryptBackupsByDefault;
    return this;
  }

   /**
   * Indicates whether the server should encrypt backups by default.
   * @return encryptBackupsByDefault
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the server should encrypt backups by default.")

  public Boolean getEncryptBackupsByDefault() {
    return encryptBackupsByDefault;
  }


  public void setEncryptBackupsByDefault(Boolean encryptBackupsByDefault) {
    
    
    
    this.encryptBackupsByDefault = encryptBackupsByDefault;
  }


  public GlobalConfigurationResponse backupEncryptionSettingsDefinitionID(String backupEncryptionSettingsDefinitionID) {
    
    
    
    
    this.backupEncryptionSettingsDefinitionID = backupEncryptionSettingsDefinitionID;
    return this;
  }

   /**
   * The unique identifier for the encryption settings definition to use to generate the encryption key for encrypted backups by default.
   * @return backupEncryptionSettingsDefinitionID
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The unique identifier for the encryption settings definition to use to generate the encryption key for encrypted backups by default.")

  public String getBackupEncryptionSettingsDefinitionID() {
    return backupEncryptionSettingsDefinitionID;
  }


  public void setBackupEncryptionSettingsDefinitionID(String backupEncryptionSettingsDefinitionID) {
    
    
    
    this.backupEncryptionSettingsDefinitionID = backupEncryptionSettingsDefinitionID;
  }


  public GlobalConfigurationResponse encryptLDIFExportsByDefault(Boolean encryptLDIFExportsByDefault) {
    
    
    
    
    this.encryptLDIFExportsByDefault = encryptLDIFExportsByDefault;
    return this;
  }

   /**
   * Indicates whether the server should encrypt LDIF exports by default.
   * @return encryptLDIFExportsByDefault
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the server should encrypt LDIF exports by default.")

  public Boolean getEncryptLDIFExportsByDefault() {
    return encryptLDIFExportsByDefault;
  }


  public void setEncryptLDIFExportsByDefault(Boolean encryptLDIFExportsByDefault) {
    
    
    
    this.encryptLDIFExportsByDefault = encryptLDIFExportsByDefault;
  }


  public GlobalConfigurationResponse ldifExportEncryptionSettingsDefinitionID(String ldifExportEncryptionSettingsDefinitionID) {
    
    
    
    
    this.ldifExportEncryptionSettingsDefinitionID = ldifExportEncryptionSettingsDefinitionID;
    return this;
  }

   /**
   * The unique identifier for the encryption settings definition to use to generate the encryption key for encrypted LDIF exports by default.
   * @return ldifExportEncryptionSettingsDefinitionID
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The unique identifier for the encryption settings definition to use to generate the encryption key for encrypted LDIF exports by default.")

  public String getLdifExportEncryptionSettingsDefinitionID() {
    return ldifExportEncryptionSettingsDefinitionID;
  }


  public void setLdifExportEncryptionSettingsDefinitionID(String ldifExportEncryptionSettingsDefinitionID) {
    
    
    
    this.ldifExportEncryptionSettingsDefinitionID = ldifExportEncryptionSettingsDefinitionID;
  }


  public GlobalConfigurationResponse automaticallyCompressEncryptedLDIFExports(Boolean automaticallyCompressEncryptedLDIFExports) {
    
    
    
    
    this.automaticallyCompressEncryptedLDIFExports = automaticallyCompressEncryptedLDIFExports;
    return this;
  }

   /**
   * Indicates whether to automatically compress LDIF exports that are also encrypted.
   * @return automaticallyCompressEncryptedLDIFExports
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether to automatically compress LDIF exports that are also encrypted.")

  public Boolean getAutomaticallyCompressEncryptedLDIFExports() {
    return automaticallyCompressEncryptedLDIFExports;
  }


  public void setAutomaticallyCompressEncryptedLDIFExports(Boolean automaticallyCompressEncryptedLDIFExports) {
    
    
    
    this.automaticallyCompressEncryptedLDIFExports = automaticallyCompressEncryptedLDIFExports;
  }


  public GlobalConfigurationResponse redactSensitiveValuesInConfigLogs(Boolean redactSensitiveValuesInConfigLogs) {
    
    
    
    
    this.redactSensitiveValuesInConfigLogs = redactSensitiveValuesInConfigLogs;
    return this;
  }

   /**
   * Indicates whether the values of sensitive configuration properties should be redacted when logging configuration changes, including in the configuration audit log, the error log, and the server.out log file.
   * @return redactSensitiveValuesInConfigLogs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the values of sensitive configuration properties should be redacted when logging configuration changes, including in the configuration audit log, the error log, and the server.out log file.")

  public Boolean getRedactSensitiveValuesInConfigLogs() {
    return redactSensitiveValuesInConfigLogs;
  }


  public void setRedactSensitiveValuesInConfigLogs(Boolean redactSensitiveValuesInConfigLogs) {
    
    
    
    this.redactSensitiveValuesInConfigLogs = redactSensitiveValuesInConfigLogs;
  }


  public GlobalConfigurationResponse sensitiveAttribute(List<String> sensitiveAttribute) {
    
    
    
    
    this.sensitiveAttribute = sensitiveAttribute;
    return this;
  }

  public GlobalConfigurationResponse addSensitiveAttributeItem(String sensitiveAttributeItem) {
    if (this.sensitiveAttribute == null) {
      this.sensitiveAttribute = new ArrayList<>();
    }
    this.sensitiveAttribute.add(sensitiveAttributeItem);
    return this;
  }

   /**
   * Provides the ability to indicate that some attributes should be considered sensitive and additional protection should be in place when interacting with those attributes.
   * @return sensitiveAttribute
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Provides the ability to indicate that some attributes should be considered sensitive and additional protection should be in place when interacting with those attributes.")

  public List<String> getSensitiveAttribute() {
    return sensitiveAttribute;
  }


  public void setSensitiveAttribute(List<String> sensitiveAttribute) {
    
    
    
    this.sensitiveAttribute = sensitiveAttribute;
  }


  public GlobalConfigurationResponse rejectInsecureRequests(Boolean rejectInsecureRequests) {
    
    
    
    
    this.rejectInsecureRequests = rejectInsecureRequests;
    return this;
  }

   /**
   * Indicates whether the Directory Server should reject any LDAP request (other than StartTLS) received from a client that is not using an encrypted connection.
   * @return rejectInsecureRequests
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should reject any LDAP request (other than StartTLS) received from a client that is not using an encrypted connection.")

  public Boolean getRejectInsecureRequests() {
    return rejectInsecureRequests;
  }


  public void setRejectInsecureRequests(Boolean rejectInsecureRequests) {
    
    
    
    this.rejectInsecureRequests = rejectInsecureRequests;
  }


  public GlobalConfigurationResponse allowedInsecureRequestCriteria(String allowedInsecureRequestCriteria) {
    
    
    
    
    this.allowedInsecureRequestCriteria = allowedInsecureRequestCriteria;
    return this;
  }

   /**
   * A set of criteria that may be used to match LDAP requests that may be permitted over an insecure connection even if reject-insecure-requests is true. Note that some types of requests will always be permitted, including StartTLS and start administrative session requests.
   * @return allowedInsecureRequestCriteria
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A set of criteria that may be used to match LDAP requests that may be permitted over an insecure connection even if reject-insecure-requests is true. Note that some types of requests will always be permitted, including StartTLS and start administrative session requests.")

  public String getAllowedInsecureRequestCriteria() {
    return allowedInsecureRequestCriteria;
  }


  public void setAllowedInsecureRequestCriteria(String allowedInsecureRequestCriteria) {
    
    
    
    this.allowedInsecureRequestCriteria = allowedInsecureRequestCriteria;
  }


  public GlobalConfigurationResponse rejectUnauthenticatedRequests(Boolean rejectUnauthenticatedRequests) {
    
    
    
    
    this.rejectUnauthenticatedRequests = rejectUnauthenticatedRequests;
    return this;
  }

   /**
   * Indicates whether the Directory Server should reject any LDAP request (other than bind or StartTLS requests) received from a client that has not yet been authenticated, whose last authentication attempt was unsuccessful, or whose last authentication attempt used anonymous authentication.
   * @return rejectUnauthenticatedRequests
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should reject any LDAP request (other than bind or StartTLS requests) received from a client that has not yet been authenticated, whose last authentication attempt was unsuccessful, or whose last authentication attempt used anonymous authentication.")

  public Boolean getRejectUnauthenticatedRequests() {
    return rejectUnauthenticatedRequests;
  }


  public void setRejectUnauthenticatedRequests(Boolean rejectUnauthenticatedRequests) {
    
    
    
    this.rejectUnauthenticatedRequests = rejectUnauthenticatedRequests;
  }


  public GlobalConfigurationResponse allowedUnauthenticatedRequestCriteria(String allowedUnauthenticatedRequestCriteria) {
    
    
    
    
    this.allowedUnauthenticatedRequestCriteria = allowedUnauthenticatedRequestCriteria;
    return this;
  }

   /**
   * A set of criteria that may be used to match LDAP requests that may be permitted over an unauthenticated connection even if reject-unauthenticated-requests is true. Note that some types of requests will always be permitted, including bind, StartTLS, and start administrative session requests.
   * @return allowedUnauthenticatedRequestCriteria
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A set of criteria that may be used to match LDAP requests that may be permitted over an unauthenticated connection even if reject-unauthenticated-requests is true. Note that some types of requests will always be permitted, including bind, StartTLS, and start administrative session requests.")

  public String getAllowedUnauthenticatedRequestCriteria() {
    return allowedUnauthenticatedRequestCriteria;
  }


  public void setAllowedUnauthenticatedRequestCriteria(String allowedUnauthenticatedRequestCriteria) {
    
    
    
    this.allowedUnauthenticatedRequestCriteria = allowedUnauthenticatedRequestCriteria;
  }


  public GlobalConfigurationResponse bindWithDNRequiresPassword(Boolean bindWithDNRequiresPassword) {
    
    
    
    
    this.bindWithDNRequiresPassword = bindWithDNRequiresPassword;
    return this;
  }

   /**
   * Indicates whether the Directory Server should reject any simple bind request that contains a DN but no password.
   * @return bindWithDNRequiresPassword
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should reject any simple bind request that contains a DN but no password.")

  public Boolean getBindWithDNRequiresPassword() {
    return bindWithDNRequiresPassword;
  }


  public void setBindWithDNRequiresPassword(Boolean bindWithDNRequiresPassword) {
    
    
    
    this.bindWithDNRequiresPassword = bindWithDNRequiresPassword;
  }


  public GlobalConfigurationResponse disabledPrivilege(List<EnumglobalConfigurationDisabledPrivilegeProp> disabledPrivilege) {
    
    
    
    
    this.disabledPrivilege = disabledPrivilege;
    return this;
  }

  public GlobalConfigurationResponse addDisabledPrivilegeItem(EnumglobalConfigurationDisabledPrivilegeProp disabledPrivilegeItem) {
    if (this.disabledPrivilege == null) {
      this.disabledPrivilege = new ArrayList<>();
    }
    this.disabledPrivilege.add(disabledPrivilegeItem);
    return this;
  }

   /**
   * Get disabledPrivilege
   * @return disabledPrivilege
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<EnumglobalConfigurationDisabledPrivilegeProp> getDisabledPrivilege() {
    return disabledPrivilege;
  }


  public void setDisabledPrivilege(List<EnumglobalConfigurationDisabledPrivilegeProp> disabledPrivilege) {
    
    
    
    this.disabledPrivilege = disabledPrivilege;
  }


  public GlobalConfigurationResponse defaultPasswordPolicy(String defaultPasswordPolicy) {
    
    
    
    
    this.defaultPasswordPolicy = defaultPasswordPolicy;
    return this;
  }

   /**
   * Specifies the name of the password policy that is in effect for users whose entries do not specify an alternate password policy (either via a real or virtual attribute).
   * @return defaultPasswordPolicy
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the name of the password policy that is in effect for users whose entries do not specify an alternate password policy (either via a real or virtual attribute).")

  public String getDefaultPasswordPolicy() {
    return defaultPasswordPolicy;
  }


  public void setDefaultPasswordPolicy(String defaultPasswordPolicy) {
    
    
    
    this.defaultPasswordPolicy = defaultPasswordPolicy;
  }


  public GlobalConfigurationResponse maximumUserDataPasswordPoliciesToCache(Integer maximumUserDataPasswordPoliciesToCache) {
    
    
    
    
    this.maximumUserDataPasswordPoliciesToCache = maximumUserDataPasswordPoliciesToCache;
    return this;
  }

   /**
   * Specifies the maximum number of password policies that are defined in the user data (that is, outside of the configuration) that the server should cache in memory for faster access. A value of zero indicates that the server should not cache any user data password policies.
   * @return maximumUserDataPasswordPoliciesToCache
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of password policies that are defined in the user data (that is, outside of the configuration) that the server should cache in memory for faster access. A value of zero indicates that the server should not cache any user data password policies.")

  public Integer getMaximumUserDataPasswordPoliciesToCache() {
    return maximumUserDataPasswordPoliciesToCache;
  }


  public void setMaximumUserDataPasswordPoliciesToCache(Integer maximumUserDataPasswordPoliciesToCache) {
    
    
    
    this.maximumUserDataPasswordPoliciesToCache = maximumUserDataPasswordPoliciesToCache;
  }


  public GlobalConfigurationResponse proxiedAuthorizationIdentityMapper(String proxiedAuthorizationIdentityMapper) {
    
    
    
    
    this.proxiedAuthorizationIdentityMapper = proxiedAuthorizationIdentityMapper;
    return this;
  }

   /**
   * Specifies the name of the identity mapper to map authorization ID values (using the \&quot;u:\&quot; form) provided in the proxied authorization control to the corresponding user entry.
   * @return proxiedAuthorizationIdentityMapper
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the name of the identity mapper to map authorization ID values (using the \"u:\" form) provided in the proxied authorization control to the corresponding user entry.")

  public String getProxiedAuthorizationIdentityMapper() {
    return proxiedAuthorizationIdentityMapper;
  }


  public void setProxiedAuthorizationIdentityMapper(String proxiedAuthorizationIdentityMapper) {
    
    
    
    this.proxiedAuthorizationIdentityMapper = proxiedAuthorizationIdentityMapper;
  }


  public GlobalConfigurationResponse verifyEntryDigests(Boolean verifyEntryDigests) {
    
    
    
    
    this.verifyEntryDigests = verifyEntryDigests;
    return this;
  }

   /**
   * Indicates whether the digest should always be verified whenever an entry containing a digest is decoded. If this is \&quot;true\&quot;, then if a digest exists, it will always be verified. Otherwise, the digest will be written when encoding entries but ignored when decoding entries but may still be available for other verification processing.
   * @return verifyEntryDigests
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the digest should always be verified whenever an entry containing a digest is decoded. If this is \"true\", then if a digest exists, it will always be verified. Otherwise, the digest will be written when encoding entries but ignored when decoding entries but may still be available for other verification processing.")

  public Boolean getVerifyEntryDigests() {
    return verifyEntryDigests;
  }


  public void setVerifyEntryDigests(Boolean verifyEntryDigests) {
    
    
    
    this.verifyEntryDigests = verifyEntryDigests;
  }


  public GlobalConfigurationResponse allowedInsecureTLSProtocol(List<EnumglobalConfigurationAllowedInsecureTLSProtocolProp> allowedInsecureTLSProtocol) {
    
    
    
    
    this.allowedInsecureTLSProtocol = allowedInsecureTLSProtocol;
    return this;
  }

  public GlobalConfigurationResponse addAllowedInsecureTLSProtocolItem(EnumglobalConfigurationAllowedInsecureTLSProtocolProp allowedInsecureTLSProtocolItem) {
    if (this.allowedInsecureTLSProtocol == null) {
      this.allowedInsecureTLSProtocol = new ArrayList<>();
    }
    this.allowedInsecureTLSProtocol.add(allowedInsecureTLSProtocolItem);
    return this;
  }

   /**
   * Get allowedInsecureTLSProtocol
   * @return allowedInsecureTLSProtocol
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<EnumglobalConfigurationAllowedInsecureTLSProtocolProp> getAllowedInsecureTLSProtocol() {
    return allowedInsecureTLSProtocol;
  }


  public void setAllowedInsecureTLSProtocol(List<EnumglobalConfigurationAllowedInsecureTLSProtocolProp> allowedInsecureTLSProtocol) {
    
    
    
    this.allowedInsecureTLSProtocol = allowedInsecureTLSProtocol;
  }


  public GlobalConfigurationResponse allowInsecureLocalJMXConnections(Boolean allowInsecureLocalJMXConnections) {
    
    
    
    
    this.allowInsecureLocalJMXConnections = allowInsecureLocalJMXConnections;
    return this;
  }

   /**
   * Indicates that processes attaching to this server&#39;s local JVM are allowed to access internal data through JMX without the authentication requirements that remote JMX connections are subject to. Please review and understand the data that this option will expose (such as cn&#x3D;monitor) to client applications to ensure there are no security concerns.
   * @return allowInsecureLocalJMXConnections
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates that processes attaching to this server's local JVM are allowed to access internal data through JMX without the authentication requirements that remote JMX connections are subject to. Please review and understand the data that this option will expose (such as cn=monitor) to client applications to ensure there are no security concerns.")

  public Boolean getAllowInsecureLocalJMXConnections() {
    return allowInsecureLocalJMXConnections;
  }


  public void setAllowInsecureLocalJMXConnections(Boolean allowInsecureLocalJMXConnections) {
    
    
    
    this.allowInsecureLocalJMXConnections = allowInsecureLocalJMXConnections;
  }


  public GlobalConfigurationResponse defaultInternalOperationClientConnectionPolicy(String defaultInternalOperationClientConnectionPolicy) {
    
    
    
    
    this.defaultInternalOperationClientConnectionPolicy = defaultInternalOperationClientConnectionPolicy;
    return this;
  }

   /**
   * Specifies the client connection policy that will be used by default for internal operations.
   * @return defaultInternalOperationClientConnectionPolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the client connection policy that will be used by default for internal operations.")

  public String getDefaultInternalOperationClientConnectionPolicy() {
    return defaultInternalOperationClientConnectionPolicy;
  }


  public void setDefaultInternalOperationClientConnectionPolicy(String defaultInternalOperationClientConnectionPolicy) {
    
    
    
    this.defaultInternalOperationClientConnectionPolicy = defaultInternalOperationClientConnectionPolicy;
  }


  public GlobalConfigurationResponse sizeLimit(Integer sizeLimit) {
    
    
    
    
    this.sizeLimit = sizeLimit;
    return this;
  }

   /**
   * Specifies the maximum number of entries that the Directory Server should return to clients by default when processing a search operation.
   * @return sizeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of entries that the Directory Server should return to clients by default when processing a search operation.")

  public Integer getSizeLimit() {
    return sizeLimit;
  }


  public void setSizeLimit(Integer sizeLimit) {
    
    
    
    this.sizeLimit = sizeLimit;
  }


  public GlobalConfigurationResponse unauthenticatedSizeLimit(Integer unauthenticatedSizeLimit) {
    
    
    
    
    this.unauthenticatedSizeLimit = unauthenticatedSizeLimit;
    return this;
  }

   /**
   * The size limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the size-limit property will be applied for both authenticated and unauthenticated connections.
   * @return unauthenticatedSizeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The size limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the size-limit property will be applied for both authenticated and unauthenticated connections.")

  public Integer getUnauthenticatedSizeLimit() {
    return unauthenticatedSizeLimit;
  }


  public void setUnauthenticatedSizeLimit(Integer unauthenticatedSizeLimit) {
    
    
    
    this.unauthenticatedSizeLimit = unauthenticatedSizeLimit;
  }


  public GlobalConfigurationResponse timeLimit(String timeLimit) {
    
    
    
    
    this.timeLimit = timeLimit;
    return this;
  }

   /**
   * Specifies the maximum length of time that the Directory Server should be allowed to spend processing a search operation.
   * @return timeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum length of time that the Directory Server should be allowed to spend processing a search operation.")

  public String getTimeLimit() {
    return timeLimit;
  }


  public void setTimeLimit(String timeLimit) {
    
    
    
    this.timeLimit = timeLimit;
  }


  public GlobalConfigurationResponse unauthenticatedTimeLimit(String unauthenticatedTimeLimit) {
    
    
    
    
    this.unauthenticatedTimeLimit = unauthenticatedTimeLimit;
    return this;
  }

   /**
   * The time limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the time-limit property will be applied for both authenticated and unauthenticated connections.
   * @return unauthenticatedTimeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The time limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the time-limit property will be applied for both authenticated and unauthenticated connections.")

  public String getUnauthenticatedTimeLimit() {
    return unauthenticatedTimeLimit;
  }


  public void setUnauthenticatedTimeLimit(String unauthenticatedTimeLimit) {
    
    
    
    this.unauthenticatedTimeLimit = unauthenticatedTimeLimit;
  }


  public GlobalConfigurationResponse idleTimeLimit(String idleTimeLimit) {
    
    
    
    
    this.idleTimeLimit = idleTimeLimit;
    return this;
  }

   /**
   * Specifies the maximum length of time that a client connection may remain established since its last completed operation.
   * @return idleTimeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum length of time that a client connection may remain established since its last completed operation.")

  public String getIdleTimeLimit() {
    return idleTimeLimit;
  }


  public void setIdleTimeLimit(String idleTimeLimit) {
    
    
    
    this.idleTimeLimit = idleTimeLimit;
  }


  public GlobalConfigurationResponse unauthenticatedIdleTimeLimit(String unauthenticatedIdleTimeLimit) {
    
    
    
    
    this.unauthenticatedIdleTimeLimit = unauthenticatedIdleTimeLimit;
    return this;
  }

   /**
   * The idle-time-limit limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the idle-time-limit property will be applied for both authenticated and unauthenticated connections.
   * @return unauthenticatedIdleTimeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The idle-time-limit limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the idle-time-limit property will be applied for both authenticated and unauthenticated connections.")

  public String getUnauthenticatedIdleTimeLimit() {
    return unauthenticatedIdleTimeLimit;
  }


  public void setUnauthenticatedIdleTimeLimit(String unauthenticatedIdleTimeLimit) {
    
    
    
    this.unauthenticatedIdleTimeLimit = unauthenticatedIdleTimeLimit;
  }


  public GlobalConfigurationResponse lookthroughLimit(Integer lookthroughLimit) {
    
    
    
    
    this.lookthroughLimit = lookthroughLimit;
    return this;
  }

   /**
   * Specifies the maximum number of entries that the Directory Server should \&quot;look through\&quot; in the course of processing a search request.
   * @return lookthroughLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of entries that the Directory Server should \"look through\" in the course of processing a search request.")

  public Integer getLookthroughLimit() {
    return lookthroughLimit;
  }


  public void setLookthroughLimit(Integer lookthroughLimit) {
    
    
    
    this.lookthroughLimit = lookthroughLimit;
  }


  public GlobalConfigurationResponse unauthenticatedLookthroughLimit(Integer unauthenticatedLookthroughLimit) {
    
    
    
    
    this.unauthenticatedLookthroughLimit = unauthenticatedLookthroughLimit;
    return this;
  }

   /**
   * The lookthrough limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the lookthrough-limit property will be applied for both authenticated and unauthenticated connections.
   * @return unauthenticatedLookthroughLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The lookthrough limit value that will apply for connections from unauthenticated clients. If this is not specified, then the value of the lookthrough-limit property will be applied for both authenticated and unauthenticated connections.")

  public Integer getUnauthenticatedLookthroughLimit() {
    return unauthenticatedLookthroughLimit;
  }


  public void setUnauthenticatedLookthroughLimit(Integer unauthenticatedLookthroughLimit) {
    
    
    
    this.unauthenticatedLookthroughLimit = unauthenticatedLookthroughLimit;
  }


  public GlobalConfigurationResponse ldapJoinSizeLimit(Integer ldapJoinSizeLimit) {
    
    
    
    
    this.ldapJoinSizeLimit = ldapJoinSizeLimit;
    return this;
  }

   /**
   * Specifies the maximum number of entries that may be directly joined with any individual search result entry.
   * @return ldapJoinSizeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of entries that may be directly joined with any individual search result entry.")

  public Integer getLdapJoinSizeLimit() {
    return ldapJoinSizeLimit;
  }


  public void setLdapJoinSizeLimit(Integer ldapJoinSizeLimit) {
    
    
    
    this.ldapJoinSizeLimit = ldapJoinSizeLimit;
  }


  public GlobalConfigurationResponse maximumConcurrentConnections(Integer maximumConcurrentConnections) {
    
    
    
    
    this.maximumConcurrentConnections = maximumConcurrentConnections;
    return this;
  }

   /**
   * Specifies the maximum number of LDAP client connections which may be established to this Directory Server at the same time.
   * @return maximumConcurrentConnections
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of LDAP client connections which may be established to this Directory Server at the same time.")

  public Integer getMaximumConcurrentConnections() {
    return maximumConcurrentConnections;
  }


  public void setMaximumConcurrentConnections(Integer maximumConcurrentConnections) {
    
    
    
    this.maximumConcurrentConnections = maximumConcurrentConnections;
  }


  public GlobalConfigurationResponse maximumConcurrentConnectionsPerIPAddress(Integer maximumConcurrentConnectionsPerIPAddress) {
    
    
    
    
    this.maximumConcurrentConnectionsPerIPAddress = maximumConcurrentConnectionsPerIPAddress;
    return this;
  }

   /**
   * Specifies the maximum number of LDAP client connections originating from the same IP address which may be established to this Directory Server at the same time.
   * @return maximumConcurrentConnectionsPerIPAddress
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of LDAP client connections originating from the same IP address which may be established to this Directory Server at the same time.")

  public Integer getMaximumConcurrentConnectionsPerIPAddress() {
    return maximumConcurrentConnectionsPerIPAddress;
  }


  public void setMaximumConcurrentConnectionsPerIPAddress(Integer maximumConcurrentConnectionsPerIPAddress) {
    
    
    
    this.maximumConcurrentConnectionsPerIPAddress = maximumConcurrentConnectionsPerIPAddress;
  }


  public GlobalConfigurationResponse maximumConcurrentConnectionsPerBindDN(Integer maximumConcurrentConnectionsPerBindDN) {
    
    
    
    
    this.maximumConcurrentConnectionsPerBindDN = maximumConcurrentConnectionsPerBindDN;
    return this;
  }

   /**
   * Specifies the maximum number of LDAP client connections which may be established to this Directory Server at the same time and authenticated as the same user.
   * @return maximumConcurrentConnectionsPerBindDN
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of LDAP client connections which may be established to this Directory Server at the same time and authenticated as the same user.")

  public Integer getMaximumConcurrentConnectionsPerBindDN() {
    return maximumConcurrentConnectionsPerBindDN;
  }


  public void setMaximumConcurrentConnectionsPerBindDN(Integer maximumConcurrentConnectionsPerBindDN) {
    
    
    
    this.maximumConcurrentConnectionsPerBindDN = maximumConcurrentConnectionsPerBindDN;
  }


  public GlobalConfigurationResponse maximumConcurrentUnindexedSearches(Integer maximumConcurrentUnindexedSearches) {
    
    
    
    
    this.maximumConcurrentUnindexedSearches = maximumConcurrentUnindexedSearches;
    return this;
  }

   /**
   * Specifies the maximum number of unindexed searches that may be in progress in this backend at any given time. Any unindexed searches requested while the maximum number of unindexed searches are already being processed will be rejected. A value of zero indicates that no limit will be enforced.
   * @return maximumConcurrentUnindexedSearches
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of unindexed searches that may be in progress in this backend at any given time. Any unindexed searches requested while the maximum number of unindexed searches are already being processed will be rejected. A value of zero indicates that no limit will be enforced.")

  public Integer getMaximumConcurrentUnindexedSearches() {
    return maximumConcurrentUnindexedSearches;
  }


  public void setMaximumConcurrentUnindexedSearches(Integer maximumConcurrentUnindexedSearches) {
    
    
    
    this.maximumConcurrentUnindexedSearches = maximumConcurrentUnindexedSearches;
  }


  public GlobalConfigurationResponse maximumAttributesPerAddRequest(Integer maximumAttributesPerAddRequest) {
    
    
    
    
    this.maximumAttributesPerAddRequest = maximumAttributesPerAddRequest;
    return this;
  }

   /**
   * Specifies the maximum number of attributes that may be included in an add request. This property does not impose any limit on the number of values that an attribute may have.
   * @return maximumAttributesPerAddRequest
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of attributes that may be included in an add request. This property does not impose any limit on the number of values that an attribute may have.")

  public Integer getMaximumAttributesPerAddRequest() {
    return maximumAttributesPerAddRequest;
  }


  public void setMaximumAttributesPerAddRequest(Integer maximumAttributesPerAddRequest) {
    
    
    
    this.maximumAttributesPerAddRequest = maximumAttributesPerAddRequest;
  }


  public GlobalConfigurationResponse maximumModificationsPerModifyRequest(Integer maximumModificationsPerModifyRequest) {
    
    
    
    
    this.maximumModificationsPerModifyRequest = maximumModificationsPerModifyRequest;
    return this;
  }

   /**
   * Specifies the maximum number of modifications that may be included in a modify request. This property does not impose any limit on the number of attribute values that a modification may have.
   * @return maximumModificationsPerModifyRequest
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of modifications that may be included in a modify request. This property does not impose any limit on the number of attribute values that a modification may have.")

  public Integer getMaximumModificationsPerModifyRequest() {
    return maximumModificationsPerModifyRequest;
  }


  public void setMaximumModificationsPerModifyRequest(Integer maximumModificationsPerModifyRequest) {
    
    
    
    this.maximumModificationsPerModifyRequest = maximumModificationsPerModifyRequest;
  }


  public GlobalConfigurationResponse backgroundThreadForEachPersistentSearch(Boolean backgroundThreadForEachPersistentSearch) {
    
    
    
    
    this.backgroundThreadForEachPersistentSearch = backgroundThreadForEachPersistentSearch;
    return this;
  }

   /**
   * Indicates whether the server should use a separate background thread for each persistent search.
   * @return backgroundThreadForEachPersistentSearch
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the server should use a separate background thread for each persistent search.")

  public Boolean getBackgroundThreadForEachPersistentSearch() {
    return backgroundThreadForEachPersistentSearch;
  }


  public void setBackgroundThreadForEachPersistentSearch(Boolean backgroundThreadForEachPersistentSearch) {
    
    
    
    this.backgroundThreadForEachPersistentSearch = backgroundThreadForEachPersistentSearch;
  }


  public GlobalConfigurationResponse allowAttributeNameExceptions(Boolean allowAttributeNameExceptions) {
    
    
    
    
    this.allowAttributeNameExceptions = allowAttributeNameExceptions;
    return this;
  }

   /**
   * Indicates whether the Directory Server should allow underscores in attribute names and allow attribute names to begin with numeric digits (both of which are violations of the LDAP standards).
   * @return allowAttributeNameExceptions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should allow underscores in attribute names and allow attribute names to begin with numeric digits (both of which are violations of the LDAP standards).")

  public Boolean getAllowAttributeNameExceptions() {
    return allowAttributeNameExceptions;
  }


  public void setAllowAttributeNameExceptions(Boolean allowAttributeNameExceptions) {
    
    
    
    this.allowAttributeNameExceptions = allowAttributeNameExceptions;
  }


  public GlobalConfigurationResponse invalidAttributeSyntaxBehavior(EnumglobalConfigurationInvalidAttributeSyntaxBehaviorProp invalidAttributeSyntaxBehavior) {
    
    
    
    
    this.invalidAttributeSyntaxBehavior = invalidAttributeSyntaxBehavior;
    return this;
  }

   /**
   * Get invalidAttributeSyntaxBehavior
   * @return invalidAttributeSyntaxBehavior
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumglobalConfigurationInvalidAttributeSyntaxBehaviorProp getInvalidAttributeSyntaxBehavior() {
    return invalidAttributeSyntaxBehavior;
  }


  public void setInvalidAttributeSyntaxBehavior(EnumglobalConfigurationInvalidAttributeSyntaxBehaviorProp invalidAttributeSyntaxBehavior) {
    
    
    
    this.invalidAttributeSyntaxBehavior = invalidAttributeSyntaxBehavior;
  }


  public GlobalConfigurationResponse permitSyntaxViolationsForAttribute(List<String> permitSyntaxViolationsForAttribute) {
    
    
    
    
    this.permitSyntaxViolationsForAttribute = permitSyntaxViolationsForAttribute;
    return this;
  }

  public GlobalConfigurationResponse addPermitSyntaxViolationsForAttributeItem(String permitSyntaxViolationsForAttributeItem) {
    if (this.permitSyntaxViolationsForAttribute == null) {
      this.permitSyntaxViolationsForAttribute = new ArrayList<>();
    }
    this.permitSyntaxViolationsForAttribute.add(permitSyntaxViolationsForAttributeItem);
    return this;
  }

   /**
   * Specifies a set of attribute types for which the server will permit values that do not conform to the associated attribute syntax.
   * @return permitSyntaxViolationsForAttribute
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies a set of attribute types for which the server will permit values that do not conform to the associated attribute syntax.")

  public List<String> getPermitSyntaxViolationsForAttribute() {
    return permitSyntaxViolationsForAttribute;
  }


  public void setPermitSyntaxViolationsForAttribute(List<String> permitSyntaxViolationsForAttribute) {
    
    
    
    this.permitSyntaxViolationsForAttribute = permitSyntaxViolationsForAttribute;
  }


  public GlobalConfigurationResponse singleStructuralObjectclassBehavior(EnumglobalConfigurationSingleStructuralObjectclassBehaviorProp singleStructuralObjectclassBehavior) {
    
    
    
    
    this.singleStructuralObjectclassBehavior = singleStructuralObjectclassBehavior;
    return this;
  }

   /**
   * Get singleStructuralObjectclassBehavior
   * @return singleStructuralObjectclassBehavior
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumglobalConfigurationSingleStructuralObjectclassBehaviorProp getSingleStructuralObjectclassBehavior() {
    return singleStructuralObjectclassBehavior;
  }


  public void setSingleStructuralObjectclassBehavior(EnumglobalConfigurationSingleStructuralObjectclassBehaviorProp singleStructuralObjectclassBehavior) {
    
    
    
    this.singleStructuralObjectclassBehavior = singleStructuralObjectclassBehavior;
  }


  public GlobalConfigurationResponse attributesModifiableWithIgnoreNoUserModificationRequestControl(List<EnumglobalConfigurationAttributesModifiableWithIgnoreNoUserModificationRequestControlProp> attributesModifiableWithIgnoreNoUserModificationRequestControl) {
    
    
    
    
    this.attributesModifiableWithIgnoreNoUserModificationRequestControl = attributesModifiableWithIgnoreNoUserModificationRequestControl;
    return this;
  }

  public GlobalConfigurationResponse addAttributesModifiableWithIgnoreNoUserModificationRequestControlItem(EnumglobalConfigurationAttributesModifiableWithIgnoreNoUserModificationRequestControlProp attributesModifiableWithIgnoreNoUserModificationRequestControlItem) {
    if (this.attributesModifiableWithIgnoreNoUserModificationRequestControl == null) {
      this.attributesModifiableWithIgnoreNoUserModificationRequestControl = new ArrayList<>();
    }
    this.attributesModifiableWithIgnoreNoUserModificationRequestControl.add(attributesModifiableWithIgnoreNoUserModificationRequestControlItem);
    return this;
  }

   /**
   * Get attributesModifiableWithIgnoreNoUserModificationRequestControl
   * @return attributesModifiableWithIgnoreNoUserModificationRequestControl
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<EnumglobalConfigurationAttributesModifiableWithIgnoreNoUserModificationRequestControlProp> getAttributesModifiableWithIgnoreNoUserModificationRequestControl() {
    return attributesModifiableWithIgnoreNoUserModificationRequestControl;
  }


  public void setAttributesModifiableWithIgnoreNoUserModificationRequestControl(List<EnumglobalConfigurationAttributesModifiableWithIgnoreNoUserModificationRequestControlProp> attributesModifiableWithIgnoreNoUserModificationRequestControl) {
    
    
    
    this.attributesModifiableWithIgnoreNoUserModificationRequestControl = attributesModifiableWithIgnoreNoUserModificationRequestControl;
  }


  public GlobalConfigurationResponse maximumServerOutLogFileSize(String maximumServerOutLogFileSize) {
    
    
    
    
    this.maximumServerOutLogFileSize = maximumServerOutLogFileSize;
    return this;
  }

   /**
   * The maximum allowed size that the server.out log file will be allowed to have. If a write would cause the file to exceed this size, then the current file will be rotated out of place and a new empty file will be created and the message written to it.
   * @return maximumServerOutLogFileSize
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The maximum allowed size that the server.out log file will be allowed to have. If a write would cause the file to exceed this size, then the current file will be rotated out of place and a new empty file will be created and the message written to it.")

  public String getMaximumServerOutLogFileSize() {
    return maximumServerOutLogFileSize;
  }


  public void setMaximumServerOutLogFileSize(String maximumServerOutLogFileSize) {
    
    
    
    this.maximumServerOutLogFileSize = maximumServerOutLogFileSize;
  }


  public GlobalConfigurationResponse maximumServerOutLogFileCount(Integer maximumServerOutLogFileCount) {
    
    
    
    
    this.maximumServerOutLogFileCount = maximumServerOutLogFileCount;
    return this;
  }

   /**
   * The maximum number of server.out log files (including the current active log file) that should be retained. When rotating the log file, if the total number of files exceeds this count, then the oldest file(s) will be removed so that the total number of log files is within this limit.
   * @return maximumServerOutLogFileCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The maximum number of server.out log files (including the current active log file) that should be retained. When rotating the log file, if the total number of files exceeds this count, then the oldest file(s) will be removed so that the total number of log files is within this limit.")

  public Integer getMaximumServerOutLogFileCount() {
    return maximumServerOutLogFileCount;
  }


  public void setMaximumServerOutLogFileCount(Integer maximumServerOutLogFileCount) {
    
    
    
    this.maximumServerOutLogFileCount = maximumServerOutLogFileCount;
  }


  public GlobalConfigurationResponse startupErrorLoggerOutputLocation(EnumglobalConfigurationStartupErrorLoggerOutputLocationProp startupErrorLoggerOutputLocation) {
    
    
    
    
    this.startupErrorLoggerOutputLocation = startupErrorLoggerOutputLocation;
    return this;
  }

   /**
   * Get startupErrorLoggerOutputLocation
   * @return startupErrorLoggerOutputLocation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumglobalConfigurationStartupErrorLoggerOutputLocationProp getStartupErrorLoggerOutputLocation() {
    return startupErrorLoggerOutputLocation;
  }


  public void setStartupErrorLoggerOutputLocation(EnumglobalConfigurationStartupErrorLoggerOutputLocationProp startupErrorLoggerOutputLocation) {
    
    
    
    this.startupErrorLoggerOutputLocation = startupErrorLoggerOutputLocation;
  }


  public GlobalConfigurationResponse exitOnJVMError(Boolean exitOnJVMError) {
    
    
    
    
    this.exitOnJVMError = exitOnJVMError;
    return this;
  }

   /**
   * Indicates whether the Directory Server should be shut down if a severe error is raised (e.g., an out of memory error) which may prevent the JVM from continuing to run properly.
   * @return exitOnJVMError
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should be shut down if a severe error is raised (e.g., an out of memory error) which may prevent the JVM from continuing to run properly.")

  public Boolean getExitOnJVMError() {
    return exitOnJVMError;
  }


  public void setExitOnJVMError(Boolean exitOnJVMError) {
    
    
    
    this.exitOnJVMError = exitOnJVMError;
  }


  public GlobalConfigurationResponse serverErrorResultCode(Integer serverErrorResultCode) {
    
    
    
    
    this.serverErrorResultCode = serverErrorResultCode;
    return this;
  }

   /**
   * Specifies the numeric value of the result code when request processing fails due to an internal server error.
   * @return serverErrorResultCode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the numeric value of the result code when request processing fails due to an internal server error.")

  public Integer getServerErrorResultCode() {
    return serverErrorResultCode;
  }


  public void setServerErrorResultCode(Integer serverErrorResultCode) {
    
    
    
    this.serverErrorResultCode = serverErrorResultCode;
  }


  public GlobalConfigurationResponse resultCodeMap(String resultCodeMap) {
    
    
    
    
    this.resultCodeMap = resultCodeMap;
    return this;
  }

   /**
   * Specifies a result code map that should be used for clients that do not have a map associated with their client connection policy. If the associated client connection policy has a result code map, then that map will be used instead. If no map is associated either with the client connection policy or the global configuration, then an internal default will be used.
   * @return resultCodeMap
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies a result code map that should be used for clients that do not have a map associated with their client connection policy. If the associated client connection policy has a result code map, then that map will be used instead. If no map is associated either with the client connection policy or the global configuration, then an internal default will be used.")

  public String getResultCodeMap() {
    return resultCodeMap;
  }


  public void setResultCodeMap(String resultCodeMap) {
    
    
    
    this.resultCodeMap = resultCodeMap;
  }


  public GlobalConfigurationResponse returnBindErrorMessages(Boolean returnBindErrorMessages) {
    
    
    
    
    this.returnBindErrorMessages = returnBindErrorMessages;
    return this;
  }

   /**
   * Indicates whether responses for failed bind operations should include a message string providing the reason for the authentication failure.
   * @return returnBindErrorMessages
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether responses for failed bind operations should include a message string providing the reason for the authentication failure.")

  public Boolean getReturnBindErrorMessages() {
    return returnBindErrorMessages;
  }


  public void setReturnBindErrorMessages(Boolean returnBindErrorMessages) {
    
    
    
    this.returnBindErrorMessages = returnBindErrorMessages;
  }


  public GlobalConfigurationResponse notifyAbandonedOperations(Boolean notifyAbandonedOperations) {
    
    
    
    
    this.notifyAbandonedOperations = notifyAbandonedOperations;
    return this;
  }

   /**
   * Indicates whether the Directory Server should send a response to any operation that is interrupted via an abandon request.
   * @return notifyAbandonedOperations
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should send a response to any operation that is interrupted via an abandon request.")

  public Boolean getNotifyAbandonedOperations() {
    return notifyAbandonedOperations;
  }


  public void setNotifyAbandonedOperations(Boolean notifyAbandonedOperations) {
    
    
    
    this.notifyAbandonedOperations = notifyAbandonedOperations;
  }


  public GlobalConfigurationResponse duplicateErrorLogLimit(Integer duplicateErrorLogLimit) {
    
    
    
    
    this.duplicateErrorLogLimit = duplicateErrorLogLimit;
    return this;
  }

   /**
   * Specifies the maximum number of duplicate error log messages that should be logged in the time window specified by the duplicate-error-log-time-limit property.
   * @return duplicateErrorLogLimit
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the maximum number of duplicate error log messages that should be logged in the time window specified by the duplicate-error-log-time-limit property.")

  public Integer getDuplicateErrorLogLimit() {
    return duplicateErrorLogLimit;
  }


  public void setDuplicateErrorLogLimit(Integer duplicateErrorLogLimit) {
    
    
    
    this.duplicateErrorLogLimit = duplicateErrorLogLimit;
  }


  public GlobalConfigurationResponse duplicateErrorLogTimeLimit(String duplicateErrorLogTimeLimit) {
    
    
    
    
    this.duplicateErrorLogTimeLimit = duplicateErrorLogTimeLimit;
    return this;
  }

   /**
   * Specifies the length of time that must expire before duplicate log messages above the duplicate-error-log-limit threshold are logged again to the error log.
   * @return duplicateErrorLogTimeLimit
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the length of time that must expire before duplicate log messages above the duplicate-error-log-limit threshold are logged again to the error log.")

  public String getDuplicateErrorLogTimeLimit() {
    return duplicateErrorLogTimeLimit;
  }


  public void setDuplicateErrorLogTimeLimit(String duplicateErrorLogTimeLimit) {
    
    
    
    this.duplicateErrorLogTimeLimit = duplicateErrorLogTimeLimit;
  }


  public GlobalConfigurationResponse duplicateAlertLimit(Integer duplicateAlertLimit) {
    
    
    
    
    this.duplicateAlertLimit = duplicateAlertLimit;
    return this;
  }

   /**
   * Specifies the maximum number of duplicate alert messages that should be sent via the administrative alert framework in the time window specified by the duplicate-alert-time-limit property.
   * @return duplicateAlertLimit
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the maximum number of duplicate alert messages that should be sent via the administrative alert framework in the time window specified by the duplicate-alert-time-limit property.")

  public Integer getDuplicateAlertLimit() {
    return duplicateAlertLimit;
  }


  public void setDuplicateAlertLimit(Integer duplicateAlertLimit) {
    
    
    
    this.duplicateAlertLimit = duplicateAlertLimit;
  }


  public GlobalConfigurationResponse duplicateAlertTimeLimit(String duplicateAlertTimeLimit) {
    
    
    
    
    this.duplicateAlertTimeLimit = duplicateAlertTimeLimit;
    return this;
  }

   /**
   * Specifies the length of time that must expire before duplicate messages are sent via the administrative alert framework.
   * @return duplicateAlertTimeLimit
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the length of time that must expire before duplicate messages are sent via the administrative alert framework.")

  public String getDuplicateAlertTimeLimit() {
    return duplicateAlertTimeLimit;
  }


  public void setDuplicateAlertTimeLimit(String duplicateAlertTimeLimit) {
    
    
    
    this.duplicateAlertTimeLimit = duplicateAlertTimeLimit;
  }


  public GlobalConfigurationResponse writabilityMode(EnumglobalConfigurationWritabilityModeProp writabilityMode) {
    
    
    
    
    this.writabilityMode = writabilityMode;
    return this;
  }

   /**
   * Get writabilityMode
   * @return writabilityMode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumglobalConfigurationWritabilityModeProp getWritabilityMode() {
    return writabilityMode;
  }


  public void setWritabilityMode(EnumglobalConfigurationWritabilityModeProp writabilityMode) {
    
    
    
    this.writabilityMode = writabilityMode;
  }


  public GlobalConfigurationResponse useSharedDatabaseCacheAcrossAllLocalDBBackends(Boolean useSharedDatabaseCacheAcrossAllLocalDBBackends) {
    
    
    
    
    this.useSharedDatabaseCacheAcrossAllLocalDBBackends = useSharedDatabaseCacheAcrossAllLocalDBBackends;
    return this;
  }

   /**
   * Indicates whether the server should use a common database cache that is shared across all local DB backends instead of maintaining a separate cache for each backend.
   * @return useSharedDatabaseCacheAcrossAllLocalDBBackends
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the server should use a common database cache that is shared across all local DB backends instead of maintaining a separate cache for each backend.")

  public Boolean getUseSharedDatabaseCacheAcrossAllLocalDBBackends() {
    return useSharedDatabaseCacheAcrossAllLocalDBBackends;
  }


  public void setUseSharedDatabaseCacheAcrossAllLocalDBBackends(Boolean useSharedDatabaseCacheAcrossAllLocalDBBackends) {
    
    
    
    this.useSharedDatabaseCacheAcrossAllLocalDBBackends = useSharedDatabaseCacheAcrossAllLocalDBBackends;
  }


  public GlobalConfigurationResponse sharedLocalDBBackendDatabaseCachePercent(Integer sharedLocalDBBackendDatabaseCachePercent) {
    
    
    
    
    this.sharedLocalDBBackendDatabaseCachePercent = sharedLocalDBBackendDatabaseCachePercent;
    return this;
  }

   /**
   * Specifies the percentage of the JVM memory to allocate to the database cache that is shared across all local DB backends.
   * @return sharedLocalDBBackendDatabaseCachePercent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the percentage of the JVM memory to allocate to the database cache that is shared across all local DB backends.")

  public Integer getSharedLocalDBBackendDatabaseCachePercent() {
    return sharedLocalDBBackendDatabaseCachePercent;
  }


  public void setSharedLocalDBBackendDatabaseCachePercent(Integer sharedLocalDBBackendDatabaseCachePercent) {
    
    
    
    this.sharedLocalDBBackendDatabaseCachePercent = sharedLocalDBBackendDatabaseCachePercent;
  }


  public GlobalConfigurationResponse unrecoverableDatabaseErrorMode(EnumglobalConfigurationUnrecoverableDatabaseErrorModeProp unrecoverableDatabaseErrorMode) {
    
    
    
    
    this.unrecoverableDatabaseErrorMode = unrecoverableDatabaseErrorMode;
    return this;
  }

   /**
   * Get unrecoverableDatabaseErrorMode
   * @return unrecoverableDatabaseErrorMode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumglobalConfigurationUnrecoverableDatabaseErrorModeProp getUnrecoverableDatabaseErrorMode() {
    return unrecoverableDatabaseErrorMode;
  }


  public void setUnrecoverableDatabaseErrorMode(EnumglobalConfigurationUnrecoverableDatabaseErrorModeProp unrecoverableDatabaseErrorMode) {
    
    
    
    this.unrecoverableDatabaseErrorMode = unrecoverableDatabaseErrorMode;
  }


  public GlobalConfigurationResponse databaseOnVirtualizedOrNetworkStorage(Boolean databaseOnVirtualizedOrNetworkStorage) {
    
    
    
    
    this.databaseOnVirtualizedOrNetworkStorage = databaseOnVirtualizedOrNetworkStorage;
    return this;
  }

   /**
   * This setting provides data integrity options when the Directory Server is installed with a database on a network storage device. A storage device may be accessed directly by a physical server, or indirectly through a virtual machine running on a hypervisor. Enabling this setting will apply changes to all Local DB Backends, the LDAP Changelog Backend, and the replication changelog database.
   * @return databaseOnVirtualizedOrNetworkStorage
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This setting provides data integrity options when the Directory Server is installed with a database on a network storage device. A storage device may be accessed directly by a physical server, or indirectly through a virtual machine running on a hypervisor. Enabling this setting will apply changes to all Local DB Backends, the LDAP Changelog Backend, and the replication changelog database.")

  public Boolean getDatabaseOnVirtualizedOrNetworkStorage() {
    return databaseOnVirtualizedOrNetworkStorage;
  }


  public void setDatabaseOnVirtualizedOrNetworkStorage(Boolean databaseOnVirtualizedOrNetworkStorage) {
    
    
    
    this.databaseOnVirtualizedOrNetworkStorage = databaseOnVirtualizedOrNetworkStorage;
  }


  public GlobalConfigurationResponse autoNameWithEntryUUIDConnectionCriteria(String autoNameWithEntryUUIDConnectionCriteria) {
    
    
    
    
    this.autoNameWithEntryUUIDConnectionCriteria = autoNameWithEntryUUIDConnectionCriteria;
    return this;
  }

   /**
   * Connection criteria that may be used to identify clients whose add requests should use entryUUID as the naming attribute.
   * @return autoNameWithEntryUUIDConnectionCriteria
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Connection criteria that may be used to identify clients whose add requests should use entryUUID as the naming attribute.")

  public String getAutoNameWithEntryUUIDConnectionCriteria() {
    return autoNameWithEntryUUIDConnectionCriteria;
  }


  public void setAutoNameWithEntryUUIDConnectionCriteria(String autoNameWithEntryUUIDConnectionCriteria) {
    
    
    
    this.autoNameWithEntryUUIDConnectionCriteria = autoNameWithEntryUUIDConnectionCriteria;
  }


  public GlobalConfigurationResponse autoNameWithEntryUUIDRequestCriteria(String autoNameWithEntryUUIDRequestCriteria) {
    
    
    
    
    this.autoNameWithEntryUUIDRequestCriteria = autoNameWithEntryUUIDRequestCriteria;
    return this;
  }

   /**
   * Request criteria that may be used to identify add requests that should use entryUUID as the naming attribute.
   * @return autoNameWithEntryUUIDRequestCriteria
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Request criteria that may be used to identify add requests that should use entryUUID as the naming attribute.")

  public String getAutoNameWithEntryUUIDRequestCriteria() {
    return autoNameWithEntryUUIDRequestCriteria;
  }


  public void setAutoNameWithEntryUUIDRequestCriteria(String autoNameWithEntryUUIDRequestCriteria) {
    
    
    
    this.autoNameWithEntryUUIDRequestCriteria = autoNameWithEntryUUIDRequestCriteria;
  }


  public GlobalConfigurationResponse softDeletePolicy(String softDeletePolicy) {
    
    
    
    
    this.softDeletePolicy = softDeletePolicy;
    return this;
  }

   /**
   * Specifies the soft delete policy that will be used by default for delete operations. Soft delete operations introduce the ability to control the server behavior of the delete operation. Instead of performing a permanent delete of an entry, deleted entries can be retained as soft deleted entries by their entryUUID values and are available for undelete at a later time. In addition to a soft delete policy enabling soft deletes, delete operations sent to the server must have the soft delete request control present with sufficient access privileges to access the soft delete request control.
   * @return softDeletePolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the soft delete policy that will be used by default for delete operations. Soft delete operations introduce the ability to control the server behavior of the delete operation. Instead of performing a permanent delete of an entry, deleted entries can be retained as soft deleted entries by their entryUUID values and are available for undelete at a later time. In addition to a soft delete policy enabling soft deletes, delete operations sent to the server must have the soft delete request control present with sufficient access privileges to access the soft delete request control.")

  public String getSoftDeletePolicy() {
    return softDeletePolicy;
  }


  public void setSoftDeletePolicy(String softDeletePolicy) {
    
    
    
    this.softDeletePolicy = softDeletePolicy;
  }


  public GlobalConfigurationResponse subtreeAccessibilityAlertTimeLimit(String subtreeAccessibilityAlertTimeLimit) {
    
    
    
    
    this.subtreeAccessibilityAlertTimeLimit = subtreeAccessibilityAlertTimeLimit;
    return this;
  }

   /**
   * Specifies the length of time that a subtree may remain hidden or read-only before an administrative alert is sent.
   * @return subtreeAccessibilityAlertTimeLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the length of time that a subtree may remain hidden or read-only before an administrative alert is sent.")

  public String getSubtreeAccessibilityAlertTimeLimit() {
    return subtreeAccessibilityAlertTimeLimit;
  }


  public void setSubtreeAccessibilityAlertTimeLimit(String subtreeAccessibilityAlertTimeLimit) {
    
    
    
    this.subtreeAccessibilityAlertTimeLimit = subtreeAccessibilityAlertTimeLimit;
  }


  public GlobalConfigurationResponse warnForBackendsWithMultipleBaseDns(Boolean warnForBackendsWithMultipleBaseDns) {
    
    
    
    
    this.warnForBackendsWithMultipleBaseDns = warnForBackendsWithMultipleBaseDns;
    return this;
  }

   /**
   * Indicates whether the server should issue a warning when enabling a backend that contains multiple base DNs.
   * @return warnForBackendsWithMultipleBaseDns
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the server should issue a warning when enabling a backend that contains multiple base DNs.")

  public Boolean getWarnForBackendsWithMultipleBaseDns() {
    return warnForBackendsWithMultipleBaseDns;
  }


  public void setWarnForBackendsWithMultipleBaseDns(Boolean warnForBackendsWithMultipleBaseDns) {
    
    
    
    this.warnForBackendsWithMultipleBaseDns = warnForBackendsWithMultipleBaseDns;
  }


  public GlobalConfigurationResponse forcedGCPrimeDuration(String forcedGCPrimeDuration) {
    
    
    
    
    this.forcedGCPrimeDuration = forcedGCPrimeDuration;
    return this;
  }

   /**
   * Specifies the minimum length of time required for backend or request processor initialization that will trigger the server to force an explicit garbage collection. A value of \&quot;0 seconds\&quot; indicates that the server should never invoke an explicit garbage collection regardless of the length of time required to initialize the server backends.
   * @return forcedGCPrimeDuration
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the minimum length of time required for backend or request processor initialization that will trigger the server to force an explicit garbage collection. A value of \"0 seconds\" indicates that the server should never invoke an explicit garbage collection regardless of the length of time required to initialize the server backends.")

  public String getForcedGCPrimeDuration() {
    return forcedGCPrimeDuration;
  }


  public void setForcedGCPrimeDuration(String forcedGCPrimeDuration) {
    
    
    
    this.forcedGCPrimeDuration = forcedGCPrimeDuration;
  }


  public GlobalConfigurationResponse replicationSetName(String replicationSetName) {
    
    
    
    
    this.replicationSetName = replicationSetName;
    return this;
  }

   /**
   * The name of the replication set assigned to this Directory Server. Restricted domains are only replicated within instances using the same replication set name.
   * @return replicationSetName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name of the replication set assigned to this Directory Server. Restricted domains are only replicated within instances using the same replication set name.")

  public String getReplicationSetName() {
    return replicationSetName;
  }


  public void setReplicationSetName(String replicationSetName) {
    
    
    
    this.replicationSetName = replicationSetName;
  }


  public GlobalConfigurationResponse startupMinReplicationBacklogCount(Integer startupMinReplicationBacklogCount) {
    
    
    
    
    this.startupMinReplicationBacklogCount = startupMinReplicationBacklogCount;
    return this;
  }

   /**
   * The number of outstanding changes any replica can have before the Directory Server will start accepting connections. The Directory Server may never accept connections if this setting is too low. If you are unsure which value to use, you can use the number of expected updates within a five second interval.
   * @return startupMinReplicationBacklogCount
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The number of outstanding changes any replica can have before the Directory Server will start accepting connections. The Directory Server may never accept connections if this setting is too low. If you are unsure which value to use, you can use the number of expected updates within a five second interval.")

  public Integer getStartupMinReplicationBacklogCount() {
    return startupMinReplicationBacklogCount;
  }


  public void setStartupMinReplicationBacklogCount(Integer startupMinReplicationBacklogCount) {
    
    
    
    this.startupMinReplicationBacklogCount = startupMinReplicationBacklogCount;
  }


  public GlobalConfigurationResponse replicationBacklogCountAlertThreshold(Integer replicationBacklogCountAlertThreshold) {
    
    
    
    
    this.replicationBacklogCountAlertThreshold = replicationBacklogCountAlertThreshold;
    return this;
  }

   /**
   * An alert is sent when the number of outstanding replication changes for the Directory Server has exceeded this threshold for longer than the replication backlog duration alert threshold.
   * @return replicationBacklogCountAlertThreshold
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "An alert is sent when the number of outstanding replication changes for the Directory Server has exceeded this threshold for longer than the replication backlog duration alert threshold.")

  public Integer getReplicationBacklogCountAlertThreshold() {
    return replicationBacklogCountAlertThreshold;
  }


  public void setReplicationBacklogCountAlertThreshold(Integer replicationBacklogCountAlertThreshold) {
    
    
    
    this.replicationBacklogCountAlertThreshold = replicationBacklogCountAlertThreshold;
  }


  public GlobalConfigurationResponse replicationBacklogDurationAlertThreshold(String replicationBacklogDurationAlertThreshold) {
    
    
    
    
    this.replicationBacklogDurationAlertThreshold = replicationBacklogDurationAlertThreshold;
    return this;
  }

   /**
   * An alert is sent when the number of outstanding replication changes for the Directory Server has exceeded the replication backlog count alert threshold for longer than this duration.
   * @return replicationBacklogDurationAlertThreshold
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "An alert is sent when the number of outstanding replication changes for the Directory Server has exceeded the replication backlog count alert threshold for longer than this duration.")

  public String getReplicationBacklogDurationAlertThreshold() {
    return replicationBacklogDurationAlertThreshold;
  }


  public void setReplicationBacklogDurationAlertThreshold(String replicationBacklogDurationAlertThreshold) {
    
    
    
    this.replicationBacklogDurationAlertThreshold = replicationBacklogDurationAlertThreshold;
  }


  public GlobalConfigurationResponse replicationAssuranceSourceTimeoutSuspendDuration(String replicationAssuranceSourceTimeoutSuspendDuration) {
    
    
    
    
    this.replicationAssuranceSourceTimeoutSuspendDuration = replicationAssuranceSourceTimeoutSuspendDuration;
    return this;
  }

   /**
   * The amount of time a replication assurance source (i.e. a peer Directory Server) will be suspended from assurance requirements on this Directory Server if it experiences an assurance timeout.
   * @return replicationAssuranceSourceTimeoutSuspendDuration
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The amount of time a replication assurance source (i.e. a peer Directory Server) will be suspended from assurance requirements on this Directory Server if it experiences an assurance timeout.")

  public String getReplicationAssuranceSourceTimeoutSuspendDuration() {
    return replicationAssuranceSourceTimeoutSuspendDuration;
  }


  public void setReplicationAssuranceSourceTimeoutSuspendDuration(String replicationAssuranceSourceTimeoutSuspendDuration) {
    
    
    
    this.replicationAssuranceSourceTimeoutSuspendDuration = replicationAssuranceSourceTimeoutSuspendDuration;
  }


  public GlobalConfigurationResponse replicationAssuranceSourceBacklogFastStartThreshold(Integer replicationAssuranceSourceBacklogFastStartThreshold) {
    
    
    
    
    this.replicationAssuranceSourceBacklogFastStartThreshold = replicationAssuranceSourceBacklogFastStartThreshold;
    return this;
  }

   /**
   * The maximum number of replication backlog updates a replication assurance source (i.e. a peer Directory Server) can have and be immediately recognized as an available assurance source by this Directory Server.
   * @return replicationAssuranceSourceBacklogFastStartThreshold
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The maximum number of replication backlog updates a replication assurance source (i.e. a peer Directory Server) can have and be immediately recognized as an available assurance source by this Directory Server.")

  public Integer getReplicationAssuranceSourceBacklogFastStartThreshold() {
    return replicationAssuranceSourceBacklogFastStartThreshold;
  }


  public void setReplicationAssuranceSourceBacklogFastStartThreshold(Integer replicationAssuranceSourceBacklogFastStartThreshold) {
    
    
    
    this.replicationAssuranceSourceBacklogFastStartThreshold = replicationAssuranceSourceBacklogFastStartThreshold;
  }


  public GlobalConfigurationResponse replicationHistoryLimit(Integer replicationHistoryLimit) {
    
    
    
    
    this.replicationHistoryLimit = replicationHistoryLimit;
    return this;
  }

   /**
   * Specifies the size limit for historical information.
   * @return replicationHistoryLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the size limit for historical information.")

  public Integer getReplicationHistoryLimit() {
    return replicationHistoryLimit;
  }


  public void setReplicationHistoryLimit(Integer replicationHistoryLimit) {
    
    
    
    this.replicationHistoryLimit = replicationHistoryLimit;
  }


  public GlobalConfigurationResponse allowInheritedReplicationOfSubordinateBackends(Boolean allowInheritedReplicationOfSubordinateBackends) {
    
    
    
    
    this.allowInheritedReplicationOfSubordinateBackends = allowInheritedReplicationOfSubordinateBackends;
    return this;
  }

   /**
   * Allow replication to be inherited by subordinate/child backends.
   * @return allowInheritedReplicationOfSubordinateBackends
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Allow replication to be inherited by subordinate/child backends.")

  public Boolean getAllowInheritedReplicationOfSubordinateBackends() {
    return allowInheritedReplicationOfSubordinateBackends;
  }


  public void setAllowInheritedReplicationOfSubordinateBackends(Boolean allowInheritedReplicationOfSubordinateBackends) {
    
    
    
    this.allowInheritedReplicationOfSubordinateBackends = allowInheritedReplicationOfSubordinateBackends;
  }


  public GlobalConfigurationResponse replicationPurgeObsoleteReplicas(Boolean replicationPurgeObsoleteReplicas) {
    
    
    
    
    this.replicationPurgeObsoleteReplicas = replicationPurgeObsoleteReplicas;
    return this;
  }

   /**
   * Indicates whether state about obsolete replicas is automatically purged.
   * @return replicationPurgeObsoleteReplicas
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether state about obsolete replicas is automatically purged.")

  public Boolean getReplicationPurgeObsoleteReplicas() {
    return replicationPurgeObsoleteReplicas;
  }


  public void setReplicationPurgeObsoleteReplicas(Boolean replicationPurgeObsoleteReplicas) {
    
    
    
    this.replicationPurgeObsoleteReplicas = replicationPurgeObsoleteReplicas;
  }


  public GlobalConfigurationResponse smtpServer(List<String> smtpServer) {
    
    
    
    
    this.smtpServer = smtpServer;
    return this;
  }

  public GlobalConfigurationResponse addSmtpServerItem(String smtpServerItem) {
    if (this.smtpServer == null) {
      this.smtpServer = new ArrayList<>();
    }
    this.smtpServer.add(smtpServerItem);
    return this;
  }

   /**
   * Specifies the set of servers that will be used to send email messages. The order in which the servers are listed indicates the order in which the Directory Server will attempt to use them in the course of sending a message. The first attempt will always go to the server at the top of the list, and servers further down the list will only be used if none of the servers listed above it were able to successfully send the message.
   * @return smtpServer
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the set of servers that will be used to send email messages. The order in which the servers are listed indicates the order in which the Directory Server will attempt to use them in the course of sending a message. The first attempt will always go to the server at the top of the list, and servers further down the list will only be used if none of the servers listed above it were able to successfully send the message.")

  public List<String> getSmtpServer() {
    return smtpServer;
  }


  public void setSmtpServer(List<String> smtpServer) {
    
    
    
    this.smtpServer = smtpServer;
  }


  public GlobalConfigurationResponse maxSMTPConnectionCount(Integer maxSMTPConnectionCount) {
    
    
    
    
    this.maxSMTPConnectionCount = maxSMTPConnectionCount;
    return this;
  }

   /**
   * The maximum number of SMTP connections that will be maintained for delivering email messages.
   * @return maxSMTPConnectionCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The maximum number of SMTP connections that will be maintained for delivering email messages.")

  public Integer getMaxSMTPConnectionCount() {
    return maxSMTPConnectionCount;
  }


  public void setMaxSMTPConnectionCount(Integer maxSMTPConnectionCount) {
    
    
    
    this.maxSMTPConnectionCount = maxSMTPConnectionCount;
  }


  public GlobalConfigurationResponse maxSMTPConnectionAge(String maxSMTPConnectionAge) {
    
    
    
    
    this.maxSMTPConnectionAge = maxSMTPConnectionAge;
    return this;
  }

   /**
   * The maximum length of time that a connection to an SMTP server should be considered valid.
   * @return maxSMTPConnectionAge
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The maximum length of time that a connection to an SMTP server should be considered valid.")

  public String getMaxSMTPConnectionAge() {
    return maxSMTPConnectionAge;
  }


  public void setMaxSMTPConnectionAge(String maxSMTPConnectionAge) {
    
    
    
    this.maxSMTPConnectionAge = maxSMTPConnectionAge;
  }


  public GlobalConfigurationResponse smtpConnectionHealthCheckInterval(String smtpConnectionHealthCheckInterval) {
    
    
    
    
    this.smtpConnectionHealthCheckInterval = smtpConnectionHealthCheckInterval;
    return this;
  }

   /**
   * The length of time between checks to ensure that available SMTP connections are still valid.
   * @return smtpConnectionHealthCheckInterval
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The length of time between checks to ensure that available SMTP connections are still valid.")

  public String getSmtpConnectionHealthCheckInterval() {
    return smtpConnectionHealthCheckInterval;
  }


  public void setSmtpConnectionHealthCheckInterval(String smtpConnectionHealthCheckInterval) {
    
    
    
    this.smtpConnectionHealthCheckInterval = smtpConnectionHealthCheckInterval;
  }


  public GlobalConfigurationResponse allowedTask(List<String> allowedTask) {
    
    
    
    
    this.allowedTask = allowedTask;
    return this;
  }

  public GlobalConfigurationResponse addAllowedTaskItem(String allowedTaskItem) {
    if (this.allowedTask == null) {
      this.allowedTask = new ArrayList<>();
    }
    this.allowedTask.add(allowedTaskItem);
    return this;
  }

   /**
   * Specifies the fully-qualified name of a Java class that may be invoked in the server.
   * @return allowedTask
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the fully-qualified name of a Java class that may be invoked in the server.")

  public List<String> getAllowedTask() {
    return allowedTask;
  }


  public void setAllowedTask(List<String> allowedTask) {
    
    
    
    this.allowedTask = allowedTask;
  }


  public GlobalConfigurationResponse enableSubOperationTimer(Boolean enableSubOperationTimer) {
    
    
    
    
    this.enableSubOperationTimer = enableSubOperationTimer;
    return this;
  }

   /**
   * Indicates whether the Directory Server should attempt to record information about the length of time required to process various phases of an operation. Enabling this feature may impact performance, but could make it easier to identify potential bottlenecks in operation processing.
   * @return enableSubOperationTimer
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the Directory Server should attempt to record information about the length of time required to process various phases of an operation. Enabling this feature may impact performance, but could make it easier to identify potential bottlenecks in operation processing.")

  public Boolean getEnableSubOperationTimer() {
    return enableSubOperationTimer;
  }


  public void setEnableSubOperationTimer(Boolean enableSubOperationTimer) {
    
    
    
    this.enableSubOperationTimer = enableSubOperationTimer;
  }


  public GlobalConfigurationResponse maximumShutdownTime(String maximumShutdownTime) {
    
    
    
    
    this.maximumShutdownTime = maximumShutdownTime;
    return this;
  }

   /**
   * Specifies the maximum amount of time the shutdown of Directory Server may take.
   * @return maximumShutdownTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum amount of time the shutdown of Directory Server may take.")

  public String getMaximumShutdownTime() {
    return maximumShutdownTime;
  }


  public void setMaximumShutdownTime(String maximumShutdownTime) {
    
    
    
    this.maximumShutdownTime = maximumShutdownTime;
  }


  public GlobalConfigurationResponse networkAddressCacheTTL(String networkAddressCacheTTL) {
    
    
    
    
    this.networkAddressCacheTTL = networkAddressCacheTTL;
    return this;
  }

   /**
   * Specifies the length of time that the Directory Server should cache the IP addresses associated with the names of systems with which it interacts.
   * @return networkAddressCacheTTL
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the length of time that the Directory Server should cache the IP addresses associated with the names of systems with which it interacts.")

  public String getNetworkAddressCacheTTL() {
    return networkAddressCacheTTL;
  }


  public void setNetworkAddressCacheTTL(String networkAddressCacheTTL) {
    
    
    
    this.networkAddressCacheTTL = networkAddressCacheTTL;
  }


  public GlobalConfigurationResponse networkAddressOutageCacheEnabled(Boolean networkAddressOutageCacheEnabled) {
    
    
    
    
    this.networkAddressOutageCacheEnabled = networkAddressOutageCacheEnabled;
    return this;
  }

   /**
   * Specifies whether the Directory Server should cache the last valid IP addresses associated with the names of systems with which it interacts with when the domain name service returns an unknown host exception. Java may return an unknown host exception when there is unexpected interruption in domain name service so this setting protects the Directory Server from temporary DNS server outages if previous results have been cached.
   * @return networkAddressOutageCacheEnabled
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies whether the Directory Server should cache the last valid IP addresses associated with the names of systems with which it interacts with when the domain name service returns an unknown host exception. Java may return an unknown host exception when there is unexpected interruption in domain name service so this setting protects the Directory Server from temporary DNS server outages if previous results have been cached.")

  public Boolean getNetworkAddressOutageCacheEnabled() {
    return networkAddressOutageCacheEnabled;
  }


  public void setNetworkAddressOutageCacheEnabled(Boolean networkAddressOutageCacheEnabled) {
    
    
    
    this.networkAddressOutageCacheEnabled = networkAddressOutageCacheEnabled;
  }


  public GlobalConfigurationResponse trackedApplication(List<String> trackedApplication) {
    
    
    
    
    this.trackedApplication = trackedApplication;
    return this;
  }

  public GlobalConfigurationResponse addTrackedApplicationItem(String trackedApplicationItem) {
    if (this.trackedApplication == null) {
      this.trackedApplication = new ArrayList<>();
    }
    this.trackedApplication.add(trackedApplicationItem);
    return this;
  }

   /**
   * Specifies criteria for identifying specific applications that access the server to enable tracking throughput and latency of LDAP operations issued by an application.
   * @return trackedApplication
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies criteria for identifying specific applications that access the server to enable tracking throughput and latency of LDAP operations issued by an application.")

  public List<String> getTrackedApplication() {
    return trackedApplication;
  }


  public void setTrackedApplication(List<String> trackedApplication) {
    
    
    
    this.trackedApplication = trackedApplication;
  }


  public GlobalConfigurationResponse jmxValueBehavior(EnumglobalConfigurationJmxValueBehaviorProp jmxValueBehavior) {
    
    
    
    
    this.jmxValueBehavior = jmxValueBehavior;
    return this;
  }

   /**
   * Get jmxValueBehavior
   * @return jmxValueBehavior
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public EnumglobalConfigurationJmxValueBehaviorProp getJmxValueBehavior() {
    return jmxValueBehavior;
  }


  public void setJmxValueBehavior(EnumglobalConfigurationJmxValueBehaviorProp jmxValueBehavior) {
    
    
    
    this.jmxValueBehavior = jmxValueBehavior;
  }


  public GlobalConfigurationResponse jmxUseLegacyMbeanNames(Boolean jmxUseLegacyMbeanNames) {
    
    
    
    
    this.jmxUseLegacyMbeanNames = jmxUseLegacyMbeanNames;
    return this;
  }

   /**
   * When set to true, the server will use its original, non-standard JMX MBean names for the monitoring MBeans. These include RDN keys of \&quot;Rdn1\&quot; and \&quot;Rdn2\&quot; instead of the recommended \&quot;type\&quot; and \&quot;name\&quot; keys. This should option should only be enabled for installations that have monitoring infrastructure that depends on the old keys.
   * @return jmxUseLegacyMbeanNames
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When set to true, the server will use its original, non-standard JMX MBean names for the monitoring MBeans. These include RDN keys of \"Rdn1\" and \"Rdn2\" instead of the recommended \"type\" and \"name\" keys. This should option should only be enabled for installations that have monitoring infrastructure that depends on the old keys.")

  public Boolean getJmxUseLegacyMbeanNames() {
    return jmxUseLegacyMbeanNames;
  }


  public void setJmxUseLegacyMbeanNames(Boolean jmxUseLegacyMbeanNames) {
    
    
    
    this.jmxUseLegacyMbeanNames = jmxUseLegacyMbeanNames;
  }


  public GlobalConfigurationResponse meta(MetaMeta meta) {
    
    
    
    
    this.meta = meta;
    return this;
  }

   /**
   * Get meta
   * @return meta
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public MetaMeta getMeta() {
    return meta;
  }


  public void setMeta(MetaMeta meta) {
    
    
    
    this.meta = meta;
  }


  public GlobalConfigurationResponse urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20(MetaUrnPingidentitySchemasConfigurationMessages20 urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20) {
    
    
    
    
    this.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20 = urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;
    return this;
  }

   /**
   * Get urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20
   * @return urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public MetaUrnPingidentitySchemasConfigurationMessages20 getUrnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20() {
    return urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;
  }


  public void setUrnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20(MetaUrnPingidentitySchemasConfigurationMessages20 urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20) {
    
    
    
    this.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20 = urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the GlobalConfigurationResponse instance itself
   */
  public GlobalConfigurationResponse putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GlobalConfigurationResponse globalConfigurationResponse = (GlobalConfigurationResponse) o;
    return Objects.equals(this.schemas, globalConfigurationResponse.schemas) &&
        Objects.equals(this.instanceName, globalConfigurationResponse.instanceName) &&
        Objects.equals(this.location, globalConfigurationResponse.location) &&
        Objects.equals(this.configurationServerGroup, globalConfigurationResponse.configurationServerGroup) &&
        Objects.equals(this.forceAsMasterForMirroredData, globalConfigurationResponse.forceAsMasterForMirroredData) &&
        Objects.equals(this.encryptData, globalConfigurationResponse.encryptData) &&
        Objects.equals(this.encryptionSettingsCipherStreamProvider, globalConfigurationResponse.encryptionSettingsCipherStreamProvider) &&
        Objects.equals(this.encryptBackupsByDefault, globalConfigurationResponse.encryptBackupsByDefault) &&
        Objects.equals(this.backupEncryptionSettingsDefinitionID, globalConfigurationResponse.backupEncryptionSettingsDefinitionID) &&
        Objects.equals(this.encryptLDIFExportsByDefault, globalConfigurationResponse.encryptLDIFExportsByDefault) &&
        Objects.equals(this.ldifExportEncryptionSettingsDefinitionID, globalConfigurationResponse.ldifExportEncryptionSettingsDefinitionID) &&
        Objects.equals(this.automaticallyCompressEncryptedLDIFExports, globalConfigurationResponse.automaticallyCompressEncryptedLDIFExports) &&
        Objects.equals(this.redactSensitiveValuesInConfigLogs, globalConfigurationResponse.redactSensitiveValuesInConfigLogs) &&
        Objects.equals(this.sensitiveAttribute, globalConfigurationResponse.sensitiveAttribute) &&
        Objects.equals(this.rejectInsecureRequests, globalConfigurationResponse.rejectInsecureRequests) &&
        Objects.equals(this.allowedInsecureRequestCriteria, globalConfigurationResponse.allowedInsecureRequestCriteria) &&
        Objects.equals(this.rejectUnauthenticatedRequests, globalConfigurationResponse.rejectUnauthenticatedRequests) &&
        Objects.equals(this.allowedUnauthenticatedRequestCriteria, globalConfigurationResponse.allowedUnauthenticatedRequestCriteria) &&
        Objects.equals(this.bindWithDNRequiresPassword, globalConfigurationResponse.bindWithDNRequiresPassword) &&
        Objects.equals(this.disabledPrivilege, globalConfigurationResponse.disabledPrivilege) &&
        Objects.equals(this.defaultPasswordPolicy, globalConfigurationResponse.defaultPasswordPolicy) &&
        Objects.equals(this.maximumUserDataPasswordPoliciesToCache, globalConfigurationResponse.maximumUserDataPasswordPoliciesToCache) &&
        Objects.equals(this.proxiedAuthorizationIdentityMapper, globalConfigurationResponse.proxiedAuthorizationIdentityMapper) &&
        Objects.equals(this.verifyEntryDigests, globalConfigurationResponse.verifyEntryDigests) &&
        Objects.equals(this.allowedInsecureTLSProtocol, globalConfigurationResponse.allowedInsecureTLSProtocol) &&
        Objects.equals(this.allowInsecureLocalJMXConnections, globalConfigurationResponse.allowInsecureLocalJMXConnections) &&
        Objects.equals(this.defaultInternalOperationClientConnectionPolicy, globalConfigurationResponse.defaultInternalOperationClientConnectionPolicy) &&
        Objects.equals(this.sizeLimit, globalConfigurationResponse.sizeLimit) &&
        Objects.equals(this.unauthenticatedSizeLimit, globalConfigurationResponse.unauthenticatedSizeLimit) &&
        Objects.equals(this.timeLimit, globalConfigurationResponse.timeLimit) &&
        Objects.equals(this.unauthenticatedTimeLimit, globalConfigurationResponse.unauthenticatedTimeLimit) &&
        Objects.equals(this.idleTimeLimit, globalConfigurationResponse.idleTimeLimit) &&
        Objects.equals(this.unauthenticatedIdleTimeLimit, globalConfigurationResponse.unauthenticatedIdleTimeLimit) &&
        Objects.equals(this.lookthroughLimit, globalConfigurationResponse.lookthroughLimit) &&
        Objects.equals(this.unauthenticatedLookthroughLimit, globalConfigurationResponse.unauthenticatedLookthroughLimit) &&
        Objects.equals(this.ldapJoinSizeLimit, globalConfigurationResponse.ldapJoinSizeLimit) &&
        Objects.equals(this.maximumConcurrentConnections, globalConfigurationResponse.maximumConcurrentConnections) &&
        Objects.equals(this.maximumConcurrentConnectionsPerIPAddress, globalConfigurationResponse.maximumConcurrentConnectionsPerIPAddress) &&
        Objects.equals(this.maximumConcurrentConnectionsPerBindDN, globalConfigurationResponse.maximumConcurrentConnectionsPerBindDN) &&
        Objects.equals(this.maximumConcurrentUnindexedSearches, globalConfigurationResponse.maximumConcurrentUnindexedSearches) &&
        Objects.equals(this.maximumAttributesPerAddRequest, globalConfigurationResponse.maximumAttributesPerAddRequest) &&
        Objects.equals(this.maximumModificationsPerModifyRequest, globalConfigurationResponse.maximumModificationsPerModifyRequest) &&
        Objects.equals(this.backgroundThreadForEachPersistentSearch, globalConfigurationResponse.backgroundThreadForEachPersistentSearch) &&
        Objects.equals(this.allowAttributeNameExceptions, globalConfigurationResponse.allowAttributeNameExceptions) &&
        Objects.equals(this.invalidAttributeSyntaxBehavior, globalConfigurationResponse.invalidAttributeSyntaxBehavior) &&
        Objects.equals(this.permitSyntaxViolationsForAttribute, globalConfigurationResponse.permitSyntaxViolationsForAttribute) &&
        Objects.equals(this.singleStructuralObjectclassBehavior, globalConfigurationResponse.singleStructuralObjectclassBehavior) &&
        Objects.equals(this.attributesModifiableWithIgnoreNoUserModificationRequestControl, globalConfigurationResponse.attributesModifiableWithIgnoreNoUserModificationRequestControl) &&
        Objects.equals(this.maximumServerOutLogFileSize, globalConfigurationResponse.maximumServerOutLogFileSize) &&
        Objects.equals(this.maximumServerOutLogFileCount, globalConfigurationResponse.maximumServerOutLogFileCount) &&
        Objects.equals(this.startupErrorLoggerOutputLocation, globalConfigurationResponse.startupErrorLoggerOutputLocation) &&
        Objects.equals(this.exitOnJVMError, globalConfigurationResponse.exitOnJVMError) &&
        Objects.equals(this.serverErrorResultCode, globalConfigurationResponse.serverErrorResultCode) &&
        Objects.equals(this.resultCodeMap, globalConfigurationResponse.resultCodeMap) &&
        Objects.equals(this.returnBindErrorMessages, globalConfigurationResponse.returnBindErrorMessages) &&
        Objects.equals(this.notifyAbandonedOperations, globalConfigurationResponse.notifyAbandonedOperations) &&
        Objects.equals(this.duplicateErrorLogLimit, globalConfigurationResponse.duplicateErrorLogLimit) &&
        Objects.equals(this.duplicateErrorLogTimeLimit, globalConfigurationResponse.duplicateErrorLogTimeLimit) &&
        Objects.equals(this.duplicateAlertLimit, globalConfigurationResponse.duplicateAlertLimit) &&
        Objects.equals(this.duplicateAlertTimeLimit, globalConfigurationResponse.duplicateAlertTimeLimit) &&
        Objects.equals(this.writabilityMode, globalConfigurationResponse.writabilityMode) &&
        Objects.equals(this.useSharedDatabaseCacheAcrossAllLocalDBBackends, globalConfigurationResponse.useSharedDatabaseCacheAcrossAllLocalDBBackends) &&
        Objects.equals(this.sharedLocalDBBackendDatabaseCachePercent, globalConfigurationResponse.sharedLocalDBBackendDatabaseCachePercent) &&
        Objects.equals(this.unrecoverableDatabaseErrorMode, globalConfigurationResponse.unrecoverableDatabaseErrorMode) &&
        Objects.equals(this.databaseOnVirtualizedOrNetworkStorage, globalConfigurationResponse.databaseOnVirtualizedOrNetworkStorage) &&
        Objects.equals(this.autoNameWithEntryUUIDConnectionCriteria, globalConfigurationResponse.autoNameWithEntryUUIDConnectionCriteria) &&
        Objects.equals(this.autoNameWithEntryUUIDRequestCriteria, globalConfigurationResponse.autoNameWithEntryUUIDRequestCriteria) &&
        Objects.equals(this.softDeletePolicy, globalConfigurationResponse.softDeletePolicy) &&
        Objects.equals(this.subtreeAccessibilityAlertTimeLimit, globalConfigurationResponse.subtreeAccessibilityAlertTimeLimit) &&
        Objects.equals(this.warnForBackendsWithMultipleBaseDns, globalConfigurationResponse.warnForBackendsWithMultipleBaseDns) &&
        Objects.equals(this.forcedGCPrimeDuration, globalConfigurationResponse.forcedGCPrimeDuration) &&
        Objects.equals(this.replicationSetName, globalConfigurationResponse.replicationSetName) &&
        Objects.equals(this.startupMinReplicationBacklogCount, globalConfigurationResponse.startupMinReplicationBacklogCount) &&
        Objects.equals(this.replicationBacklogCountAlertThreshold, globalConfigurationResponse.replicationBacklogCountAlertThreshold) &&
        Objects.equals(this.replicationBacklogDurationAlertThreshold, globalConfigurationResponse.replicationBacklogDurationAlertThreshold) &&
        Objects.equals(this.replicationAssuranceSourceTimeoutSuspendDuration, globalConfigurationResponse.replicationAssuranceSourceTimeoutSuspendDuration) &&
        Objects.equals(this.replicationAssuranceSourceBacklogFastStartThreshold, globalConfigurationResponse.replicationAssuranceSourceBacklogFastStartThreshold) &&
        Objects.equals(this.replicationHistoryLimit, globalConfigurationResponse.replicationHistoryLimit) &&
        Objects.equals(this.allowInheritedReplicationOfSubordinateBackends, globalConfigurationResponse.allowInheritedReplicationOfSubordinateBackends) &&
        Objects.equals(this.replicationPurgeObsoleteReplicas, globalConfigurationResponse.replicationPurgeObsoleteReplicas) &&
        Objects.equals(this.smtpServer, globalConfigurationResponse.smtpServer) &&
        Objects.equals(this.maxSMTPConnectionCount, globalConfigurationResponse.maxSMTPConnectionCount) &&
        Objects.equals(this.maxSMTPConnectionAge, globalConfigurationResponse.maxSMTPConnectionAge) &&
        Objects.equals(this.smtpConnectionHealthCheckInterval, globalConfigurationResponse.smtpConnectionHealthCheckInterval) &&
        Objects.equals(this.allowedTask, globalConfigurationResponse.allowedTask) &&
        Objects.equals(this.enableSubOperationTimer, globalConfigurationResponse.enableSubOperationTimer) &&
        Objects.equals(this.maximumShutdownTime, globalConfigurationResponse.maximumShutdownTime) &&
        Objects.equals(this.networkAddressCacheTTL, globalConfigurationResponse.networkAddressCacheTTL) &&
        Objects.equals(this.networkAddressOutageCacheEnabled, globalConfigurationResponse.networkAddressOutageCacheEnabled) &&
        Objects.equals(this.trackedApplication, globalConfigurationResponse.trackedApplication) &&
        Objects.equals(this.jmxValueBehavior, globalConfigurationResponse.jmxValueBehavior) &&
        Objects.equals(this.jmxUseLegacyMbeanNames, globalConfigurationResponse.jmxUseLegacyMbeanNames) &&
        Objects.equals(this.meta, globalConfigurationResponse.meta) &&
        Objects.equals(this.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20, globalConfigurationResponse.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20)&&
        Objects.equals(this.additionalProperties, globalConfigurationResponse.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(schemas, instanceName, location, configurationServerGroup, forceAsMasterForMirroredData, encryptData, encryptionSettingsCipherStreamProvider, encryptBackupsByDefault, backupEncryptionSettingsDefinitionID, encryptLDIFExportsByDefault, ldifExportEncryptionSettingsDefinitionID, automaticallyCompressEncryptedLDIFExports, redactSensitiveValuesInConfigLogs, sensitiveAttribute, rejectInsecureRequests, allowedInsecureRequestCriteria, rejectUnauthenticatedRequests, allowedUnauthenticatedRequestCriteria, bindWithDNRequiresPassword, disabledPrivilege, defaultPasswordPolicy, maximumUserDataPasswordPoliciesToCache, proxiedAuthorizationIdentityMapper, verifyEntryDigests, allowedInsecureTLSProtocol, allowInsecureLocalJMXConnections, defaultInternalOperationClientConnectionPolicy, sizeLimit, unauthenticatedSizeLimit, timeLimit, unauthenticatedTimeLimit, idleTimeLimit, unauthenticatedIdleTimeLimit, lookthroughLimit, unauthenticatedLookthroughLimit, ldapJoinSizeLimit, maximumConcurrentConnections, maximumConcurrentConnectionsPerIPAddress, maximumConcurrentConnectionsPerBindDN, maximumConcurrentUnindexedSearches, maximumAttributesPerAddRequest, maximumModificationsPerModifyRequest, backgroundThreadForEachPersistentSearch, allowAttributeNameExceptions, invalidAttributeSyntaxBehavior, permitSyntaxViolationsForAttribute, singleStructuralObjectclassBehavior, attributesModifiableWithIgnoreNoUserModificationRequestControl, maximumServerOutLogFileSize, maximumServerOutLogFileCount, startupErrorLoggerOutputLocation, exitOnJVMError, serverErrorResultCode, resultCodeMap, returnBindErrorMessages, notifyAbandonedOperations, duplicateErrorLogLimit, duplicateErrorLogTimeLimit, duplicateAlertLimit, duplicateAlertTimeLimit, writabilityMode, useSharedDatabaseCacheAcrossAllLocalDBBackends, sharedLocalDBBackendDatabaseCachePercent, unrecoverableDatabaseErrorMode, databaseOnVirtualizedOrNetworkStorage, autoNameWithEntryUUIDConnectionCriteria, autoNameWithEntryUUIDRequestCriteria, softDeletePolicy, subtreeAccessibilityAlertTimeLimit, warnForBackendsWithMultipleBaseDns, forcedGCPrimeDuration, replicationSetName, startupMinReplicationBacklogCount, replicationBacklogCountAlertThreshold, replicationBacklogDurationAlertThreshold, replicationAssuranceSourceTimeoutSuspendDuration, replicationAssuranceSourceBacklogFastStartThreshold, replicationHistoryLimit, allowInheritedReplicationOfSubordinateBackends, replicationPurgeObsoleteReplicas, smtpServer, maxSMTPConnectionCount, maxSMTPConnectionAge, smtpConnectionHealthCheckInterval, allowedTask, enableSubOperationTimer, maximumShutdownTime, networkAddressCacheTTL, networkAddressOutageCacheEnabled, trackedApplication, jmxValueBehavior, jmxUseLegacyMbeanNames, meta, urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GlobalConfigurationResponse {\n");
    sb.append("    schemas: ").append(toIndentedString(schemas)).append("\n");
    sb.append("    instanceName: ").append(toIndentedString(instanceName)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    configurationServerGroup: ").append(toIndentedString(configurationServerGroup)).append("\n");
    sb.append("    forceAsMasterForMirroredData: ").append(toIndentedString(forceAsMasterForMirroredData)).append("\n");
    sb.append("    encryptData: ").append(toIndentedString(encryptData)).append("\n");
    sb.append("    encryptionSettingsCipherStreamProvider: ").append(toIndentedString(encryptionSettingsCipherStreamProvider)).append("\n");
    sb.append("    encryptBackupsByDefault: ").append(toIndentedString(encryptBackupsByDefault)).append("\n");
    sb.append("    backupEncryptionSettingsDefinitionID: ").append(toIndentedString(backupEncryptionSettingsDefinitionID)).append("\n");
    sb.append("    encryptLDIFExportsByDefault: ").append(toIndentedString(encryptLDIFExportsByDefault)).append("\n");
    sb.append("    ldifExportEncryptionSettingsDefinitionID: ").append(toIndentedString(ldifExportEncryptionSettingsDefinitionID)).append("\n");
    sb.append("    automaticallyCompressEncryptedLDIFExports: ").append(toIndentedString(automaticallyCompressEncryptedLDIFExports)).append("\n");
    sb.append("    redactSensitiveValuesInConfigLogs: ").append(toIndentedString(redactSensitiveValuesInConfigLogs)).append("\n");
    sb.append("    sensitiveAttribute: ").append(toIndentedString(sensitiveAttribute)).append("\n");
    sb.append("    rejectInsecureRequests: ").append(toIndentedString(rejectInsecureRequests)).append("\n");
    sb.append("    allowedInsecureRequestCriteria: ").append(toIndentedString(allowedInsecureRequestCriteria)).append("\n");
    sb.append("    rejectUnauthenticatedRequests: ").append(toIndentedString(rejectUnauthenticatedRequests)).append("\n");
    sb.append("    allowedUnauthenticatedRequestCriteria: ").append(toIndentedString(allowedUnauthenticatedRequestCriteria)).append("\n");
    sb.append("    bindWithDNRequiresPassword: ").append(toIndentedString(bindWithDNRequiresPassword)).append("\n");
    sb.append("    disabledPrivilege: ").append(toIndentedString(disabledPrivilege)).append("\n");
    sb.append("    defaultPasswordPolicy: ").append(toIndentedString(defaultPasswordPolicy)).append("\n");
    sb.append("    maximumUserDataPasswordPoliciesToCache: ").append(toIndentedString(maximumUserDataPasswordPoliciesToCache)).append("\n");
    sb.append("    proxiedAuthorizationIdentityMapper: ").append(toIndentedString(proxiedAuthorizationIdentityMapper)).append("\n");
    sb.append("    verifyEntryDigests: ").append(toIndentedString(verifyEntryDigests)).append("\n");
    sb.append("    allowedInsecureTLSProtocol: ").append(toIndentedString(allowedInsecureTLSProtocol)).append("\n");
    sb.append("    allowInsecureLocalJMXConnections: ").append(toIndentedString(allowInsecureLocalJMXConnections)).append("\n");
    sb.append("    defaultInternalOperationClientConnectionPolicy: ").append(toIndentedString(defaultInternalOperationClientConnectionPolicy)).append("\n");
    sb.append("    sizeLimit: ").append(toIndentedString(sizeLimit)).append("\n");
    sb.append("    unauthenticatedSizeLimit: ").append(toIndentedString(unauthenticatedSizeLimit)).append("\n");
    sb.append("    timeLimit: ").append(toIndentedString(timeLimit)).append("\n");
    sb.append("    unauthenticatedTimeLimit: ").append(toIndentedString(unauthenticatedTimeLimit)).append("\n");
    sb.append("    idleTimeLimit: ").append(toIndentedString(idleTimeLimit)).append("\n");
    sb.append("    unauthenticatedIdleTimeLimit: ").append(toIndentedString(unauthenticatedIdleTimeLimit)).append("\n");
    sb.append("    lookthroughLimit: ").append(toIndentedString(lookthroughLimit)).append("\n");
    sb.append("    unauthenticatedLookthroughLimit: ").append(toIndentedString(unauthenticatedLookthroughLimit)).append("\n");
    sb.append("    ldapJoinSizeLimit: ").append(toIndentedString(ldapJoinSizeLimit)).append("\n");
    sb.append("    maximumConcurrentConnections: ").append(toIndentedString(maximumConcurrentConnections)).append("\n");
    sb.append("    maximumConcurrentConnectionsPerIPAddress: ").append(toIndentedString(maximumConcurrentConnectionsPerIPAddress)).append("\n");
    sb.append("    maximumConcurrentConnectionsPerBindDN: ").append(toIndentedString(maximumConcurrentConnectionsPerBindDN)).append("\n");
    sb.append("    maximumConcurrentUnindexedSearches: ").append(toIndentedString(maximumConcurrentUnindexedSearches)).append("\n");
    sb.append("    maximumAttributesPerAddRequest: ").append(toIndentedString(maximumAttributesPerAddRequest)).append("\n");
    sb.append("    maximumModificationsPerModifyRequest: ").append(toIndentedString(maximumModificationsPerModifyRequest)).append("\n");
    sb.append("    backgroundThreadForEachPersistentSearch: ").append(toIndentedString(backgroundThreadForEachPersistentSearch)).append("\n");
    sb.append("    allowAttributeNameExceptions: ").append(toIndentedString(allowAttributeNameExceptions)).append("\n");
    sb.append("    invalidAttributeSyntaxBehavior: ").append(toIndentedString(invalidAttributeSyntaxBehavior)).append("\n");
    sb.append("    permitSyntaxViolationsForAttribute: ").append(toIndentedString(permitSyntaxViolationsForAttribute)).append("\n");
    sb.append("    singleStructuralObjectclassBehavior: ").append(toIndentedString(singleStructuralObjectclassBehavior)).append("\n");
    sb.append("    attributesModifiableWithIgnoreNoUserModificationRequestControl: ").append(toIndentedString(attributesModifiableWithIgnoreNoUserModificationRequestControl)).append("\n");
    sb.append("    maximumServerOutLogFileSize: ").append(toIndentedString(maximumServerOutLogFileSize)).append("\n");
    sb.append("    maximumServerOutLogFileCount: ").append(toIndentedString(maximumServerOutLogFileCount)).append("\n");
    sb.append("    startupErrorLoggerOutputLocation: ").append(toIndentedString(startupErrorLoggerOutputLocation)).append("\n");
    sb.append("    exitOnJVMError: ").append(toIndentedString(exitOnJVMError)).append("\n");
    sb.append("    serverErrorResultCode: ").append(toIndentedString(serverErrorResultCode)).append("\n");
    sb.append("    resultCodeMap: ").append(toIndentedString(resultCodeMap)).append("\n");
    sb.append("    returnBindErrorMessages: ").append(toIndentedString(returnBindErrorMessages)).append("\n");
    sb.append("    notifyAbandonedOperations: ").append(toIndentedString(notifyAbandonedOperations)).append("\n");
    sb.append("    duplicateErrorLogLimit: ").append(toIndentedString(duplicateErrorLogLimit)).append("\n");
    sb.append("    duplicateErrorLogTimeLimit: ").append(toIndentedString(duplicateErrorLogTimeLimit)).append("\n");
    sb.append("    duplicateAlertLimit: ").append(toIndentedString(duplicateAlertLimit)).append("\n");
    sb.append("    duplicateAlertTimeLimit: ").append(toIndentedString(duplicateAlertTimeLimit)).append("\n");
    sb.append("    writabilityMode: ").append(toIndentedString(writabilityMode)).append("\n");
    sb.append("    useSharedDatabaseCacheAcrossAllLocalDBBackends: ").append(toIndentedString(useSharedDatabaseCacheAcrossAllLocalDBBackends)).append("\n");
    sb.append("    sharedLocalDBBackendDatabaseCachePercent: ").append(toIndentedString(sharedLocalDBBackendDatabaseCachePercent)).append("\n");
    sb.append("    unrecoverableDatabaseErrorMode: ").append(toIndentedString(unrecoverableDatabaseErrorMode)).append("\n");
    sb.append("    databaseOnVirtualizedOrNetworkStorage: ").append(toIndentedString(databaseOnVirtualizedOrNetworkStorage)).append("\n");
    sb.append("    autoNameWithEntryUUIDConnectionCriteria: ").append(toIndentedString(autoNameWithEntryUUIDConnectionCriteria)).append("\n");
    sb.append("    autoNameWithEntryUUIDRequestCriteria: ").append(toIndentedString(autoNameWithEntryUUIDRequestCriteria)).append("\n");
    sb.append("    softDeletePolicy: ").append(toIndentedString(softDeletePolicy)).append("\n");
    sb.append("    subtreeAccessibilityAlertTimeLimit: ").append(toIndentedString(subtreeAccessibilityAlertTimeLimit)).append("\n");
    sb.append("    warnForBackendsWithMultipleBaseDns: ").append(toIndentedString(warnForBackendsWithMultipleBaseDns)).append("\n");
    sb.append("    forcedGCPrimeDuration: ").append(toIndentedString(forcedGCPrimeDuration)).append("\n");
    sb.append("    replicationSetName: ").append(toIndentedString(replicationSetName)).append("\n");
    sb.append("    startupMinReplicationBacklogCount: ").append(toIndentedString(startupMinReplicationBacklogCount)).append("\n");
    sb.append("    replicationBacklogCountAlertThreshold: ").append(toIndentedString(replicationBacklogCountAlertThreshold)).append("\n");
    sb.append("    replicationBacklogDurationAlertThreshold: ").append(toIndentedString(replicationBacklogDurationAlertThreshold)).append("\n");
    sb.append("    replicationAssuranceSourceTimeoutSuspendDuration: ").append(toIndentedString(replicationAssuranceSourceTimeoutSuspendDuration)).append("\n");
    sb.append("    replicationAssuranceSourceBacklogFastStartThreshold: ").append(toIndentedString(replicationAssuranceSourceBacklogFastStartThreshold)).append("\n");
    sb.append("    replicationHistoryLimit: ").append(toIndentedString(replicationHistoryLimit)).append("\n");
    sb.append("    allowInheritedReplicationOfSubordinateBackends: ").append(toIndentedString(allowInheritedReplicationOfSubordinateBackends)).append("\n");
    sb.append("    replicationPurgeObsoleteReplicas: ").append(toIndentedString(replicationPurgeObsoleteReplicas)).append("\n");
    sb.append("    smtpServer: ").append(toIndentedString(smtpServer)).append("\n");
    sb.append("    maxSMTPConnectionCount: ").append(toIndentedString(maxSMTPConnectionCount)).append("\n");
    sb.append("    maxSMTPConnectionAge: ").append(toIndentedString(maxSMTPConnectionAge)).append("\n");
    sb.append("    smtpConnectionHealthCheckInterval: ").append(toIndentedString(smtpConnectionHealthCheckInterval)).append("\n");
    sb.append("    allowedTask: ").append(toIndentedString(allowedTask)).append("\n");
    sb.append("    enableSubOperationTimer: ").append(toIndentedString(enableSubOperationTimer)).append("\n");
    sb.append("    maximumShutdownTime: ").append(toIndentedString(maximumShutdownTime)).append("\n");
    sb.append("    networkAddressCacheTTL: ").append(toIndentedString(networkAddressCacheTTL)).append("\n");
    sb.append("    networkAddressOutageCacheEnabled: ").append(toIndentedString(networkAddressOutageCacheEnabled)).append("\n");
    sb.append("    trackedApplication: ").append(toIndentedString(trackedApplication)).append("\n");
    sb.append("    jmxValueBehavior: ").append(toIndentedString(jmxValueBehavior)).append("\n");
    sb.append("    jmxUseLegacyMbeanNames: ").append(toIndentedString(jmxUseLegacyMbeanNames)).append("\n");
    sb.append("    meta: ").append(toIndentedString(meta)).append("\n");
    sb.append("    urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20: ").append(toIndentedString(urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("schemas");
    openapiFields.add("instanceName");
    openapiFields.add("location");
    openapiFields.add("configurationServerGroup");
    openapiFields.add("forceAsMasterForMirroredData");
    openapiFields.add("encryptData");
    openapiFields.add("encryptionSettingsCipherStreamProvider");
    openapiFields.add("encryptBackupsByDefault");
    openapiFields.add("backupEncryptionSettingsDefinitionID");
    openapiFields.add("encryptLDIFExportsByDefault");
    openapiFields.add("ldifExportEncryptionSettingsDefinitionID");
    openapiFields.add("automaticallyCompressEncryptedLDIFExports");
    openapiFields.add("redactSensitiveValuesInConfigLogs");
    openapiFields.add("sensitiveAttribute");
    openapiFields.add("rejectInsecureRequests");
    openapiFields.add("allowedInsecureRequestCriteria");
    openapiFields.add("rejectUnauthenticatedRequests");
    openapiFields.add("allowedUnauthenticatedRequestCriteria");
    openapiFields.add("bindWithDNRequiresPassword");
    openapiFields.add("disabledPrivilege");
    openapiFields.add("defaultPasswordPolicy");
    openapiFields.add("maximumUserDataPasswordPoliciesToCache");
    openapiFields.add("proxiedAuthorizationIdentityMapper");
    openapiFields.add("verifyEntryDigests");
    openapiFields.add("allowedInsecureTLSProtocol");
    openapiFields.add("allowInsecureLocalJMXConnections");
    openapiFields.add("defaultInternalOperationClientConnectionPolicy");
    openapiFields.add("sizeLimit");
    openapiFields.add("unauthenticatedSizeLimit");
    openapiFields.add("timeLimit");
    openapiFields.add("unauthenticatedTimeLimit");
    openapiFields.add("idleTimeLimit");
    openapiFields.add("unauthenticatedIdleTimeLimit");
    openapiFields.add("lookthroughLimit");
    openapiFields.add("unauthenticatedLookthroughLimit");
    openapiFields.add("ldapJoinSizeLimit");
    openapiFields.add("maximumConcurrentConnections");
    openapiFields.add("maximumConcurrentConnectionsPerIPAddress");
    openapiFields.add("maximumConcurrentConnectionsPerBindDN");
    openapiFields.add("maximumConcurrentUnindexedSearches");
    openapiFields.add("maximumAttributesPerAddRequest");
    openapiFields.add("maximumModificationsPerModifyRequest");
    openapiFields.add("backgroundThreadForEachPersistentSearch");
    openapiFields.add("allowAttributeNameExceptions");
    openapiFields.add("invalidAttributeSyntaxBehavior");
    openapiFields.add("permitSyntaxViolationsForAttribute");
    openapiFields.add("singleStructuralObjectclassBehavior");
    openapiFields.add("attributesModifiableWithIgnoreNoUserModificationRequestControl");
    openapiFields.add("maximumServerOutLogFileSize");
    openapiFields.add("maximumServerOutLogFileCount");
    openapiFields.add("startupErrorLoggerOutputLocation");
    openapiFields.add("exitOnJVMError");
    openapiFields.add("serverErrorResultCode");
    openapiFields.add("resultCodeMap");
    openapiFields.add("returnBindErrorMessages");
    openapiFields.add("notifyAbandonedOperations");
    openapiFields.add("duplicateErrorLogLimit");
    openapiFields.add("duplicateErrorLogTimeLimit");
    openapiFields.add("duplicateAlertLimit");
    openapiFields.add("duplicateAlertTimeLimit");
    openapiFields.add("writabilityMode");
    openapiFields.add("useSharedDatabaseCacheAcrossAllLocalDBBackends");
    openapiFields.add("sharedLocalDBBackendDatabaseCachePercent");
    openapiFields.add("unrecoverableDatabaseErrorMode");
    openapiFields.add("databaseOnVirtualizedOrNetworkStorage");
    openapiFields.add("autoNameWithEntryUUIDConnectionCriteria");
    openapiFields.add("autoNameWithEntryUUIDRequestCriteria");
    openapiFields.add("softDeletePolicy");
    openapiFields.add("subtreeAccessibilityAlertTimeLimit");
    openapiFields.add("warnForBackendsWithMultipleBaseDns");
    openapiFields.add("forcedGCPrimeDuration");
    openapiFields.add("replicationSetName");
    openapiFields.add("startupMinReplicationBacklogCount");
    openapiFields.add("replicationBacklogCountAlertThreshold");
    openapiFields.add("replicationBacklogDurationAlertThreshold");
    openapiFields.add("replicationAssuranceSourceTimeoutSuspendDuration");
    openapiFields.add("replicationAssuranceSourceBacklogFastStartThreshold");
    openapiFields.add("replicationHistoryLimit");
    openapiFields.add("allowInheritedReplicationOfSubordinateBackends");
    openapiFields.add("replicationPurgeObsoleteReplicas");
    openapiFields.add("smtpServer");
    openapiFields.add("maxSMTPConnectionCount");
    openapiFields.add("maxSMTPConnectionAge");
    openapiFields.add("smtpConnectionHealthCheckInterval");
    openapiFields.add("allowedTask");
    openapiFields.add("enableSubOperationTimer");
    openapiFields.add("maximumShutdownTime");
    openapiFields.add("networkAddressCacheTTL");
    openapiFields.add("networkAddressOutageCacheEnabled");
    openapiFields.add("trackedApplication");
    openapiFields.add("jmxValueBehavior");
    openapiFields.add("jmxUseLegacyMbeanNames");
    openapiFields.add("meta");
    openapiFields.add("urn:pingidentity:schemas:configuration:messages:2.0");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("instanceName");
    openapiRequiredFields.add("defaultPasswordPolicy");
    openapiRequiredFields.add("proxiedAuthorizationIdentityMapper");
    openapiRequiredFields.add("duplicateErrorLogLimit");
    openapiRequiredFields.add("duplicateErrorLogTimeLimit");
    openapiRequiredFields.add("duplicateAlertLimit");
    openapiRequiredFields.add("duplicateAlertTimeLimit");
    openapiRequiredFields.add("startupMinReplicationBacklogCount");
    openapiRequiredFields.add("replicationBacklogCountAlertThreshold");
    openapiRequiredFields.add("replicationBacklogDurationAlertThreshold");
    openapiRequiredFields.add("replicationAssuranceSourceTimeoutSuspendDuration");
    openapiRequiredFields.add("replicationAssuranceSourceBacklogFastStartThreshold");
    openapiRequiredFields.add("allowInheritedReplicationOfSubordinateBackends");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to GlobalConfigurationResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!GlobalConfigurationResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GlobalConfigurationResponse is not found in the empty JSON string", GlobalConfigurationResponse.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : GlobalConfigurationResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("schemas") != null && !jsonObj.get("schemas").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `schemas` to be an array in the JSON string but got `%s`", jsonObj.get("schemas").toString()));
      }
      if (!jsonObj.get("instanceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instanceName").toString()));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if ((jsonObj.get("configurationServerGroup") != null && !jsonObj.get("configurationServerGroup").isJsonNull()) && !jsonObj.get("configurationServerGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `configurationServerGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("configurationServerGroup").toString()));
      }
      if ((jsonObj.get("encryptionSettingsCipherStreamProvider") != null && !jsonObj.get("encryptionSettingsCipherStreamProvider").isJsonNull()) && !jsonObj.get("encryptionSettingsCipherStreamProvider").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `encryptionSettingsCipherStreamProvider` to be a primitive type in the JSON string but got `%s`", jsonObj.get("encryptionSettingsCipherStreamProvider").toString()));
      }
      if ((jsonObj.get("backupEncryptionSettingsDefinitionID") != null && !jsonObj.get("backupEncryptionSettingsDefinitionID").isJsonNull()) && !jsonObj.get("backupEncryptionSettingsDefinitionID").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backupEncryptionSettingsDefinitionID` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backupEncryptionSettingsDefinitionID").toString()));
      }
      if ((jsonObj.get("ldifExportEncryptionSettingsDefinitionID") != null && !jsonObj.get("ldifExportEncryptionSettingsDefinitionID").isJsonNull()) && !jsonObj.get("ldifExportEncryptionSettingsDefinitionID").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ldifExportEncryptionSettingsDefinitionID` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ldifExportEncryptionSettingsDefinitionID").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sensitiveAttribute") != null && !jsonObj.get("sensitiveAttribute").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sensitiveAttribute` to be an array in the JSON string but got `%s`", jsonObj.get("sensitiveAttribute").toString()));
      }
      if ((jsonObj.get("allowedInsecureRequestCriteria") != null && !jsonObj.get("allowedInsecureRequestCriteria").isJsonNull()) && !jsonObj.get("allowedInsecureRequestCriteria").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedInsecureRequestCriteria` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allowedInsecureRequestCriteria").toString()));
      }
      if ((jsonObj.get("allowedUnauthenticatedRequestCriteria") != null && !jsonObj.get("allowedUnauthenticatedRequestCriteria").isJsonNull()) && !jsonObj.get("allowedUnauthenticatedRequestCriteria").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedUnauthenticatedRequestCriteria` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allowedUnauthenticatedRequestCriteria").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("disabledPrivilege") != null && !jsonObj.get("disabledPrivilege").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `disabledPrivilege` to be an array in the JSON string but got `%s`", jsonObj.get("disabledPrivilege").toString()));
      }
      if (!jsonObj.get("defaultPasswordPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultPasswordPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultPasswordPolicy").toString()));
      }
      if (!jsonObj.get("proxiedAuthorizationIdentityMapper").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `proxiedAuthorizationIdentityMapper` to be a primitive type in the JSON string but got `%s`", jsonObj.get("proxiedAuthorizationIdentityMapper").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedInsecureTLSProtocol") != null && !jsonObj.get("allowedInsecureTLSProtocol").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedInsecureTLSProtocol` to be an array in the JSON string but got `%s`", jsonObj.get("allowedInsecureTLSProtocol").toString()));
      }
      if ((jsonObj.get("defaultInternalOperationClientConnectionPolicy") != null && !jsonObj.get("defaultInternalOperationClientConnectionPolicy").isJsonNull()) && !jsonObj.get("defaultInternalOperationClientConnectionPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultInternalOperationClientConnectionPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultInternalOperationClientConnectionPolicy").toString()));
      }
      if ((jsonObj.get("timeLimit") != null && !jsonObj.get("timeLimit").isJsonNull()) && !jsonObj.get("timeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeLimit").toString()));
      }
      if ((jsonObj.get("unauthenticatedTimeLimit") != null && !jsonObj.get("unauthenticatedTimeLimit").isJsonNull()) && !jsonObj.get("unauthenticatedTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unauthenticatedTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unauthenticatedTimeLimit").toString()));
      }
      if ((jsonObj.get("idleTimeLimit") != null && !jsonObj.get("idleTimeLimit").isJsonNull()) && !jsonObj.get("idleTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `idleTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("idleTimeLimit").toString()));
      }
      if ((jsonObj.get("unauthenticatedIdleTimeLimit") != null && !jsonObj.get("unauthenticatedIdleTimeLimit").isJsonNull()) && !jsonObj.get("unauthenticatedIdleTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unauthenticatedIdleTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unauthenticatedIdleTimeLimit").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permitSyntaxViolationsForAttribute") != null && !jsonObj.get("permitSyntaxViolationsForAttribute").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permitSyntaxViolationsForAttribute` to be an array in the JSON string but got `%s`", jsonObj.get("permitSyntaxViolationsForAttribute").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("attributesModifiableWithIgnoreNoUserModificationRequestControl") != null && !jsonObj.get("attributesModifiableWithIgnoreNoUserModificationRequestControl").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `attributesModifiableWithIgnoreNoUserModificationRequestControl` to be an array in the JSON string but got `%s`", jsonObj.get("attributesModifiableWithIgnoreNoUserModificationRequestControl").toString()));
      }
      if ((jsonObj.get("maximumServerOutLogFileSize") != null && !jsonObj.get("maximumServerOutLogFileSize").isJsonNull()) && !jsonObj.get("maximumServerOutLogFileSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maximumServerOutLogFileSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maximumServerOutLogFileSize").toString()));
      }
      if ((jsonObj.get("resultCodeMap") != null && !jsonObj.get("resultCodeMap").isJsonNull()) && !jsonObj.get("resultCodeMap").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resultCodeMap` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resultCodeMap").toString()));
      }
      if (!jsonObj.get("duplicateErrorLogTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `duplicateErrorLogTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("duplicateErrorLogTimeLimit").toString()));
      }
      if (!jsonObj.get("duplicateAlertTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `duplicateAlertTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("duplicateAlertTimeLimit").toString()));
      }
      if ((jsonObj.get("autoNameWithEntryUUIDConnectionCriteria") != null && !jsonObj.get("autoNameWithEntryUUIDConnectionCriteria").isJsonNull()) && !jsonObj.get("autoNameWithEntryUUIDConnectionCriteria").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoNameWithEntryUUIDConnectionCriteria` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoNameWithEntryUUIDConnectionCriteria").toString()));
      }
      if ((jsonObj.get("autoNameWithEntryUUIDRequestCriteria") != null && !jsonObj.get("autoNameWithEntryUUIDRequestCriteria").isJsonNull()) && !jsonObj.get("autoNameWithEntryUUIDRequestCriteria").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoNameWithEntryUUIDRequestCriteria` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoNameWithEntryUUIDRequestCriteria").toString()));
      }
      if ((jsonObj.get("softDeletePolicy") != null && !jsonObj.get("softDeletePolicy").isJsonNull()) && !jsonObj.get("softDeletePolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `softDeletePolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("softDeletePolicy").toString()));
      }
      if ((jsonObj.get("subtreeAccessibilityAlertTimeLimit") != null && !jsonObj.get("subtreeAccessibilityAlertTimeLimit").isJsonNull()) && !jsonObj.get("subtreeAccessibilityAlertTimeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subtreeAccessibilityAlertTimeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subtreeAccessibilityAlertTimeLimit").toString()));
      }
      if ((jsonObj.get("forcedGCPrimeDuration") != null && !jsonObj.get("forcedGCPrimeDuration").isJsonNull()) && !jsonObj.get("forcedGCPrimeDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `forcedGCPrimeDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("forcedGCPrimeDuration").toString()));
      }
      if ((jsonObj.get("replicationSetName") != null && !jsonObj.get("replicationSetName").isJsonNull()) && !jsonObj.get("replicationSetName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replicationSetName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replicationSetName").toString()));
      }
      if (!jsonObj.get("replicationBacklogDurationAlertThreshold").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replicationBacklogDurationAlertThreshold` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replicationBacklogDurationAlertThreshold").toString()));
      }
      if (!jsonObj.get("replicationAssuranceSourceTimeoutSuspendDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replicationAssuranceSourceTimeoutSuspendDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replicationAssuranceSourceTimeoutSuspendDuration").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("smtpServer") != null && !jsonObj.get("smtpServer").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `smtpServer` to be an array in the JSON string but got `%s`", jsonObj.get("smtpServer").toString()));
      }
      if ((jsonObj.get("maxSMTPConnectionAge") != null && !jsonObj.get("maxSMTPConnectionAge").isJsonNull()) && !jsonObj.get("maxSMTPConnectionAge").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxSMTPConnectionAge` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxSMTPConnectionAge").toString()));
      }
      if ((jsonObj.get("smtpConnectionHealthCheckInterval") != null && !jsonObj.get("smtpConnectionHealthCheckInterval").isJsonNull()) && !jsonObj.get("smtpConnectionHealthCheckInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `smtpConnectionHealthCheckInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("smtpConnectionHealthCheckInterval").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedTask") != null && !jsonObj.get("allowedTask").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedTask` to be an array in the JSON string but got `%s`", jsonObj.get("allowedTask").toString()));
      }
      if ((jsonObj.get("maximumShutdownTime") != null && !jsonObj.get("maximumShutdownTime").isJsonNull()) && !jsonObj.get("maximumShutdownTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maximumShutdownTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maximumShutdownTime").toString()));
      }
      if ((jsonObj.get("networkAddressCacheTTL") != null && !jsonObj.get("networkAddressCacheTTL").isJsonNull()) && !jsonObj.get("networkAddressCacheTTL").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkAddressCacheTTL` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkAddressCacheTTL").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("trackedApplication") != null && !jsonObj.get("trackedApplication").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `trackedApplication` to be an array in the JSON string but got `%s`", jsonObj.get("trackedApplication").toString()));
      }
      // validate the optional field `meta`
      if (jsonObj.get("meta") != null && !jsonObj.get("meta").isJsonNull()) {
        MetaMeta.validateJsonObject(jsonObj.getAsJsonObject("meta"));
      }
      // validate the optional field `urn:pingidentity:schemas:configuration:messages:2.0`
      if (jsonObj.get("urn:pingidentity:schemas:configuration:messages:2.0") != null && !jsonObj.get("urn:pingidentity:schemas:configuration:messages:2.0").isJsonNull()) {
        MetaUrnPingidentitySchemasConfigurationMessages20.validateJsonObject(jsonObj.getAsJsonObject("urn:pingidentity:schemas:configuration:messages:2.0"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GlobalConfigurationResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GlobalConfigurationResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GlobalConfigurationResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GlobalConfigurationResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<GlobalConfigurationResponse>() {
           @Override
           public void write(JsonWriter out, GlobalConfigurationResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public GlobalConfigurationResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             GlobalConfigurationResponse instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of GlobalConfigurationResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of GlobalConfigurationResponse
  * @throws IOException if the JSON string is invalid with respect to GlobalConfigurationResponse
  */
  public static GlobalConfigurationResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GlobalConfigurationResponse.class);
  }

 /**
  * Convert an instance of GlobalConfigurationResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

