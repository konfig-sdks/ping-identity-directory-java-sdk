/*
 * PingData Config - OpenAPI 3.0
 * This is the PingData Configuration API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.EnumfileServerHttpServletExtensionSchemaUrn;
import com.konfigthis.client.model.EnumhttpServletExtensionAllowedAuthenticationTypeProp;
import com.konfigthis.client.model.MetaMeta;
import com.konfigthis.client.model.MetaUrnPingidentitySchemasConfigurationMessages20;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * FileServerHttpServletExtensionResponse
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class FileServerHttpServletExtensionResponse {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_SCHEMAS = "schemas";
  @SerializedName(SERIALIZED_NAME_SCHEMAS)
  private List<EnumfileServerHttpServletExtensionSchemaUrn> schemas = new ArrayList<>();

  public static final String SERIALIZED_NAME_BASE_CONTEXT_PATH = "baseContextPath";
  @SerializedName(SERIALIZED_NAME_BASE_CONTEXT_PATH)
  private String baseContextPath;

  public static final String SERIALIZED_NAME_DOCUMENT_ROOT_DIRECTORY = "documentRootDirectory";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_ROOT_DIRECTORY)
  private String documentRootDirectory;

  public static final String SERIALIZED_NAME_ENABLE_DIRECTORY_INDEXING = "enableDirectoryIndexing";
  @SerializedName(SERIALIZED_NAME_ENABLE_DIRECTORY_INDEXING)
  private Boolean enableDirectoryIndexing;

  public static final String SERIALIZED_NAME_INDEX_FILE = "indexFile";
  @SerializedName(SERIALIZED_NAME_INDEX_FILE)
  private List<String> indexFile = null;

  public static final String SERIALIZED_NAME_MIME_TYPES_FILE = "mimeTypesFile";
  @SerializedName(SERIALIZED_NAME_MIME_TYPES_FILE)
  private String mimeTypesFile;

  public static final String SERIALIZED_NAME_DEFAULT_M_I_M_E_TYPE = "defaultMIMEType";
  @SerializedName(SERIALIZED_NAME_DEFAULT_M_I_M_E_TYPE)
  private String defaultMIMEType;

  public static final String SERIALIZED_NAME_REQUIRE_AUTHENTICATION = "requireAuthentication";
  @SerializedName(SERIALIZED_NAME_REQUIRE_AUTHENTICATION)
  private Boolean requireAuthentication;

  public static final String SERIALIZED_NAME_ALLOWED_AUTHENTICATION_TYPE = "allowedAuthenticationType";
  @SerializedName(SERIALIZED_NAME_ALLOWED_AUTHENTICATION_TYPE)
  private List<EnumhttpServletExtensionAllowedAuthenticationTypeProp> allowedAuthenticationType = null;

  public static final String SERIALIZED_NAME_ACCESS_TOKEN_VALIDATOR = "accessTokenValidator";
  @SerializedName(SERIALIZED_NAME_ACCESS_TOKEN_VALIDATOR)
  private List<String> accessTokenValidator = null;

  public static final String SERIALIZED_NAME_ID_TOKEN_VALIDATOR = "idTokenValidator";
  @SerializedName(SERIALIZED_NAME_ID_TOKEN_VALIDATOR)
  private List<String> idTokenValidator = null;

  public static final String SERIALIZED_NAME_REQUIRE_FILE_SERVLET_ACCESS_PRIVILEGE = "requireFileServletAccessPrivilege";
  @SerializedName(SERIALIZED_NAME_REQUIRE_FILE_SERVLET_ACCESS_PRIVILEGE)
  private Boolean requireFileServletAccessPrivilege;

  public static final String SERIALIZED_NAME_REQUIRE_GROUP = "requireGroup";
  @SerializedName(SERIALIZED_NAME_REQUIRE_GROUP)
  private List<String> requireGroup = null;

  public static final String SERIALIZED_NAME_IDENTITY_MAPPER = "identityMapper";
  @SerializedName(SERIALIZED_NAME_IDENTITY_MAPPER)
  private String identityMapper;

  public static final String SERIALIZED_NAME_CROSS_ORIGIN_POLICY = "crossOriginPolicy";
  @SerializedName(SERIALIZED_NAME_CROSS_ORIGIN_POLICY)
  private String crossOriginPolicy;

  public static final String SERIALIZED_NAME_RESPONSE_HEADER = "responseHeader";
  @SerializedName(SERIALIZED_NAME_RESPONSE_HEADER)
  private List<String> responseHeader = null;

  public static final String SERIALIZED_NAME_CORRELATION_I_D_RESPONSE_HEADER = "correlationIDResponseHeader";
  @SerializedName(SERIALIZED_NAME_CORRELATION_I_D_RESPONSE_HEADER)
  private String correlationIDResponseHeader;

  public static final String SERIALIZED_NAME_META = "meta";
  @SerializedName(SERIALIZED_NAME_META)
  private MetaMeta meta;

  public static final String SERIALIZED_NAME_URN_COLON_PINGIDENTITY_COLON_SCHEMAS_COLON_CONFIGURATION_COLON_MESSAGES_COLON20 = "urn:pingidentity:schemas:configuration:messages:2.0";
  @SerializedName(SERIALIZED_NAME_URN_COLON_PINGIDENTITY_COLON_SCHEMAS_COLON_CONFIGURATION_COLON_MESSAGES_COLON20)
  private MetaUrnPingidentitySchemasConfigurationMessages20 urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;

  public FileServerHttpServletExtensionResponse() {
  }

  public FileServerHttpServletExtensionResponse id(String id) {
    
    
    
    
    this.id = id;
    return this;
  }

   /**
   * Name of the HTTP Servlet Extension
   * @return id
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Name of the HTTP Servlet Extension")

  public String getId() {
    return id;
  }


  public void setId(String id) {
    
    
    
    this.id = id;
  }


  public FileServerHttpServletExtensionResponse description(String description) {
    
    
    
    
    this.description = description;
    return this;
  }

   /**
   * A description for this HTTP Servlet Extension
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A description for this HTTP Servlet Extension")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    
    
    
    this.description = description;
  }


  public FileServerHttpServletExtensionResponse schemas(List<EnumfileServerHttpServletExtensionSchemaUrn> schemas) {
    
    
    
    
    this.schemas = schemas;
    return this;
  }

  public FileServerHttpServletExtensionResponse addSchemasItem(EnumfileServerHttpServletExtensionSchemaUrn schemasItem) {
    this.schemas.add(schemasItem);
    return this;
  }

   /**
   * Get schemas
   * @return schemas
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public List<EnumfileServerHttpServletExtensionSchemaUrn> getSchemas() {
    return schemas;
  }


  public void setSchemas(List<EnumfileServerHttpServletExtensionSchemaUrn> schemas) {
    
    
    
    this.schemas = schemas;
  }


  public FileServerHttpServletExtensionResponse baseContextPath(String baseContextPath) {
    
    
    
    
    this.baseContextPath = baseContextPath;
    return this;
  }

   /**
   * Specifies the base context path that should be used by HTTP clients to reference content. The value must start with a forward slash and must represent a valid HTTP context path.
   * @return baseContextPath
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the base context path that should be used by HTTP clients to reference content. The value must start with a forward slash and must represent a valid HTTP context path.")

  public String getBaseContextPath() {
    return baseContextPath;
  }


  public void setBaseContextPath(String baseContextPath) {
    
    
    
    this.baseContextPath = baseContextPath;
  }


  public FileServerHttpServletExtensionResponse documentRootDirectory(String documentRootDirectory) {
    
    
    
    
    this.documentRootDirectory = documentRootDirectory;
    return this;
  }

   /**
   * Specifies the path to the directory on the local filesystem containing the files to be served by this File Server HTTP Servlet Extension. The path must exist, and it must be a directory.
   * @return documentRootDirectory
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the path to the directory on the local filesystem containing the files to be served by this File Server HTTP Servlet Extension. The path must exist, and it must be a directory.")

  public String getDocumentRootDirectory() {
    return documentRootDirectory;
  }


  public void setDocumentRootDirectory(String documentRootDirectory) {
    
    
    
    this.documentRootDirectory = documentRootDirectory;
  }


  public FileServerHttpServletExtensionResponse enableDirectoryIndexing(Boolean enableDirectoryIndexing) {
    
    
    
    
    this.enableDirectoryIndexing = enableDirectoryIndexing;
    return this;
  }

   /**
   * Indicates whether to generate a default HTML page with a listing of available files if the requested path refers to a directory rather than a file, and that directory does not contain an index file.
   * @return enableDirectoryIndexing
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether to generate a default HTML page with a listing of available files if the requested path refers to a directory rather than a file, and that directory does not contain an index file.")

  public Boolean getEnableDirectoryIndexing() {
    return enableDirectoryIndexing;
  }


  public void setEnableDirectoryIndexing(Boolean enableDirectoryIndexing) {
    
    
    
    this.enableDirectoryIndexing = enableDirectoryIndexing;
  }


  public FileServerHttpServletExtensionResponse indexFile(List<String> indexFile) {
    
    
    
    
    this.indexFile = indexFile;
    return this;
  }

  public FileServerHttpServletExtensionResponse addIndexFileItem(String indexFileItem) {
    if (this.indexFile == null) {
      this.indexFile = new ArrayList<>();
    }
    this.indexFile.add(indexFileItem);
    return this;
  }

   /**
   * Specifies the name of a file whose contents may be returned to the client if the requested path refers to a directory rather than a file.
   * @return indexFile
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the name of a file whose contents may be returned to the client if the requested path refers to a directory rather than a file.")

  public List<String> getIndexFile() {
    return indexFile;
  }


  public void setIndexFile(List<String> indexFile) {
    
    
    
    this.indexFile = indexFile;
  }


  public FileServerHttpServletExtensionResponse mimeTypesFile(String mimeTypesFile) {
    
    
    
    
    this.mimeTypesFile = mimeTypesFile;
    return this;
  }

   /**
   * Specifies the path to a file that contains MIME type mappings that will be used to determine the appropriate value to return for the Content-Type header based on the extension of the requested file.
   * @return mimeTypesFile
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the path to a file that contains MIME type mappings that will be used to determine the appropriate value to return for the Content-Type header based on the extension of the requested file.")

  public String getMimeTypesFile() {
    return mimeTypesFile;
  }


  public void setMimeTypesFile(String mimeTypesFile) {
    
    
    
    this.mimeTypesFile = mimeTypesFile;
  }


  public FileServerHttpServletExtensionResponse defaultMIMEType(String defaultMIMEType) {
    
    
    
    
    this.defaultMIMEType = defaultMIMEType;
    return this;
  }

   /**
   * Specifies the default MIME type to use for the Content-Type header when a mapping cannot be found.
   * @return defaultMIMEType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the default MIME type to use for the Content-Type header when a mapping cannot be found.")

  public String getDefaultMIMEType() {
    return defaultMIMEType;
  }


  public void setDefaultMIMEType(String defaultMIMEType) {
    
    
    
    this.defaultMIMEType = defaultMIMEType;
  }


  public FileServerHttpServletExtensionResponse requireAuthentication(Boolean requireAuthentication) {
    
    
    
    
    this.requireAuthentication = requireAuthentication;
    return this;
  }

   /**
   * Indicates whether the servlet extension should only accept requests from authenticated clients.
   * @return requireAuthentication
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the servlet extension should only accept requests from authenticated clients.")

  public Boolean getRequireAuthentication() {
    return requireAuthentication;
  }


  public void setRequireAuthentication(Boolean requireAuthentication) {
    
    
    
    this.requireAuthentication = requireAuthentication;
  }


  public FileServerHttpServletExtensionResponse allowedAuthenticationType(List<EnumhttpServletExtensionAllowedAuthenticationTypeProp> allowedAuthenticationType) {
    
    
    
    
    this.allowedAuthenticationType = allowedAuthenticationType;
    return this;
  }

  public FileServerHttpServletExtensionResponse addAllowedAuthenticationTypeItem(EnumhttpServletExtensionAllowedAuthenticationTypeProp allowedAuthenticationTypeItem) {
    if (this.allowedAuthenticationType == null) {
      this.allowedAuthenticationType = new ArrayList<>();
    }
    this.allowedAuthenticationType.add(allowedAuthenticationTypeItem);
    return this;
  }

   /**
   * Get allowedAuthenticationType
   * @return allowedAuthenticationType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<EnumhttpServletExtensionAllowedAuthenticationTypeProp> getAllowedAuthenticationType() {
    return allowedAuthenticationType;
  }


  public void setAllowedAuthenticationType(List<EnumhttpServletExtensionAllowedAuthenticationTypeProp> allowedAuthenticationType) {
    
    
    
    this.allowedAuthenticationType = allowedAuthenticationType;
  }


  public FileServerHttpServletExtensionResponse accessTokenValidator(List<String> accessTokenValidator) {
    
    
    
    
    this.accessTokenValidator = accessTokenValidator;
    return this;
  }

  public FileServerHttpServletExtensionResponse addAccessTokenValidatorItem(String accessTokenValidatorItem) {
    if (this.accessTokenValidator == null) {
      this.accessTokenValidator = new ArrayList<>();
    }
    this.accessTokenValidator.add(accessTokenValidatorItem);
    return this;
  }

   /**
   * The access token validators that may be used to verify the authenticity of an OAuth 2.0 bearer token.
   * @return accessTokenValidator
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The access token validators that may be used to verify the authenticity of an OAuth 2.0 bearer token.")

  public List<String> getAccessTokenValidator() {
    return accessTokenValidator;
  }


  public void setAccessTokenValidator(List<String> accessTokenValidator) {
    
    
    
    this.accessTokenValidator = accessTokenValidator;
  }


  public FileServerHttpServletExtensionResponse idTokenValidator(List<String> idTokenValidator) {
    
    
    
    
    this.idTokenValidator = idTokenValidator;
    return this;
  }

  public FileServerHttpServletExtensionResponse addIdTokenValidatorItem(String idTokenValidatorItem) {
    if (this.idTokenValidator == null) {
      this.idTokenValidator = new ArrayList<>();
    }
    this.idTokenValidator.add(idTokenValidatorItem);
    return this;
  }

   /**
   * The ID token validators that may be used to verify the authenticity of an of an OpenID Connect ID token.
   * @return idTokenValidator
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The ID token validators that may be used to verify the authenticity of an of an OpenID Connect ID token.")

  public List<String> getIdTokenValidator() {
    return idTokenValidator;
  }


  public void setIdTokenValidator(List<String> idTokenValidator) {
    
    
    
    this.idTokenValidator = idTokenValidator;
  }


  public FileServerHttpServletExtensionResponse requireFileServletAccessPrivilege(Boolean requireFileServletAccessPrivilege) {
    
    
    
    
    this.requireFileServletAccessPrivilege = requireFileServletAccessPrivilege;
    return this;
  }

   /**
   * Indicates whether the servlet extension should only accept requests from authenticated clients that have the file-servlet-access privilege.
   * @return requireFileServletAccessPrivilege
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the servlet extension should only accept requests from authenticated clients that have the file-servlet-access privilege.")

  public Boolean getRequireFileServletAccessPrivilege() {
    return requireFileServletAccessPrivilege;
  }


  public void setRequireFileServletAccessPrivilege(Boolean requireFileServletAccessPrivilege) {
    
    
    
    this.requireFileServletAccessPrivilege = requireFileServletAccessPrivilege;
  }


  public FileServerHttpServletExtensionResponse requireGroup(List<String> requireGroup) {
    
    
    
    
    this.requireGroup = requireGroup;
    return this;
  }

  public FileServerHttpServletExtensionResponse addRequireGroupItem(String requireGroupItem) {
    if (this.requireGroup == null) {
      this.requireGroup = new ArrayList<>();
    }
    this.requireGroup.add(requireGroupItem);
    return this;
  }

   /**
   * The DN of a group whose members will be permitted to access to the associated files. If multiple group DNs are configured, then anyone who is a member of at least one of those groups will be granted access.
   * @return requireGroup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The DN of a group whose members will be permitted to access to the associated files. If multiple group DNs are configured, then anyone who is a member of at least one of those groups will be granted access.")

  public List<String> getRequireGroup() {
    return requireGroup;
  }


  public void setRequireGroup(List<String> requireGroup) {
    
    
    
    this.requireGroup = requireGroup;
  }


  public FileServerHttpServletExtensionResponse identityMapper(String identityMapper) {
    
    
    
    
    this.identityMapper = identityMapper;
    return this;
  }

   /**
   * The identity mapper that will be used to identify the entry with which a username is associated.
   * @return identityMapper
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The identity mapper that will be used to identify the entry with which a username is associated.")

  public String getIdentityMapper() {
    return identityMapper;
  }


  public void setIdentityMapper(String identityMapper) {
    
    
    
    this.identityMapper = identityMapper;
  }


  public FileServerHttpServletExtensionResponse crossOriginPolicy(String crossOriginPolicy) {
    
    
    
    
    this.crossOriginPolicy = crossOriginPolicy;
    return this;
  }

   /**
   * The cross-origin request policy to use for the HTTP Servlet Extension.
   * @return crossOriginPolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The cross-origin request policy to use for the HTTP Servlet Extension.")

  public String getCrossOriginPolicy() {
    return crossOriginPolicy;
  }


  public void setCrossOriginPolicy(String crossOriginPolicy) {
    
    
    
    this.crossOriginPolicy = crossOriginPolicy;
  }


  public FileServerHttpServletExtensionResponse responseHeader(List<String> responseHeader) {
    
    
    
    
    this.responseHeader = responseHeader;
    return this;
  }

  public FileServerHttpServletExtensionResponse addResponseHeaderItem(String responseHeaderItem) {
    if (this.responseHeader == null) {
      this.responseHeader = new ArrayList<>();
    }
    this.responseHeader.add(responseHeaderItem);
    return this;
  }

   /**
   * Specifies HTTP header fields and values added to response headers for all requests.
   * @return responseHeader
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies HTTP header fields and values added to response headers for all requests.")

  public List<String> getResponseHeader() {
    return responseHeader;
  }


  public void setResponseHeader(List<String> responseHeader) {
    
    
    
    this.responseHeader = responseHeader;
  }


  public FileServerHttpServletExtensionResponse correlationIDResponseHeader(String correlationIDResponseHeader) {
    
    
    
    
    this.correlationIDResponseHeader = correlationIDResponseHeader;
    return this;
  }

   /**
   * Specifies the name of the HTTP response header that will contain a correlation ID value. Example values are \&quot;Correlation-Id\&quot;, \&quot;X-Amzn-Trace-Id\&quot;, and \&quot;X-Request-Id\&quot;.
   * @return correlationIDResponseHeader
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the name of the HTTP response header that will contain a correlation ID value. Example values are \"Correlation-Id\", \"X-Amzn-Trace-Id\", and \"X-Request-Id\".")

  public String getCorrelationIDResponseHeader() {
    return correlationIDResponseHeader;
  }


  public void setCorrelationIDResponseHeader(String correlationIDResponseHeader) {
    
    
    
    this.correlationIDResponseHeader = correlationIDResponseHeader;
  }


  public FileServerHttpServletExtensionResponse meta(MetaMeta meta) {
    
    
    
    
    this.meta = meta;
    return this;
  }

   /**
   * Get meta
   * @return meta
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public MetaMeta getMeta() {
    return meta;
  }


  public void setMeta(MetaMeta meta) {
    
    
    
    this.meta = meta;
  }


  public FileServerHttpServletExtensionResponse urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20(MetaUrnPingidentitySchemasConfigurationMessages20 urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20) {
    
    
    
    
    this.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20 = urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;
    return this;
  }

   /**
   * Get urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20
   * @return urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public MetaUrnPingidentitySchemasConfigurationMessages20 getUrnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20() {
    return urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;
  }


  public void setUrnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20(MetaUrnPingidentitySchemasConfigurationMessages20 urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20) {
    
    
    
    this.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20 = urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the FileServerHttpServletExtensionResponse instance itself
   */
  public FileServerHttpServletExtensionResponse putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FileServerHttpServletExtensionResponse fileServerHttpServletExtensionResponse = (FileServerHttpServletExtensionResponse) o;
    return Objects.equals(this.id, fileServerHttpServletExtensionResponse.id) &&
        Objects.equals(this.description, fileServerHttpServletExtensionResponse.description) &&
        Objects.equals(this.schemas, fileServerHttpServletExtensionResponse.schemas) &&
        Objects.equals(this.baseContextPath, fileServerHttpServletExtensionResponse.baseContextPath) &&
        Objects.equals(this.documentRootDirectory, fileServerHttpServletExtensionResponse.documentRootDirectory) &&
        Objects.equals(this.enableDirectoryIndexing, fileServerHttpServletExtensionResponse.enableDirectoryIndexing) &&
        Objects.equals(this.indexFile, fileServerHttpServletExtensionResponse.indexFile) &&
        Objects.equals(this.mimeTypesFile, fileServerHttpServletExtensionResponse.mimeTypesFile) &&
        Objects.equals(this.defaultMIMEType, fileServerHttpServletExtensionResponse.defaultMIMEType) &&
        Objects.equals(this.requireAuthentication, fileServerHttpServletExtensionResponse.requireAuthentication) &&
        Objects.equals(this.allowedAuthenticationType, fileServerHttpServletExtensionResponse.allowedAuthenticationType) &&
        Objects.equals(this.accessTokenValidator, fileServerHttpServletExtensionResponse.accessTokenValidator) &&
        Objects.equals(this.idTokenValidator, fileServerHttpServletExtensionResponse.idTokenValidator) &&
        Objects.equals(this.requireFileServletAccessPrivilege, fileServerHttpServletExtensionResponse.requireFileServletAccessPrivilege) &&
        Objects.equals(this.requireGroup, fileServerHttpServletExtensionResponse.requireGroup) &&
        Objects.equals(this.identityMapper, fileServerHttpServletExtensionResponse.identityMapper) &&
        Objects.equals(this.crossOriginPolicy, fileServerHttpServletExtensionResponse.crossOriginPolicy) &&
        Objects.equals(this.responseHeader, fileServerHttpServletExtensionResponse.responseHeader) &&
        Objects.equals(this.correlationIDResponseHeader, fileServerHttpServletExtensionResponse.correlationIDResponseHeader) &&
        Objects.equals(this.meta, fileServerHttpServletExtensionResponse.meta) &&
        Objects.equals(this.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20, fileServerHttpServletExtensionResponse.urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20)&&
        Objects.equals(this.additionalProperties, fileServerHttpServletExtensionResponse.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, description, schemas, baseContextPath, documentRootDirectory, enableDirectoryIndexing, indexFile, mimeTypesFile, defaultMIMEType, requireAuthentication, allowedAuthenticationType, accessTokenValidator, idTokenValidator, requireFileServletAccessPrivilege, requireGroup, identityMapper, crossOriginPolicy, responseHeader, correlationIDResponseHeader, meta, urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FileServerHttpServletExtensionResponse {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    schemas: ").append(toIndentedString(schemas)).append("\n");
    sb.append("    baseContextPath: ").append(toIndentedString(baseContextPath)).append("\n");
    sb.append("    documentRootDirectory: ").append(toIndentedString(documentRootDirectory)).append("\n");
    sb.append("    enableDirectoryIndexing: ").append(toIndentedString(enableDirectoryIndexing)).append("\n");
    sb.append("    indexFile: ").append(toIndentedString(indexFile)).append("\n");
    sb.append("    mimeTypesFile: ").append(toIndentedString(mimeTypesFile)).append("\n");
    sb.append("    defaultMIMEType: ").append(toIndentedString(defaultMIMEType)).append("\n");
    sb.append("    requireAuthentication: ").append(toIndentedString(requireAuthentication)).append("\n");
    sb.append("    allowedAuthenticationType: ").append(toIndentedString(allowedAuthenticationType)).append("\n");
    sb.append("    accessTokenValidator: ").append(toIndentedString(accessTokenValidator)).append("\n");
    sb.append("    idTokenValidator: ").append(toIndentedString(idTokenValidator)).append("\n");
    sb.append("    requireFileServletAccessPrivilege: ").append(toIndentedString(requireFileServletAccessPrivilege)).append("\n");
    sb.append("    requireGroup: ").append(toIndentedString(requireGroup)).append("\n");
    sb.append("    identityMapper: ").append(toIndentedString(identityMapper)).append("\n");
    sb.append("    crossOriginPolicy: ").append(toIndentedString(crossOriginPolicy)).append("\n");
    sb.append("    responseHeader: ").append(toIndentedString(responseHeader)).append("\n");
    sb.append("    correlationIDResponseHeader: ").append(toIndentedString(correlationIDResponseHeader)).append("\n");
    sb.append("    meta: ").append(toIndentedString(meta)).append("\n");
    sb.append("    urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20: ").append(toIndentedString(urnColonPingidentityColonSchemasColonConfigurationColonMessagesColon20)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("description");
    openapiFields.add("schemas");
    openapiFields.add("baseContextPath");
    openapiFields.add("documentRootDirectory");
    openapiFields.add("enableDirectoryIndexing");
    openapiFields.add("indexFile");
    openapiFields.add("mimeTypesFile");
    openapiFields.add("defaultMIMEType");
    openapiFields.add("requireAuthentication");
    openapiFields.add("allowedAuthenticationType");
    openapiFields.add("accessTokenValidator");
    openapiFields.add("idTokenValidator");
    openapiFields.add("requireFileServletAccessPrivilege");
    openapiFields.add("requireGroup");
    openapiFields.add("identityMapper");
    openapiFields.add("crossOriginPolicy");
    openapiFields.add("responseHeader");
    openapiFields.add("correlationIDResponseHeader");
    openapiFields.add("meta");
    openapiFields.add("urn:pingidentity:schemas:configuration:messages:2.0");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("schemas");
    openapiRequiredFields.add("baseContextPath");
    openapiRequiredFields.add("documentRootDirectory");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to FileServerHttpServletExtensionResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!FileServerHttpServletExtensionResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FileServerHttpServletExtensionResponse is not found in the empty JSON string", FileServerHttpServletExtensionResponse.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FileServerHttpServletExtensionResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("schemas") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("schemas").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `schemas` to be an array in the JSON string but got `%s`", jsonObj.get("schemas").toString()));
      }
      if (!jsonObj.get("baseContextPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseContextPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseContextPath").toString()));
      }
      if (!jsonObj.get("documentRootDirectory").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentRootDirectory` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentRootDirectory").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("indexFile") != null && !jsonObj.get("indexFile").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `indexFile` to be an array in the JSON string but got `%s`", jsonObj.get("indexFile").toString()));
      }
      if ((jsonObj.get("mimeTypesFile") != null && !jsonObj.get("mimeTypesFile").isJsonNull()) && !jsonObj.get("mimeTypesFile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeTypesFile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeTypesFile").toString()));
      }
      if ((jsonObj.get("defaultMIMEType") != null && !jsonObj.get("defaultMIMEType").isJsonNull()) && !jsonObj.get("defaultMIMEType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultMIMEType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultMIMEType").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedAuthenticationType") != null && !jsonObj.get("allowedAuthenticationType").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedAuthenticationType` to be an array in the JSON string but got `%s`", jsonObj.get("allowedAuthenticationType").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("accessTokenValidator") != null && !jsonObj.get("accessTokenValidator").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `accessTokenValidator` to be an array in the JSON string but got `%s`", jsonObj.get("accessTokenValidator").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("idTokenValidator") != null && !jsonObj.get("idTokenValidator").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `idTokenValidator` to be an array in the JSON string but got `%s`", jsonObj.get("idTokenValidator").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("requireGroup") != null && !jsonObj.get("requireGroup").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `requireGroup` to be an array in the JSON string but got `%s`", jsonObj.get("requireGroup").toString()));
      }
      if ((jsonObj.get("identityMapper") != null && !jsonObj.get("identityMapper").isJsonNull()) && !jsonObj.get("identityMapper").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `identityMapper` to be a primitive type in the JSON string but got `%s`", jsonObj.get("identityMapper").toString()));
      }
      if ((jsonObj.get("crossOriginPolicy") != null && !jsonObj.get("crossOriginPolicy").isJsonNull()) && !jsonObj.get("crossOriginPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crossOriginPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crossOriginPolicy").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("responseHeader") != null && !jsonObj.get("responseHeader").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `responseHeader` to be an array in the JSON string but got `%s`", jsonObj.get("responseHeader").toString()));
      }
      if ((jsonObj.get("correlationIDResponseHeader") != null && !jsonObj.get("correlationIDResponseHeader").isJsonNull()) && !jsonObj.get("correlationIDResponseHeader").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `correlationIDResponseHeader` to be a primitive type in the JSON string but got `%s`", jsonObj.get("correlationIDResponseHeader").toString()));
      }
      // validate the optional field `meta`
      if (jsonObj.get("meta") != null && !jsonObj.get("meta").isJsonNull()) {
        MetaMeta.validateJsonObject(jsonObj.getAsJsonObject("meta"));
      }
      // validate the optional field `urn:pingidentity:schemas:configuration:messages:2.0`
      if (jsonObj.get("urn:pingidentity:schemas:configuration:messages:2.0") != null && !jsonObj.get("urn:pingidentity:schemas:configuration:messages:2.0").isJsonNull()) {
        MetaUrnPingidentitySchemasConfigurationMessages20.validateJsonObject(jsonObj.getAsJsonObject("urn:pingidentity:schemas:configuration:messages:2.0"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FileServerHttpServletExtensionResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FileServerHttpServletExtensionResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FileServerHttpServletExtensionResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FileServerHttpServletExtensionResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<FileServerHttpServletExtensionResponse>() {
           @Override
           public void write(JsonWriter out, FileServerHttpServletExtensionResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public FileServerHttpServletExtensionResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             FileServerHttpServletExtensionResponse instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FileServerHttpServletExtensionResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FileServerHttpServletExtensionResponse
  * @throws IOException if the JSON string is invalid with respect to FileServerHttpServletExtensionResponse
  */
  public static FileServerHttpServletExtensionResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FileServerHttpServletExtensionResponse.class);
  }

 /**
  * Convert an instance of FileServerHttpServletExtensionResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

