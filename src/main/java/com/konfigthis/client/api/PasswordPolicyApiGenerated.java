/*
 * PingData Config - OpenAPI 3.0
 * This is the PingData Configuration API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AddPasswordPolicyRequest;
import com.konfigthis.client.model.EnumpasswordPolicyAllowPreEncodedPasswordsProp;
import com.konfigthis.client.model.EnumpasswordPolicyAllowedPasswordResetTokenUseConditionProp;
import com.konfigthis.client.model.EnumpasswordPolicyBindPasswordValidationFailureActionProp;
import com.konfigthis.client.model.EnumpasswordPolicyPasswordRetirementBehaviorProp;
import com.konfigthis.client.model.EnumpasswordPolicyRecentLoginHistorySimilarAttemptBehaviorProp;
import com.konfigthis.client.model.EnumpasswordPolicyReturnPasswordExpirationControlsProp;
import com.konfigthis.client.model.EnumpasswordPolicySchemaUrn;
import com.konfigthis.client.model.EnumpasswordPolicyStateUpdateFailurePolicyProp;
import com.konfigthis.client.model.Operation;
import com.konfigthis.client.model.PasswordPolicyListResponse;
import com.konfigthis.client.model.PasswordPolicyResponse;
import com.konfigthis.client.model.UpdateRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class PasswordPolicyApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PasswordPolicyApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public PasswordPolicyApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call addNewPolicyToConfigCall(AddPasswordPolicyRequest addPasswordPolicyRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = addPasswordPolicyRequest;

        // create path and map variables
        String localVarPath = "/password-policies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addNewPolicyToConfigValidateBeforeCall(AddPasswordPolicyRequest addPasswordPolicyRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'addPasswordPolicyRequest' is set
        if (addPasswordPolicyRequest == null) {
            throw new ApiException("Missing the required parameter 'addPasswordPolicyRequest' when calling addNewPolicyToConfig(Async)");
        }

        return addNewPolicyToConfigCall(addPasswordPolicyRequest, _callback);

    }


    private ApiResponse<PasswordPolicyResponse> addNewPolicyToConfigWithHttpInfo(AddPasswordPolicyRequest addPasswordPolicyRequest) throws ApiException {
        okhttp3.Call localVarCall = addNewPolicyToConfigValidateBeforeCall(addPasswordPolicyRequest, null);
        Type localVarReturnType = new TypeToken<PasswordPolicyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call addNewPolicyToConfigAsync(AddPasswordPolicyRequest addPasswordPolicyRequest, final ApiCallback<PasswordPolicyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = addNewPolicyToConfigValidateBeforeCall(addPasswordPolicyRequest, _callback);
        Type localVarReturnType = new TypeToken<PasswordPolicyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class AddNewPolicyToConfigRequestBuilder {
        private final String policyName;
        private String description;
        private List<EnumpasswordPolicySchemaUrn> schemas;
        private Boolean requireSecureAuthentication;
        private Boolean requireSecurePasswordChanges;
        private List<String> accountStatusNotificationHandler;
        private EnumpasswordPolicyStateUpdateFailurePolicyProp stateUpdateFailurePolicy;
        private Boolean enableDebug;
        private String passwordAttribute;
        private List<String> defaultPasswordStorageScheme;
        private List<String> deprecatedPasswordStorageScheme;
        private Boolean reEncodePasswordsOnSchemeConfigChange;
        private Boolean allowMultiplePasswordValues;
        private EnumpasswordPolicyAllowPreEncodedPasswordsProp allowPreEncodedPasswords;
        private List<String> passwordValidator;
        private List<String> bindPasswordValidator;
        private String minimumBindPasswordValidationFrequency;
        private EnumpasswordPolicyBindPasswordValidationFailureActionProp bindPasswordValidationFailureAction;
        private String passwordGenerator;
        private Integer passwordHistoryCount;
        private String passwordHistoryDuration;
        private String minPasswordAge;
        private String maxPasswordAge;
        private String passwordExpirationWarningInterval;
        private Boolean expirePasswordsWithoutWarning;
        private EnumpasswordPolicyReturnPasswordExpirationControlsProp returnPasswordExpirationControls;
        private Boolean allowExpiredPasswordChanges;
        private Integer graceLoginCount;
        private String requireChangeByTime;
        private Integer lockoutFailureCount;
        private String lockoutDuration;
        private String lockoutFailureExpirationInterval;
        private Boolean ignoreDuplicatePasswordFailures;
        private String failureLockoutAction;
        private String idleLockoutInterval;
        private Boolean allowUserPasswordChanges;
        private Boolean passwordChangeRequiresCurrentPassword;
        private List<EnumpasswordPolicyPasswordRetirementBehaviorProp> passwordRetirementBehavior;
        private String maxRetiredPasswordAge;
        private List<EnumpasswordPolicyAllowedPasswordResetTokenUseConditionProp> allowedPasswordResetTokenUseCondition;
        private Boolean forceChangeOnAdd;
        private Boolean forceChangeOnReset;
        private String maxPasswordResetAge;
        private Boolean skipValidationForAdministrators;
        private Integer maximumRecentLoginHistorySuccessfulAuthenticationCount;
        private String maximumRecentLoginHistorySuccessfulAuthenticationDuration;
        private Integer maximumRecentLoginHistoryFailedAuthenticationCount;
        private String maximumRecentLoginHistoryFailedAuthenticationDuration;
        private EnumpasswordPolicyRecentLoginHistorySimilarAttemptBehaviorProp recentLoginHistorySimilarAttemptBehavior;
        private String lastLoginIPAddressAttribute;
        private String lastLoginTimeAttribute;
        private String lastLoginTimeFormat;
        private List<String> previousLastLoginTimeFormat;

        private AddNewPolicyToConfigRequestBuilder(String policyName) {
            this.policyName = policyName;
        }

        /**
         * Set description
         * @param description A description for this Password Policy (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set schemas
         * @param schemas  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder schemas(List<EnumpasswordPolicySchemaUrn> schemas) {
            this.schemas = schemas;
            return this;
        }
        
        /**
         * Set requireSecureAuthentication
         * @param requireSecureAuthentication Indicates whether users with the associated password policy are required to authenticate in a secure manner. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder requireSecureAuthentication(Boolean requireSecureAuthentication) {
            this.requireSecureAuthentication = requireSecureAuthentication;
            return this;
        }
        
        /**
         * Set requireSecurePasswordChanges
         * @param requireSecurePasswordChanges Indicates whether users with the associated password policy are required to change their password in a secure manner that does not expose the credentials. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder requireSecurePasswordChanges(Boolean requireSecurePasswordChanges) {
            this.requireSecurePasswordChanges = requireSecurePasswordChanges;
            return this;
        }
        
        /**
         * Set accountStatusNotificationHandler
         * @param accountStatusNotificationHandler Specifies the names of the account status notification handlers that are used with the associated password storage scheme. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder accountStatusNotificationHandler(List<String> accountStatusNotificationHandler) {
            this.accountStatusNotificationHandler = accountStatusNotificationHandler;
            return this;
        }
        
        /**
         * Set stateUpdateFailurePolicy
         * @param stateUpdateFailurePolicy  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder stateUpdateFailurePolicy(EnumpasswordPolicyStateUpdateFailurePolicyProp stateUpdateFailurePolicy) {
            this.stateUpdateFailurePolicy = stateUpdateFailurePolicy;
            return this;
        }
        
        /**
         * Set enableDebug
         * @param enableDebug Indicates whether to enable debugging for the password policy state. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder enableDebug(Boolean enableDebug) {
            this.enableDebug = enableDebug;
            return this;
        }
        
        /**
         * Set passwordAttribute
         * @param passwordAttribute Specifies the attribute type used to hold user passwords. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordAttribute(String passwordAttribute) {
            this.passwordAttribute = passwordAttribute;
            return this;
        }
        
        /**
         * Set defaultPasswordStorageScheme
         * @param defaultPasswordStorageScheme Specifies the names of the password storage schemes that are used to encode clear-text passwords for this password policy. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder defaultPasswordStorageScheme(List<String> defaultPasswordStorageScheme) {
            this.defaultPasswordStorageScheme = defaultPasswordStorageScheme;
            return this;
        }
        
        /**
         * Set deprecatedPasswordStorageScheme
         * @param deprecatedPasswordStorageScheme Specifies the names of the password storage schemes that are considered deprecated for this password policy. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder deprecatedPasswordStorageScheme(List<String> deprecatedPasswordStorageScheme) {
            this.deprecatedPasswordStorageScheme = deprecatedPasswordStorageScheme;
            return this;
        }
        
        /**
         * Set reEncodePasswordsOnSchemeConfigChange
         * @param reEncodePasswordsOnSchemeConfigChange Indicates whether to re-encode passwords on authentication if the configuration for the underlying password storage scheme has changed. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder reEncodePasswordsOnSchemeConfigChange(Boolean reEncodePasswordsOnSchemeConfigChange) {
            this.reEncodePasswordsOnSchemeConfigChange = reEncodePasswordsOnSchemeConfigChange;
            return this;
        }
        
        /**
         * Set allowMultiplePasswordValues
         * @param allowMultiplePasswordValues Indicates whether user entries can have multiple distinct values for the password attribute. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder allowMultiplePasswordValues(Boolean allowMultiplePasswordValues) {
            this.allowMultiplePasswordValues = allowMultiplePasswordValues;
            return this;
        }
        
        /**
         * Set allowPreEncodedPasswords
         * @param allowPreEncodedPasswords  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder allowPreEncodedPasswords(EnumpasswordPolicyAllowPreEncodedPasswordsProp allowPreEncodedPasswords) {
            this.allowPreEncodedPasswords = allowPreEncodedPasswords;
            return this;
        }
        
        /**
         * Set passwordValidator
         * @param passwordValidator Specifies the names of the password validators that are used with the associated password storage scheme. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordValidator(List<String> passwordValidator) {
            this.passwordValidator = passwordValidator;
            return this;
        }
        
        /**
         * Set bindPasswordValidator
         * @param bindPasswordValidator Specifies the names of the password validators that should be invoked for bind operations. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder bindPasswordValidator(List<String> bindPasswordValidator) {
            this.bindPasswordValidator = bindPasswordValidator;
            return this;
        }
        
        /**
         * Set minimumBindPasswordValidationFrequency
         * @param minimumBindPasswordValidationFrequency Indicates how frequently password validation should be performed during bind operations for each user to whom this password policy is assigned. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder minimumBindPasswordValidationFrequency(String minimumBindPasswordValidationFrequency) {
            this.minimumBindPasswordValidationFrequency = minimumBindPasswordValidationFrequency;
            return this;
        }
        
        /**
         * Set bindPasswordValidationFailureAction
         * @param bindPasswordValidationFailureAction  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder bindPasswordValidationFailureAction(EnumpasswordPolicyBindPasswordValidationFailureActionProp bindPasswordValidationFailureAction) {
            this.bindPasswordValidationFailureAction = bindPasswordValidationFailureAction;
            return this;
        }
        
        /**
         * Set passwordGenerator
         * @param passwordGenerator Specifies the name of the password generator that is used with the associated password policy. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordGenerator(String passwordGenerator) {
            this.passwordGenerator = passwordGenerator;
            return this;
        }
        
        /**
         * Set passwordHistoryCount
         * @param passwordHistoryCount Specifies the maximum number of former passwords to maintain in the password history. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordHistoryCount(Integer passwordHistoryCount) {
            this.passwordHistoryCount = passwordHistoryCount;
            return this;
        }
        
        /**
         * Set passwordHistoryDuration
         * @param passwordHistoryDuration Specifies the maximum length of time that passwords remain in the password history. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordHistoryDuration(String passwordHistoryDuration) {
            this.passwordHistoryDuration = passwordHistoryDuration;
            return this;
        }
        
        /**
         * Set minPasswordAge
         * @param minPasswordAge Specifies the minimum length of time after a password change before the user is allowed to change the password again. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder minPasswordAge(String minPasswordAge) {
            this.minPasswordAge = minPasswordAge;
            return this;
        }
        
        /**
         * Set maxPasswordAge
         * @param maxPasswordAge Specifies the maximum length of time that a user can continue using the same password before it must be changed (that is, the password expiration interval). (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maxPasswordAge(String maxPasswordAge) {
            this.maxPasswordAge = maxPasswordAge;
            return this;
        }
        
        /**
         * Set passwordExpirationWarningInterval
         * @param passwordExpirationWarningInterval Specifies the maximum length of time before a user&#39;s password actually expires that the server begins to include warning notifications in bind responses for that user. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordExpirationWarningInterval(String passwordExpirationWarningInterval) {
            this.passwordExpirationWarningInterval = passwordExpirationWarningInterval;
            return this;
        }
        
        /**
         * Set expirePasswordsWithoutWarning
         * @param expirePasswordsWithoutWarning Indicates whether the Directory Server allows a user&#39;s password to expire even if that user has never seen an expiration warning notification. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder expirePasswordsWithoutWarning(Boolean expirePasswordsWithoutWarning) {
            this.expirePasswordsWithoutWarning = expirePasswordsWithoutWarning;
            return this;
        }
        
        /**
         * Set returnPasswordExpirationControls
         * @param returnPasswordExpirationControls  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder returnPasswordExpirationControls(EnumpasswordPolicyReturnPasswordExpirationControlsProp returnPasswordExpirationControls) {
            this.returnPasswordExpirationControls = returnPasswordExpirationControls;
            return this;
        }
        
        /**
         * Set allowExpiredPasswordChanges
         * @param allowExpiredPasswordChanges Indicates whether a user whose password is expired is still allowed to change that password using the password modify extended operation. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder allowExpiredPasswordChanges(Boolean allowExpiredPasswordChanges) {
            this.allowExpiredPasswordChanges = allowExpiredPasswordChanges;
            return this;
        }
        
        /**
         * Set graceLoginCount
         * @param graceLoginCount Specifies the number of grace logins that a user is allowed after the account has expired to allow that user to choose a new password. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder graceLoginCount(Integer graceLoginCount) {
            this.graceLoginCount = graceLoginCount;
            return this;
        }
        
        /**
         * Set requireChangeByTime
         * @param requireChangeByTime Specifies the time by which all users with the associated password policy must change their passwords. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder requireChangeByTime(String requireChangeByTime) {
            this.requireChangeByTime = requireChangeByTime;
            return this;
        }
        
        /**
         * Set lockoutFailureCount
         * @param lockoutFailureCount Specifies the maximum number of authentication failures that a user is allowed before the account is locked out. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder lockoutFailureCount(Integer lockoutFailureCount) {
            this.lockoutFailureCount = lockoutFailureCount;
            return this;
        }
        
        /**
         * Set lockoutDuration
         * @param lockoutDuration Specifies the length of time that an account is locked after too many authentication failures. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder lockoutDuration(String lockoutDuration) {
            this.lockoutDuration = lockoutDuration;
            return this;
        }
        
        /**
         * Set lockoutFailureExpirationInterval
         * @param lockoutFailureExpirationInterval Specifies the length of time before an authentication failure is no longer counted against a user for the purposes of account lockout. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder lockoutFailureExpirationInterval(String lockoutFailureExpirationInterval) {
            this.lockoutFailureExpirationInterval = lockoutFailureExpirationInterval;
            return this;
        }
        
        /**
         * Set ignoreDuplicatePasswordFailures
         * @param ignoreDuplicatePasswordFailures Indicates whether to ignore subsequent authentication failures using the same password as an earlier failed authentication attempt (within the time frame defined by the lockout failure expiration interval). If this option is \\\&quot;true\\\&quot;, then multiple failed attempts using the same password will be considered only a single failure. If this option is \\\&quot;false\\\&quot;, then any failure will be tracked regardless of whether it used the same password as an earlier attempt. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder ignoreDuplicatePasswordFailures(Boolean ignoreDuplicatePasswordFailures) {
            this.ignoreDuplicatePasswordFailures = ignoreDuplicatePasswordFailures;
            return this;
        }
        
        /**
         * Set failureLockoutAction
         * @param failureLockoutAction The action that the server should take for authentication attempts that target a user with more than the configured number of outstanding authentication failures. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder failureLockoutAction(String failureLockoutAction) {
            this.failureLockoutAction = failureLockoutAction;
            return this;
        }
        
        /**
         * Set idleLockoutInterval
         * @param idleLockoutInterval Specifies the maximum length of time that an account may remain idle (that is, the associated user does not authenticate to the server) before that user is locked out. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder idleLockoutInterval(String idleLockoutInterval) {
            this.idleLockoutInterval = idleLockoutInterval;
            return this;
        }
        
        /**
         * Set allowUserPasswordChanges
         * @param allowUserPasswordChanges Indicates whether users can change their own passwords. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder allowUserPasswordChanges(Boolean allowUserPasswordChanges) {
            this.allowUserPasswordChanges = allowUserPasswordChanges;
            return this;
        }
        
        /**
         * Set passwordChangeRequiresCurrentPassword
         * @param passwordChangeRequiresCurrentPassword Indicates whether user password changes must use the password modify extended operation and must include the user&#39;s current password before the change is allowed. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordChangeRequiresCurrentPassword(Boolean passwordChangeRequiresCurrentPassword) {
            this.passwordChangeRequiresCurrentPassword = passwordChangeRequiresCurrentPassword;
            return this;
        }
        
        /**
         * Set passwordRetirementBehavior
         * @param passwordRetirementBehavior  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder passwordRetirementBehavior(List<EnumpasswordPolicyPasswordRetirementBehaviorProp> passwordRetirementBehavior) {
            this.passwordRetirementBehavior = passwordRetirementBehavior;
            return this;
        }
        
        /**
         * Set maxRetiredPasswordAge
         * @param maxRetiredPasswordAge Specifies the maximum length of time that a retired password should be considered valid and may be used to authenticate to the server. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maxRetiredPasswordAge(String maxRetiredPasswordAge) {
            this.maxRetiredPasswordAge = maxRetiredPasswordAge;
            return this;
        }
        
        /**
         * Set allowedPasswordResetTokenUseCondition
         * @param allowedPasswordResetTokenUseCondition  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder allowedPasswordResetTokenUseCondition(List<EnumpasswordPolicyAllowedPasswordResetTokenUseConditionProp> allowedPasswordResetTokenUseCondition) {
            this.allowedPasswordResetTokenUseCondition = allowedPasswordResetTokenUseCondition;
            return this;
        }
        
        /**
         * Set forceChangeOnAdd
         * @param forceChangeOnAdd Indicates whether users are forced to change their passwords upon first authenticating to the Directory Server after their account has been created. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder forceChangeOnAdd(Boolean forceChangeOnAdd) {
            this.forceChangeOnAdd = forceChangeOnAdd;
            return this;
        }
        
        /**
         * Set forceChangeOnReset
         * @param forceChangeOnReset Indicates whether users are forced to change their passwords if they are reset by an administrator. If a user&#39;s password is changed by any other user, that is considered an administrative password reset. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder forceChangeOnReset(Boolean forceChangeOnReset) {
            this.forceChangeOnReset = forceChangeOnReset;
            return this;
        }
        
        /**
         * Set maxPasswordResetAge
         * @param maxPasswordResetAge Specifies the maximum length of time that users have to change passwords after they have been reset by an administrator before they become locked. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maxPasswordResetAge(String maxPasswordResetAge) {
            this.maxPasswordResetAge = maxPasswordResetAge;
            return this;
        }
        
        /**
         * Set skipValidationForAdministrators
         * @param skipValidationForAdministrators Indicates whether passwords set by administrators are allowed to bypass the password validation process that is required for user password changes. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder skipValidationForAdministrators(Boolean skipValidationForAdministrators) {
            this.skipValidationForAdministrators = skipValidationForAdministrators;
            return this;
        }
        
        /**
         * Set maximumRecentLoginHistorySuccessfulAuthenticationCount
         * @param maximumRecentLoginHistorySuccessfulAuthenticationCount The maximum number of successful authentication attempts to include in the recent login history for each account. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maximumRecentLoginHistorySuccessfulAuthenticationCount(Integer maximumRecentLoginHistorySuccessfulAuthenticationCount) {
            this.maximumRecentLoginHistorySuccessfulAuthenticationCount = maximumRecentLoginHistorySuccessfulAuthenticationCount;
            return this;
        }
        
        /**
         * Set maximumRecentLoginHistorySuccessfulAuthenticationDuration
         * @param maximumRecentLoginHistorySuccessfulAuthenticationDuration The maximum age of successful authentication attempts to include in the recent login history for each account. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maximumRecentLoginHistorySuccessfulAuthenticationDuration(String maximumRecentLoginHistorySuccessfulAuthenticationDuration) {
            this.maximumRecentLoginHistorySuccessfulAuthenticationDuration = maximumRecentLoginHistorySuccessfulAuthenticationDuration;
            return this;
        }
        
        /**
         * Set maximumRecentLoginHistoryFailedAuthenticationCount
         * @param maximumRecentLoginHistoryFailedAuthenticationCount The maximum number of failed authentication attempts to include in the recent login history for each account. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maximumRecentLoginHistoryFailedAuthenticationCount(Integer maximumRecentLoginHistoryFailedAuthenticationCount) {
            this.maximumRecentLoginHistoryFailedAuthenticationCount = maximumRecentLoginHistoryFailedAuthenticationCount;
            return this;
        }
        
        /**
         * Set maximumRecentLoginHistoryFailedAuthenticationDuration
         * @param maximumRecentLoginHistoryFailedAuthenticationDuration The maximum age of failed authentication attempts to include in the recent login history for each account. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder maximumRecentLoginHistoryFailedAuthenticationDuration(String maximumRecentLoginHistoryFailedAuthenticationDuration) {
            this.maximumRecentLoginHistoryFailedAuthenticationDuration = maximumRecentLoginHistoryFailedAuthenticationDuration;
            return this;
        }
        
        /**
         * Set recentLoginHistorySimilarAttemptBehavior
         * @param recentLoginHistorySimilarAttemptBehavior  (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder recentLoginHistorySimilarAttemptBehavior(EnumpasswordPolicyRecentLoginHistorySimilarAttemptBehaviorProp recentLoginHistorySimilarAttemptBehavior) {
            this.recentLoginHistorySimilarAttemptBehavior = recentLoginHistorySimilarAttemptBehavior;
            return this;
        }
        
        /**
         * Set lastLoginIPAddressAttribute
         * @param lastLoginIPAddressAttribute Specifies the name or OID of the attribute type that is used to hold the IP address of the client from which the user last authenticated. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder lastLoginIPAddressAttribute(String lastLoginIPAddressAttribute) {
            this.lastLoginIPAddressAttribute = lastLoginIPAddressAttribute;
            return this;
        }
        
        /**
         * Set lastLoginTimeAttribute
         * @param lastLoginTimeAttribute Specifies the name or OID of the attribute type that is used to hold the last login time for users with the associated password policy. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder lastLoginTimeAttribute(String lastLoginTimeAttribute) {
            this.lastLoginTimeAttribute = lastLoginTimeAttribute;
            return this;
        }
        
        /**
         * Set lastLoginTimeFormat
         * @param lastLoginTimeFormat Specifies the format string that is used to generate the last login time value for users with the associated password policy. Last login time values will be written using the UTC (also known as GMT, or Greenwich Mean Time) time zone. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder lastLoginTimeFormat(String lastLoginTimeFormat) {
            this.lastLoginTimeFormat = lastLoginTimeFormat;
            return this;
        }
        
        /**
         * Set previousLastLoginTimeFormat
         * @param previousLastLoginTimeFormat Specifies the format string(s) that might have been used with the last login time at any point in the past for users associated with the password policy. (optional)
         * @return AddNewPolicyToConfigRequestBuilder
         */
        public AddNewPolicyToConfigRequestBuilder previousLastLoginTimeFormat(List<String> previousLastLoginTimeFormat) {
            this.previousLastLoginTimeFormat = previousLastLoginTimeFormat;
            return this;
        }
        
        /**
         * Build call for addNewPolicyToConfig
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AddPasswordPolicyRequest addPasswordPolicyRequest = buildBodyParams();
            return addNewPolicyToConfigCall(addPasswordPolicyRequest, _callback);
        }

        private AddPasswordPolicyRequest buildBodyParams() {
            AddPasswordPolicyRequest addPasswordPolicyRequest = new AddPasswordPolicyRequest();
            return addPasswordPolicyRequest;
        }

        /**
         * Execute addNewPolicyToConfig request
         * @return PasswordPolicyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public PasswordPolicyResponse execute() throws ApiException {
            AddPasswordPolicyRequest addPasswordPolicyRequest = buildBodyParams();
            ApiResponse<PasswordPolicyResponse> localVarResp = addNewPolicyToConfigWithHttpInfo(addPasswordPolicyRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute addNewPolicyToConfig request with HTTP info returned
         * @return ApiResponse&lt;PasswordPolicyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PasswordPolicyResponse> executeWithHttpInfo() throws ApiException {
            AddPasswordPolicyRequest addPasswordPolicyRequest = buildBodyParams();
            return addNewPolicyToConfigWithHttpInfo(addPasswordPolicyRequest);
        }

        /**
         * Execute addNewPolicyToConfig request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PasswordPolicyResponse> _callback) throws ApiException {
            AddPasswordPolicyRequest addPasswordPolicyRequest = buildBodyParams();
            return addNewPolicyToConfigAsync(addPasswordPolicyRequest, _callback);
        }
    }

    /**
     * Add a new Password Policy to the config
     * 
     * @param addPasswordPolicyRequest Create a new Password Policy in the config (required)
     * @return AddNewPolicyToConfigRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The Password Policy already exists </td><td>  -  </td></tr>
     </table>
     */
    public AddNewPolicyToConfigRequestBuilder addNewPolicyToConfig(String policyName) throws IllegalArgumentException {
        if (policyName == null) throw new IllegalArgumentException("\"policyName\" is required but got null");
            

        return new AddNewPolicyToConfigRequestBuilder(policyName);
    }
    private okhttp3.Call deletePolicyCall(String passwordPolicyName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/password-policies/{password-policy-name}"
            .replace("{" + "password-policy-name" + "}", localVarApiClient.escapeString(passwordPolicyName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deletePolicyValidateBeforeCall(String passwordPolicyName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'passwordPolicyName' is set
        if (passwordPolicyName == null) {
            throw new ApiException("Missing the required parameter 'passwordPolicyName' when calling deletePolicy(Async)");
        }

        return deletePolicyCall(passwordPolicyName, _callback);

    }


    private ApiResponse<Void> deletePolicyWithHttpInfo(String passwordPolicyName) throws ApiException {
        okhttp3.Call localVarCall = deletePolicyValidateBeforeCall(passwordPolicyName, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deletePolicyAsync(String passwordPolicyName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deletePolicyValidateBeforeCall(passwordPolicyName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeletePolicyRequestBuilder {
        private final String passwordPolicyName;

        private DeletePolicyRequestBuilder(String passwordPolicyName) {
            this.passwordPolicyName = passwordPolicyName;
        }

        /**
         * Build call for deletePolicy
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deletePolicyCall(passwordPolicyName, _callback);
        }


        /**
         * Execute deletePolicy request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deletePolicyWithHttpInfo(passwordPolicyName);
        }

        /**
         * Execute deletePolicy request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deletePolicyWithHttpInfo(passwordPolicyName);
        }

        /**
         * Execute deletePolicy request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Password Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deletePolicyAsync(passwordPolicyName, _callback);
        }
    }

    /**
     * Delete a Password Policy
     * 
     * @param passwordPolicyName Name of the Password Policy (required)
     * @return DeletePolicyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The Password Policy cannot be deleted </td><td>  -  </td></tr>
     </table>
     */
    public DeletePolicyRequestBuilder deletePolicy(String passwordPolicyName) throws IllegalArgumentException {
        if (passwordPolicyName == null) throw new IllegalArgumentException("\"passwordPolicyName\" is required but got null");
            

        return new DeletePolicyRequestBuilder(passwordPolicyName);
    }
    private okhttp3.Call getSinglePolicyCall(String passwordPolicyName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/password-policies/{password-policy-name}"
            .replace("{" + "password-policy-name" + "}", localVarApiClient.escapeString(passwordPolicyName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSinglePolicyValidateBeforeCall(String passwordPolicyName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'passwordPolicyName' is set
        if (passwordPolicyName == null) {
            throw new ApiException("Missing the required parameter 'passwordPolicyName' when calling getSinglePolicy(Async)");
        }

        return getSinglePolicyCall(passwordPolicyName, _callback);

    }


    private ApiResponse<PasswordPolicyResponse> getSinglePolicyWithHttpInfo(String passwordPolicyName) throws ApiException {
        okhttp3.Call localVarCall = getSinglePolicyValidateBeforeCall(passwordPolicyName, null);
        Type localVarReturnType = new TypeToken<PasswordPolicyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSinglePolicyAsync(String passwordPolicyName, final ApiCallback<PasswordPolicyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSinglePolicyValidateBeforeCall(passwordPolicyName, _callback);
        Type localVarReturnType = new TypeToken<PasswordPolicyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSinglePolicyRequestBuilder {
        private final String passwordPolicyName;

        private GetSinglePolicyRequestBuilder(String passwordPolicyName) {
            this.passwordPolicyName = passwordPolicyName;
        }

        /**
         * Build call for getSinglePolicy
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSinglePolicyCall(passwordPolicyName, _callback);
        }


        /**
         * Execute getSinglePolicy request
         * @return PasswordPolicyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public PasswordPolicyResponse execute() throws ApiException {
            ApiResponse<PasswordPolicyResponse> localVarResp = getSinglePolicyWithHttpInfo(passwordPolicyName);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSinglePolicy request with HTTP info returned
         * @return ApiResponse&lt;PasswordPolicyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PasswordPolicyResponse> executeWithHttpInfo() throws ApiException {
            return getSinglePolicyWithHttpInfo(passwordPolicyName);
        }

        /**
         * Execute getSinglePolicy request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PasswordPolicyResponse> _callback) throws ApiException {
            return getSinglePolicyAsync(passwordPolicyName, _callback);
        }
    }

    /**
     * Returns a single Password Policy
     * 
     * @param passwordPolicyName Name of the Password Policy (required)
     * @return GetSinglePolicyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
     </table>
     */
    public GetSinglePolicyRequestBuilder getSinglePolicy(String passwordPolicyName) throws IllegalArgumentException {
        if (passwordPolicyName == null) throw new IllegalArgumentException("\"passwordPolicyName\" is required but got null");
            

        return new GetSinglePolicyRequestBuilder(passwordPolicyName);
    }
    private okhttp3.Call listAllObjectsCall(String filter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/password-policies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAllObjectsValidateBeforeCall(String filter, final ApiCallback _callback) throws ApiException {
        return listAllObjectsCall(filter, _callback);

    }


    private ApiResponse<PasswordPolicyListResponse> listAllObjectsWithHttpInfo(String filter) throws ApiException {
        okhttp3.Call localVarCall = listAllObjectsValidateBeforeCall(filter, null);
        Type localVarReturnType = new TypeToken<PasswordPolicyListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAllObjectsAsync(String filter, final ApiCallback<PasswordPolicyListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAllObjectsValidateBeforeCall(filter, _callback);
        Type localVarReturnType = new TypeToken<PasswordPolicyListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListAllObjectsRequestBuilder {
        private String filter;

        private ListAllObjectsRequestBuilder() {
        }

        /**
         * Set filter
         * @param filter SCIM filter (optional)
         * @return ListAllObjectsRequestBuilder
         */
        public ListAllObjectsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Build call for listAllObjects
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAllObjectsCall(filter, _callback);
        }


        /**
         * Execute listAllObjects request
         * @return PasswordPolicyListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public PasswordPolicyListResponse execute() throws ApiException {
            ApiResponse<PasswordPolicyListResponse> localVarResp = listAllObjectsWithHttpInfo(filter);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listAllObjects request with HTTP info returned
         * @return ApiResponse&lt;PasswordPolicyListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PasswordPolicyListResponse> executeWithHttpInfo() throws ApiException {
            return listAllObjectsWithHttpInfo(filter);
        }

        /**
         * Execute listAllObjects request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PasswordPolicyListResponse> _callback) throws ApiException {
            return listAllObjectsAsync(filter, _callback);
        }
    }

    /**
     * Returns a list of all Password Policy objects
     * 
     * @return ListAllObjectsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
     </table>
     */
    public ListAllObjectsRequestBuilder listAllObjects() throws IllegalArgumentException {
        return new ListAllObjectsRequestBuilder();
    }
    private okhttp3.Call updateByNameCall(String passwordPolicyName, UpdateRequest updateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateRequest;

        // create path and map variables
        String localVarPath = "/password-policies/{password-policy-name}"
            .replace("{" + "password-policy-name" + "}", localVarApiClient.escapeString(passwordPolicyName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateByNameValidateBeforeCall(String passwordPolicyName, UpdateRequest updateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'passwordPolicyName' is set
        if (passwordPolicyName == null) {
            throw new ApiException("Missing the required parameter 'passwordPolicyName' when calling updateByName(Async)");
        }

        // verify the required parameter 'updateRequest' is set
        if (updateRequest == null) {
            throw new ApiException("Missing the required parameter 'updateRequest' when calling updateByName(Async)");
        }

        return updateByNameCall(passwordPolicyName, updateRequest, _callback);

    }


    private ApiResponse<PasswordPolicyResponse> updateByNameWithHttpInfo(String passwordPolicyName, UpdateRequest updateRequest) throws ApiException {
        okhttp3.Call localVarCall = updateByNameValidateBeforeCall(passwordPolicyName, updateRequest, null);
        Type localVarReturnType = new TypeToken<PasswordPolicyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateByNameAsync(String passwordPolicyName, UpdateRequest updateRequest, final ApiCallback<PasswordPolicyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateByNameValidateBeforeCall(passwordPolicyName, updateRequest, _callback);
        Type localVarReturnType = new TypeToken<PasswordPolicyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateByNameRequestBuilder {
        private final List<Operation> operations;
        private final String passwordPolicyName;

        private UpdateByNameRequestBuilder(List<Operation> operations, String passwordPolicyName) {
            this.operations = operations;
            this.passwordPolicyName = passwordPolicyName;
        }

        /**
         * Build call for updateByName
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameCall(passwordPolicyName, updateRequest, _callback);
        }

        private UpdateRequest buildBodyParams() {
            UpdateRequest updateRequest = new UpdateRequest();
            updateRequest.operations(this.operations);
            return updateRequest;
        }

        /**
         * Execute updateByName request
         * @return PasswordPolicyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public PasswordPolicyResponse execute() throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            ApiResponse<PasswordPolicyResponse> localVarResp = updateByNameWithHttpInfo(passwordPolicyName, updateRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateByName request with HTTP info returned
         * @return ApiResponse&lt;PasswordPolicyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PasswordPolicyResponse> executeWithHttpInfo() throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameWithHttpInfo(passwordPolicyName, updateRequest);
        }

        /**
         * Execute updateByName request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PasswordPolicyResponse> _callback) throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameAsync(passwordPolicyName, updateRequest, _callback);
        }
    }

    /**
     * Update an existing Password Policy by name
     * 
     * @param passwordPolicyName Name of the Password Policy (required)
     * @param updateRequest Update an existing Password Policy (required)
     * @return UpdateByNameRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Password Policy does not exist </td><td>  -  </td></tr>
     </table>
     */
    public UpdateByNameRequestBuilder updateByName(List<Operation> operations, String passwordPolicyName) throws IllegalArgumentException {
        if (operations == null) throw new IllegalArgumentException("\"operations\" is required but got null");
        if (passwordPolicyName == null) throw new IllegalArgumentException("\"passwordPolicyName\" is required but got null");
            

        return new UpdateByNameRequestBuilder(operations, passwordPolicyName);
    }
}
