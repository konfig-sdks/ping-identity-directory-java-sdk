/*
 * PingData Config - OpenAPI 3.0
 * This is the PingData Configuration API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AddClientConnectionPolicyRequest;
import com.konfigthis.client.model.ClientConnectionPolicyListResponse;
import com.konfigthis.client.model.ClientConnectionPolicyResponse;
import com.konfigthis.client.model.EnumclientConnectionPolicyAllowedAuthTypeProp;
import com.konfigthis.client.model.EnumclientConnectionPolicyAllowedFilterTypeProp;
import com.konfigthis.client.model.EnumclientConnectionPolicyAllowedOperationProp;
import com.konfigthis.client.model.EnumclientConnectionPolicyConnectionOperationRateExceededBehaviorProp;
import com.konfigthis.client.model.EnumclientConnectionPolicyMaximumConcurrentOperationsPerConnectionExceededBehaviorProp;
import com.konfigthis.client.model.EnumclientConnectionPolicyPolicyOperationRateExceededBehaviorProp;
import com.konfigthis.client.model.EnumclientConnectionPolicySchemaUrn;
import com.konfigthis.client.model.Operation;
import com.konfigthis.client.model.UpdateRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class ClientConnectionPolicyApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ClientConnectionPolicyApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public ClientConnectionPolicyApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call addNewPolicyCall(AddClientConnectionPolicyRequest addClientConnectionPolicyRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = addClientConnectionPolicyRequest;

        // create path and map variables
        String localVarPath = "/client-connection-policies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addNewPolicyValidateBeforeCall(AddClientConnectionPolicyRequest addClientConnectionPolicyRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'addClientConnectionPolicyRequest' is set
        if (addClientConnectionPolicyRequest == null) {
            throw new ApiException("Missing the required parameter 'addClientConnectionPolicyRequest' when calling addNewPolicy(Async)");
        }

        return addNewPolicyCall(addClientConnectionPolicyRequest, _callback);

    }


    private ApiResponse<ClientConnectionPolicyResponse> addNewPolicyWithHttpInfo(AddClientConnectionPolicyRequest addClientConnectionPolicyRequest) throws ApiException {
        okhttp3.Call localVarCall = addNewPolicyValidateBeforeCall(addClientConnectionPolicyRequest, null);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call addNewPolicyAsync(AddClientConnectionPolicyRequest addClientConnectionPolicyRequest, final ApiCallback<ClientConnectionPolicyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = addNewPolicyValidateBeforeCall(addClientConnectionPolicyRequest, _callback);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class AddNewPolicyRequestBuilder {
        private final String policyName;
        private String description;
        private List<EnumclientConnectionPolicySchemaUrn> schemas;
        private String policyID;
        private Boolean enabled;
        private Integer evaluationOrderIndex;
        private String connectionCriteria;
        private Boolean terminateConnection;
        private List<String> sensitiveAttribute;
        private List<String> excludeGlobalSensitiveAttribute;
        private String resultCodeMap;
        private List<String> includedBackendBaseDN;
        private List<String> excludedBackendBaseDN;
        private List<EnumclientConnectionPolicyAllowedOperationProp> allowedOperation;
        private String requiredOperationRequestCriteria;
        private String prohibitedOperationRequestCriteria;
        private List<String> allowedRequestControl;
        private List<String> deniedRequestControl;
        private List<String> allowedExtendedOperation;
        private List<String> deniedExtendedOperation;
        private List<EnumclientConnectionPolicyAllowedAuthTypeProp> allowedAuthType;
        private List<String> allowedSASLMechanism;
        private List<String> deniedSASLMechanism;
        private List<EnumclientConnectionPolicyAllowedFilterTypeProp> allowedFilterType;
        private Boolean allowUnindexedSearches;
        private Boolean allowUnindexedSearchesWithControl;
        private Integer minimumSubstringLength;
        private Integer maximumConcurrentConnections;
        private String maximumConnectionDuration;
        private String maximumIdleConnectionDuration;
        private Integer maximumOperationCountPerConnection;
        private Integer maximumConcurrentOperationsPerConnection;
        private String maximumConcurrentOperationWaitTimeBeforeRejecting;
        private EnumclientConnectionPolicyMaximumConcurrentOperationsPerConnectionExceededBehaviorProp maximumConcurrentOperationsPerConnectionExceededBehavior;
        private List<String> maximumConnectionOperationRate;
        private EnumclientConnectionPolicyConnectionOperationRateExceededBehaviorProp connectionOperationRateExceededBehavior;
        private List<String> maximumPolicyOperationRate;
        private EnumclientConnectionPolicyPolicyOperationRateExceededBehaviorProp policyOperationRateExceededBehavior;
        private Integer maximumSearchSizeLimit;
        private String maximumSearchTimeLimit;
        private Integer maximumSearchLookthroughLimit;
        private Integer maximumLDAPJoinSizeLimit;
        private Integer maximumSortSizeLimitWithoutVLVIndex;

        private AddNewPolicyRequestBuilder(String policyName) {
            this.policyName = policyName;
        }

        /**
         * Set description
         * @param description A description for this Client Connection Policy (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set schemas
         * @param schemas  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder schemas(List<EnumclientConnectionPolicySchemaUrn> schemas) {
            this.schemas = schemas;
            return this;
        }
        
        /**
         * Set policyID
         * @param policyID Specifies a name which uniquely identifies this Client Connection Policy in the server. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder policyID(String policyID) {
            this.policyID = policyID;
            return this;
        }
        
        /**
         * Set enabled
         * @param enabled Indicates whether this Client Connection Policy is enabled for use in the server. If a Client Connection Policy is disabled, then no new client connections will be associated with it. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder enabled(Boolean enabled) {
            this.enabled = enabled;
            return this;
        }
        
        /**
         * Set evaluationOrderIndex
         * @param evaluationOrderIndex Specifies the order in which Client Connection Policy definitions will be evaluated. A Client Connection Policy with a lower index will be evaluated before one with a higher index, and the first Client Connection Policy evaluated which may apply to a client connection will be used for that connection. Each Client Connection Policy must be assigned a unique evaluation order index value. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder evaluationOrderIndex(Integer evaluationOrderIndex) {
            this.evaluationOrderIndex = evaluationOrderIndex;
            return this;
        }
        
        /**
         * Set connectionCriteria
         * @param connectionCriteria Specifies a set of connection criteria that must match the associated client connection for it to be associated with this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder connectionCriteria(String connectionCriteria) {
            this.connectionCriteria = connectionCriteria;
            return this;
        }
        
        /**
         * Set terminateConnection
         * @param terminateConnection Indicates whether any client connection for which this Client Connection Policy is selected should be terminated. This makes it possible to define fine-grained criteria for clients that should not be allowed to connect to this Directory Server. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder terminateConnection(Boolean terminateConnection) {
            this.terminateConnection = terminateConnection;
            return this;
        }
        
        /**
         * Set sensitiveAttribute
         * @param sensitiveAttribute Provides the ability to indicate that some attributes should be considered sensitive and additional protection should be in place when interacting with those attributes. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder sensitiveAttribute(List<String> sensitiveAttribute) {
            this.sensitiveAttribute = sensitiveAttribute;
            return this;
        }
        
        /**
         * Set excludeGlobalSensitiveAttribute
         * @param excludeGlobalSensitiveAttribute Specifies the set of global sensitive attribute definitions that should not apply to this client connection policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder excludeGlobalSensitiveAttribute(List<String> excludeGlobalSensitiveAttribute) {
            this.excludeGlobalSensitiveAttribute = excludeGlobalSensitiveAttribute;
            return this;
        }
        
        /**
         * Set resultCodeMap
         * @param resultCodeMap Specifies the result code map that should be used for clients associated with this Client Connection Policy. If a value is defined for this property, then it will override any result code map referenced in the global configuration. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder resultCodeMap(String resultCodeMap) {
            this.resultCodeMap = resultCodeMap;
            return this;
        }
        
        /**
         * Set includedBackendBaseDN
         * @param includedBackendBaseDN Specifies the set of backend base DNs for which subtree views should be included in this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder includedBackendBaseDN(List<String> includedBackendBaseDN) {
            this.includedBackendBaseDN = includedBackendBaseDN;
            return this;
        }
        
        /**
         * Set excludedBackendBaseDN
         * @param excludedBackendBaseDN Specifies the set of backend base DNs for which subtree views should be excluded from this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder excludedBackendBaseDN(List<String> excludedBackendBaseDN) {
            this.excludedBackendBaseDN = excludedBackendBaseDN;
            return this;
        }
        
        /**
         * Set allowedOperation
         * @param allowedOperation  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowedOperation(List<EnumclientConnectionPolicyAllowedOperationProp> allowedOperation) {
            this.allowedOperation = allowedOperation;
            return this;
        }
        
        /**
         * Set requiredOperationRequestCriteria
         * @param requiredOperationRequestCriteria Specifies a request criteria object that will be required to match all requests submitted by clients associated with this Client Connection Policy. If a client submits a request that does not satisfy this request criteria object, then that request will be rejected. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder requiredOperationRequestCriteria(String requiredOperationRequestCriteria) {
            this.requiredOperationRequestCriteria = requiredOperationRequestCriteria;
            return this;
        }
        
        /**
         * Set prohibitedOperationRequestCriteria
         * @param prohibitedOperationRequestCriteria Specifies a request criteria object that must not match any requests submitted by clients associated with this Client Connection Policy. If a client submits a request that satisfies this request criteria object, then that request will be rejected. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder prohibitedOperationRequestCriteria(String prohibitedOperationRequestCriteria) {
            this.prohibitedOperationRequestCriteria = prohibitedOperationRequestCriteria;
            return this;
        }
        
        /**
         * Set allowedRequestControl
         * @param allowedRequestControl Specifies the OIDs of the controls that clients associated with this Client Connection Policy will be allowed to include in requests. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowedRequestControl(List<String> allowedRequestControl) {
            this.allowedRequestControl = allowedRequestControl;
            return this;
        }
        
        /**
         * Set deniedRequestControl
         * @param deniedRequestControl Specifies the OIDs of the controls that clients associated with this Client Connection Policy will not be allowed to include in requests. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder deniedRequestControl(List<String> deniedRequestControl) {
            this.deniedRequestControl = deniedRequestControl;
            return this;
        }
        
        /**
         * Set allowedExtendedOperation
         * @param allowedExtendedOperation Specifies the OIDs of the extended operations that clients associated with this Client Connection Policy will be allowed to request. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowedExtendedOperation(List<String> allowedExtendedOperation) {
            this.allowedExtendedOperation = allowedExtendedOperation;
            return this;
        }
        
        /**
         * Set deniedExtendedOperation
         * @param deniedExtendedOperation Specifies the OIDs of the extended operations that clients associated with this Client Connection Policy will not be allowed to request. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder deniedExtendedOperation(List<String> deniedExtendedOperation) {
            this.deniedExtendedOperation = deniedExtendedOperation;
            return this;
        }
        
        /**
         * Set allowedAuthType
         * @param allowedAuthType  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowedAuthType(List<EnumclientConnectionPolicyAllowedAuthTypeProp> allowedAuthType) {
            this.allowedAuthType = allowedAuthType;
            return this;
        }
        
        /**
         * Set allowedSASLMechanism
         * @param allowedSASLMechanism Specifies the names of the SASL mechanisms that clients associated with this Client Connection Policy will be allowed to request. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowedSASLMechanism(List<String> allowedSASLMechanism) {
            this.allowedSASLMechanism = allowedSASLMechanism;
            return this;
        }
        
        /**
         * Set deniedSASLMechanism
         * @param deniedSASLMechanism Specifies the names of the SASL mechanisms that clients associated with this Client Connection Policy will not be allowed to request. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder deniedSASLMechanism(List<String> deniedSASLMechanism) {
            this.deniedSASLMechanism = deniedSASLMechanism;
            return this;
        }
        
        /**
         * Set allowedFilterType
         * @param allowedFilterType  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowedFilterType(List<EnumclientConnectionPolicyAllowedFilterTypeProp> allowedFilterType) {
            this.allowedFilterType = allowedFilterType;
            return this;
        }
        
        /**
         * Set allowUnindexedSearches
         * @param allowUnindexedSearches Indicates whether clients will be allowed to request search operations that cannot be efficiently processed using the set of indexes defined in the corresponding backend. Note that even if this is false, some clients may be able to request unindexed searches if the allow-unindexed-searches-with-control property has a value of true and the necessary conditions are satisfied. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowUnindexedSearches(Boolean allowUnindexedSearches) {
            this.allowUnindexedSearches = allowUnindexedSearches;
            return this;
        }
        
        /**
         * Set allowUnindexedSearchesWithControl
         * @param allowUnindexedSearchesWithControl Indicates whether clients will be allowed to request search operations that cannot be efficiently processed using the set of indexes defined in the corresponding backend, as long as the search request also includes the permit unindexed search request control and the requester has the unindexed-search-with-control privilege (or that privilege is disabled in the global configuration). (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder allowUnindexedSearchesWithControl(Boolean allowUnindexedSearchesWithControl) {
            this.allowUnindexedSearchesWithControl = allowUnindexedSearchesWithControl;
            return this;
        }
        
        /**
         * Set minimumSubstringLength
         * @param minimumSubstringLength Specifies the minimum number of consecutive bytes that must be present in any subInitial, subAny, or subFinal element of a substring filter component (i.e., the minimum number of consecutive bytes between wildcard characters in a substring filter). Any attempt to use a substring search with an element containing fewer than this number of bytes will be rejected. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder minimumSubstringLength(Integer minimumSubstringLength) {
            this.minimumSubstringLength = minimumSubstringLength;
            return this;
        }
        
        /**
         * Set maximumConcurrentConnections
         * @param maximumConcurrentConnections Specifies the maximum number of client connections which may be associated with this Client Connection Policy at any given time. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumConcurrentConnections(Integer maximumConcurrentConnections) {
            this.maximumConcurrentConnections = maximumConcurrentConnections;
            return this;
        }
        
        /**
         * Set maximumConnectionDuration
         * @param maximumConnectionDuration Specifies the maximum length of time that a connection associated with this Client Connection Policy may be established. Any connection which is associated with this Client Connection Policy and has been established for longer than this period of time may be terminated. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumConnectionDuration(String maximumConnectionDuration) {
            this.maximumConnectionDuration = maximumConnectionDuration;
            return this;
        }
        
        /**
         * Set maximumIdleConnectionDuration
         * @param maximumIdleConnectionDuration Specifies the maximum length of time that a connection associated with this Client Connection Policy may remain established after the completion of the last operation processed on that connection. Any new operation requested on the connection will reset this timer. Any connection associated with this Client Connection Policy which has been idle for longer than this length of time may be terminated. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumIdleConnectionDuration(String maximumIdleConnectionDuration) {
            this.maximumIdleConnectionDuration = maximumIdleConnectionDuration;
            return this;
        }
        
        /**
         * Set maximumOperationCountPerConnection
         * @param maximumOperationCountPerConnection Specifies the maximum number of operations that may be requested by any client connection associated with this Client Connection Policy. If an attempt is made to process more than this number of operations on a client connection, then that connection will be terminated. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumOperationCountPerConnection(Integer maximumOperationCountPerConnection) {
            this.maximumOperationCountPerConnection = maximumOperationCountPerConnection;
            return this;
        }
        
        /**
         * Set maximumConcurrentOperationsPerConnection
         * @param maximumConcurrentOperationsPerConnection Specifies the maximum number of concurrent operations that can be in progress for any connection. This can help prevent a single client connection from monopolizing server processing resources by sending a large number of concurrent asynchronous requests. A value of zero indicates that no limit will be placed on the number of concurrent requests for a single client. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumConcurrentOperationsPerConnection(Integer maximumConcurrentOperationsPerConnection) {
            this.maximumConcurrentOperationsPerConnection = maximumConcurrentOperationsPerConnection;
            return this;
        }
        
        /**
         * Set maximumConcurrentOperationWaitTimeBeforeRejecting
         * @param maximumConcurrentOperationWaitTimeBeforeRejecting Specifies the maximum length of time that the server should wait for an outstanding operation to complete before rejecting a new request received when the maximum number of outstanding operations are already in progress on that connection. If an existing outstanding operation on the connection completes before this time, then the operation will be processed. Otherwise, the operation will be rejected with a \\\&quot;busy\\\&quot; result. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumConcurrentOperationWaitTimeBeforeRejecting(String maximumConcurrentOperationWaitTimeBeforeRejecting) {
            this.maximumConcurrentOperationWaitTimeBeforeRejecting = maximumConcurrentOperationWaitTimeBeforeRejecting;
            return this;
        }
        
        /**
         * Set maximumConcurrentOperationsPerConnectionExceededBehavior
         * @param maximumConcurrentOperationsPerConnectionExceededBehavior  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumConcurrentOperationsPerConnectionExceededBehavior(EnumclientConnectionPolicyMaximumConcurrentOperationsPerConnectionExceededBehaviorProp maximumConcurrentOperationsPerConnectionExceededBehavior) {
            this.maximumConcurrentOperationsPerConnectionExceededBehavior = maximumConcurrentOperationsPerConnectionExceededBehavior;
            return this;
        }
        
        /**
         * Set maximumConnectionOperationRate
         * @param maximumConnectionOperationRate Specifies the maximum rate at which a client associated with this Client Connection Policy may issue requests to the Directory Server. If any client attempts to request operations at a rate higher than this limit, then the server will exhibit the behavior described in the connection-operation-rate-exceeded-behavior property. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumConnectionOperationRate(List<String> maximumConnectionOperationRate) {
            this.maximumConnectionOperationRate = maximumConnectionOperationRate;
            return this;
        }
        
        /**
         * Set connectionOperationRateExceededBehavior
         * @param connectionOperationRateExceededBehavior  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder connectionOperationRateExceededBehavior(EnumclientConnectionPolicyConnectionOperationRateExceededBehaviorProp connectionOperationRateExceededBehavior) {
            this.connectionOperationRateExceededBehavior = connectionOperationRateExceededBehavior;
            return this;
        }
        
        /**
         * Set maximumPolicyOperationRate
         * @param maximumPolicyOperationRate Specifies the maximum rate at which all clients associated with this Client Connection Policy, as a collective set, may issue requests to the Directory Server. If this limit is exceeded, then the server will exhibit the behavior described in the policy-operation-rate-exceeded-behavior property. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumPolicyOperationRate(List<String> maximumPolicyOperationRate) {
            this.maximumPolicyOperationRate = maximumPolicyOperationRate;
            return this;
        }
        
        /**
         * Set policyOperationRateExceededBehavior
         * @param policyOperationRateExceededBehavior  (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder policyOperationRateExceededBehavior(EnumclientConnectionPolicyPolicyOperationRateExceededBehaviorProp policyOperationRateExceededBehavior) {
            this.policyOperationRateExceededBehavior = policyOperationRateExceededBehavior;
            return this;
        }
        
        /**
         * Set maximumSearchSizeLimit
         * @param maximumSearchSizeLimit Specifies the maximum number of entries that may be returned for a search performed by a client associated with this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumSearchSizeLimit(Integer maximumSearchSizeLimit) {
            this.maximumSearchSizeLimit = maximumSearchSizeLimit;
            return this;
        }
        
        /**
         * Set maximumSearchTimeLimit
         * @param maximumSearchTimeLimit Specifies the maximum length of time that the server should spend processing search operations requested by clients associated with this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumSearchTimeLimit(String maximumSearchTimeLimit) {
            this.maximumSearchTimeLimit = maximumSearchTimeLimit;
            return this;
        }
        
        /**
         * Set maximumSearchLookthroughLimit
         * @param maximumSearchLookthroughLimit Specifies the maximum number of entries that may be examined by a backend in the course of processing a search requested by clients associated with this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumSearchLookthroughLimit(Integer maximumSearchLookthroughLimit) {
            this.maximumSearchLookthroughLimit = maximumSearchLookthroughLimit;
            return this;
        }
        
        /**
         * Set maximumLDAPJoinSizeLimit
         * @param maximumLDAPJoinSizeLimit Specifies the maximum number of entries that may be joined with any single search result entry for a search request performed by a client associated with this Client Connection Policy. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumLDAPJoinSizeLimit(Integer maximumLDAPJoinSizeLimit) {
            this.maximumLDAPJoinSizeLimit = maximumLDAPJoinSizeLimit;
            return this;
        }
        
        /**
         * Set maximumSortSizeLimitWithoutVLVIndex
         * @param maximumSortSizeLimitWithoutVLVIndex Specifies the maximum number of entries that the server will attempt to sort without the benefit of a VLV index. A value of zero indicates that no limit should be enforced. (optional)
         * @return AddNewPolicyRequestBuilder
         */
        public AddNewPolicyRequestBuilder maximumSortSizeLimitWithoutVLVIndex(Integer maximumSortSizeLimitWithoutVLVIndex) {
            this.maximumSortSizeLimitWithoutVLVIndex = maximumSortSizeLimitWithoutVLVIndex;
            return this;
        }
        
        /**
         * Build call for addNewPolicy
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AddClientConnectionPolicyRequest addClientConnectionPolicyRequest = buildBodyParams();
            return addNewPolicyCall(addClientConnectionPolicyRequest, _callback);
        }

        private AddClientConnectionPolicyRequest buildBodyParams() {
            AddClientConnectionPolicyRequest addClientConnectionPolicyRequest = new AddClientConnectionPolicyRequest();
            return addClientConnectionPolicyRequest;
        }

        /**
         * Execute addNewPolicy request
         * @return ClientConnectionPolicyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public ClientConnectionPolicyResponse execute() throws ApiException {
            AddClientConnectionPolicyRequest addClientConnectionPolicyRequest = buildBodyParams();
            ApiResponse<ClientConnectionPolicyResponse> localVarResp = addNewPolicyWithHttpInfo(addClientConnectionPolicyRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute addNewPolicy request with HTTP info returned
         * @return ApiResponse&lt;ClientConnectionPolicyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ClientConnectionPolicyResponse> executeWithHttpInfo() throws ApiException {
            AddClientConnectionPolicyRequest addClientConnectionPolicyRequest = buildBodyParams();
            return addNewPolicyWithHttpInfo(addClientConnectionPolicyRequest);
        }

        /**
         * Execute addNewPolicy request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy already exists </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ClientConnectionPolicyResponse> _callback) throws ApiException {
            AddClientConnectionPolicyRequest addClientConnectionPolicyRequest = buildBodyParams();
            return addNewPolicyAsync(addClientConnectionPolicyRequest, _callback);
        }
    }

    /**
     * Add a new Client Connection Policy to the config
     * 
     * @param addClientConnectionPolicyRequest Create a new Client Connection Policy in the config (required)
     * @return AddNewPolicyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The Client Connection Policy already exists </td><td>  -  </td></tr>
     </table>
     */
    public AddNewPolicyRequestBuilder addNewPolicy(String policyName) throws IllegalArgumentException {
        if (policyName == null) throw new IllegalArgumentException("\"policyName\" is required but got null");
            

        return new AddNewPolicyRequestBuilder(policyName);
    }
    private okhttp3.Call deleteByIdCall(String clientConnectionPolicyName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/client-connection-policies/{client-connection-policy-name}"
            .replace("{" + "client-connection-policy-name" + "}", localVarApiClient.escapeString(clientConnectionPolicyName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteByIdValidateBeforeCall(String clientConnectionPolicyName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clientConnectionPolicyName' is set
        if (clientConnectionPolicyName == null) {
            throw new ApiException("Missing the required parameter 'clientConnectionPolicyName' when calling deleteById(Async)");
        }

        return deleteByIdCall(clientConnectionPolicyName, _callback);

    }


    private ApiResponse<Void> deleteByIdWithHttpInfo(String clientConnectionPolicyName) throws ApiException {
        okhttp3.Call localVarCall = deleteByIdValidateBeforeCall(clientConnectionPolicyName, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteByIdAsync(String clientConnectionPolicyName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteByIdValidateBeforeCall(clientConnectionPolicyName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteByIdRequestBuilder {
        private final String clientConnectionPolicyName;

        private DeleteByIdRequestBuilder(String clientConnectionPolicyName) {
            this.clientConnectionPolicyName = clientConnectionPolicyName;
        }

        /**
         * Build call for deleteById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteByIdCall(clientConnectionPolicyName, _callback);
        }


        /**
         * Execute deleteById request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteByIdWithHttpInfo(clientConnectionPolicyName);
        }

        /**
         * Execute deleteById request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteByIdWithHttpInfo(clientConnectionPolicyName);
        }

        /**
         * Execute deleteById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Client Connection Policy cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteByIdAsync(clientConnectionPolicyName, _callback);
        }
    }

    /**
     * Delete a Client Connection Policy
     * 
     * @param clientConnectionPolicyName Name of the Client Connection Policy (required)
     * @return DeleteByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The Client Connection Policy cannot be deleted </td><td>  -  </td></tr>
     </table>
     */
    public DeleteByIdRequestBuilder deleteById(String clientConnectionPolicyName) throws IllegalArgumentException {
        if (clientConnectionPolicyName == null) throw new IllegalArgumentException("\"clientConnectionPolicyName\" is required but got null");
            

        return new DeleteByIdRequestBuilder(clientConnectionPolicyName);
    }
    private okhttp3.Call getAllObjectsCall(String filter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/client-connection-policies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllObjectsValidateBeforeCall(String filter, final ApiCallback _callback) throws ApiException {
        return getAllObjectsCall(filter, _callback);

    }


    private ApiResponse<ClientConnectionPolicyListResponse> getAllObjectsWithHttpInfo(String filter) throws ApiException {
        okhttp3.Call localVarCall = getAllObjectsValidateBeforeCall(filter, null);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAllObjectsAsync(String filter, final ApiCallback<ClientConnectionPolicyListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllObjectsValidateBeforeCall(filter, _callback);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAllObjectsRequestBuilder {
        private String filter;

        private GetAllObjectsRequestBuilder() {
        }

        /**
         * Set filter
         * @param filter SCIM filter (optional)
         * @return GetAllObjectsRequestBuilder
         */
        public GetAllObjectsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Build call for getAllObjects
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAllObjectsCall(filter, _callback);
        }


        /**
         * Execute getAllObjects request
         * @return ClientConnectionPolicyListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public ClientConnectionPolicyListResponse execute() throws ApiException {
            ApiResponse<ClientConnectionPolicyListResponse> localVarResp = getAllObjectsWithHttpInfo(filter);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAllObjects request with HTTP info returned
         * @return ApiResponse&lt;ClientConnectionPolicyListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ClientConnectionPolicyListResponse> executeWithHttpInfo() throws ApiException {
            return getAllObjectsWithHttpInfo(filter);
        }

        /**
         * Execute getAllObjects request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ClientConnectionPolicyListResponse> _callback) throws ApiException {
            return getAllObjectsAsync(filter, _callback);
        }
    }

    /**
     * Returns a list of all Client Connection Policy objects
     * 
     * @return GetAllObjectsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
     </table>
     */
    public GetAllObjectsRequestBuilder getAllObjects() throws IllegalArgumentException {
        return new GetAllObjectsRequestBuilder();
    }
    private okhttp3.Call getSingleCall(String clientConnectionPolicyName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/client-connection-policies/{client-connection-policy-name}"
            .replace("{" + "client-connection-policy-name" + "}", localVarApiClient.escapeString(clientConnectionPolicyName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSingleValidateBeforeCall(String clientConnectionPolicyName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clientConnectionPolicyName' is set
        if (clientConnectionPolicyName == null) {
            throw new ApiException("Missing the required parameter 'clientConnectionPolicyName' when calling getSingle(Async)");
        }

        return getSingleCall(clientConnectionPolicyName, _callback);

    }


    private ApiResponse<ClientConnectionPolicyResponse> getSingleWithHttpInfo(String clientConnectionPolicyName) throws ApiException {
        okhttp3.Call localVarCall = getSingleValidateBeforeCall(clientConnectionPolicyName, null);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSingleAsync(String clientConnectionPolicyName, final ApiCallback<ClientConnectionPolicyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSingleValidateBeforeCall(clientConnectionPolicyName, _callback);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSingleRequestBuilder {
        private final String clientConnectionPolicyName;

        private GetSingleRequestBuilder(String clientConnectionPolicyName) {
            this.clientConnectionPolicyName = clientConnectionPolicyName;
        }

        /**
         * Build call for getSingle
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSingleCall(clientConnectionPolicyName, _callback);
        }


        /**
         * Execute getSingle request
         * @return ClientConnectionPolicyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ClientConnectionPolicyResponse execute() throws ApiException {
            ApiResponse<ClientConnectionPolicyResponse> localVarResp = getSingleWithHttpInfo(clientConnectionPolicyName);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSingle request with HTTP info returned
         * @return ApiResponse&lt;ClientConnectionPolicyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ClientConnectionPolicyResponse> executeWithHttpInfo() throws ApiException {
            return getSingleWithHttpInfo(clientConnectionPolicyName);
        }

        /**
         * Execute getSingle request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ClientConnectionPolicyResponse> _callback) throws ApiException {
            return getSingleAsync(clientConnectionPolicyName, _callback);
        }
    }

    /**
     * Returns a single Client Connection Policy
     * 
     * @param clientConnectionPolicyName Name of the Client Connection Policy (required)
     * @return GetSingleRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
     </table>
     */
    public GetSingleRequestBuilder getSingle(String clientConnectionPolicyName) throws IllegalArgumentException {
        if (clientConnectionPolicyName == null) throw new IllegalArgumentException("\"clientConnectionPolicyName\" is required but got null");
            

        return new GetSingleRequestBuilder(clientConnectionPolicyName);
    }
    private okhttp3.Call updateByNameCall(String clientConnectionPolicyName, UpdateRequest updateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateRequest;

        // create path and map variables
        String localVarPath = "/client-connection-policies/{client-connection-policy-name}"
            .replace("{" + "client-connection-policy-name" + "}", localVarApiClient.escapeString(clientConnectionPolicyName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateByNameValidateBeforeCall(String clientConnectionPolicyName, UpdateRequest updateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clientConnectionPolicyName' is set
        if (clientConnectionPolicyName == null) {
            throw new ApiException("Missing the required parameter 'clientConnectionPolicyName' when calling updateByName(Async)");
        }

        // verify the required parameter 'updateRequest' is set
        if (updateRequest == null) {
            throw new ApiException("Missing the required parameter 'updateRequest' when calling updateByName(Async)");
        }

        return updateByNameCall(clientConnectionPolicyName, updateRequest, _callback);

    }


    private ApiResponse<ClientConnectionPolicyResponse> updateByNameWithHttpInfo(String clientConnectionPolicyName, UpdateRequest updateRequest) throws ApiException {
        okhttp3.Call localVarCall = updateByNameValidateBeforeCall(clientConnectionPolicyName, updateRequest, null);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateByNameAsync(String clientConnectionPolicyName, UpdateRequest updateRequest, final ApiCallback<ClientConnectionPolicyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateByNameValidateBeforeCall(clientConnectionPolicyName, updateRequest, _callback);
        Type localVarReturnType = new TypeToken<ClientConnectionPolicyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateByNameRequestBuilder {
        private final List<Operation> operations;
        private final String clientConnectionPolicyName;

        private UpdateByNameRequestBuilder(List<Operation> operations, String clientConnectionPolicyName) {
            this.operations = operations;
            this.clientConnectionPolicyName = clientConnectionPolicyName;
        }

        /**
         * Build call for updateByName
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameCall(clientConnectionPolicyName, updateRequest, _callback);
        }

        private UpdateRequest buildBodyParams() {
            UpdateRequest updateRequest = new UpdateRequest();
            updateRequest.operations(this.operations);
            return updateRequest;
        }

        /**
         * Execute updateByName request
         * @return ClientConnectionPolicyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ClientConnectionPolicyResponse execute() throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            ApiResponse<ClientConnectionPolicyResponse> localVarResp = updateByNameWithHttpInfo(clientConnectionPolicyName, updateRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateByName request with HTTP info returned
         * @return ApiResponse&lt;ClientConnectionPolicyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ClientConnectionPolicyResponse> executeWithHttpInfo() throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameWithHttpInfo(clientConnectionPolicyName, updateRequest);
        }

        /**
         * Execute updateByName request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ClientConnectionPolicyResponse> _callback) throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameAsync(clientConnectionPolicyName, updateRequest, _callback);
        }
    }

    /**
     * Update an existing Client Connection Policy by name
     * 
     * @param clientConnectionPolicyName Name of the Client Connection Policy (required)
     * @param updateRequest Update an existing Client Connection Policy (required)
     * @return UpdateByNameRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Client Connection Policy does not exist </td><td>  -  </td></tr>
     </table>
     */
    public UpdateByNameRequestBuilder updateByName(List<Operation> operations, String clientConnectionPolicyName) throws IllegalArgumentException {
        if (operations == null) throw new IllegalArgumentException("\"operations\" is required but got null");
        if (clientConnectionPolicyName == null) throw new IllegalArgumentException("\"clientConnectionPolicyName\" is required but got null");
            

        return new UpdateByNameRequestBuilder(operations, clientConnectionPolicyName);
    }
}
