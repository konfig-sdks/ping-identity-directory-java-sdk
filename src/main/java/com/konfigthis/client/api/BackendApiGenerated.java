/*
 * PingData Config - OpenAPI 3.0
 * This is the PingData Configuration API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AddLocalDbBackendRequest;
import com.konfigthis.client.model.BackendListResponse;
import com.konfigthis.client.model.EnumbackendDefaultCacheModeProp;
import com.konfigthis.client.model.EnumbackendDn2idCacheModeProp;
import com.konfigthis.client.model.EnumbackendDn2uriCacheModeProp;
import com.konfigthis.client.model.EnumbackendExternalTxnDefaultBackendLockBehaviorProp;
import com.konfigthis.client.model.EnumbackendId2childrenCacheModeProp;
import com.konfigthis.client.model.EnumbackendId2entryCacheModeProp;
import com.konfigthis.client.model.EnumbackendId2subtreeCacheModeProp;
import com.konfigthis.client.model.EnumbackendPrimeMethodProp;
import com.konfigthis.client.model.EnumbackendSingleWriterLockBehaviorProp;
import com.konfigthis.client.model.EnumbackendSystemIndexToPrimeInternalNodesOnlyProp;
import com.konfigthis.client.model.EnumbackendSystemIndexToPrimeProp;
import com.konfigthis.client.model.EnumbackendUncachedId2entryCacheModeProp;
import com.konfigthis.client.model.EnumbackendWritabilityModeProp;
import com.konfigthis.client.model.EnumlocalDbBackendSchemaUrn;
import com.konfigthis.client.model.Operation;
import com.konfigthis.client.model.UpdateRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class BackendApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public BackendApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public BackendApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createConfigCall(AddLocalDbBackendRequest addLocalDbBackendRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = addLocalDbBackendRequest;

        // create path and map variables
        String localVarPath = "/backends";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createConfigValidateBeforeCall(AddLocalDbBackendRequest addLocalDbBackendRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'addLocalDbBackendRequest' is set
        if (addLocalDbBackendRequest == null) {
            throw new ApiException("Missing the required parameter 'addLocalDbBackendRequest' when calling createConfig(Async)");
        }

        return createConfigCall(addLocalDbBackendRequest, _callback);

    }


    private ApiResponse<Object> createConfigWithHttpInfo(AddLocalDbBackendRequest addLocalDbBackendRequest) throws ApiException {
        okhttp3.Call localVarCall = createConfigValidateBeforeCall(addLocalDbBackendRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createConfigAsync(AddLocalDbBackendRequest addLocalDbBackendRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = createConfigValidateBeforeCall(addLocalDbBackendRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateConfigRequestBuilder {
        private final String backendName;
        private String description;
        private List<EnumlocalDbBackendSchemaUrn> schemas;
        private EnumbackendUncachedId2entryCacheModeProp uncachedId2entryCacheMode;
        private String uncachedAttributeCriteria;
        private String uncachedEntryCriteria;
        private EnumbackendWritabilityModeProp writabilityMode;
        private Boolean setDegradedAlertForUntrustedIndex;
        private Boolean returnUnavailableForUntrustedIndex;
        private Boolean processFiltersWithUndefinedAttributeTypes;
        private Boolean isPrivateBackend;
        private String dbDirectory;
        private String dbDirectoryPermissions;
        private List<String> compactCommonParentDN;
        private Boolean compressEntries;
        private Boolean hashEntries;
        private Integer dbNumCleanerThreads;
        private Integer dbCleanerMinUtilization;
        private Integer dbEvictorCriticalPercentage;
        private String dbCheckpointerWakeupInterval;
        private String dbBackgroundSyncInterval;
        private Boolean dbUseThreadLocalHandles;
        private String dbLogFileMax;
        private String dbLoggingLevel;
        private List<String> jeProperty;
        private Integer dbCachePercent;
        private EnumbackendDefaultCacheModeProp defaultCacheMode;
        private EnumbackendId2entryCacheModeProp id2entryCacheMode;
        private EnumbackendDn2idCacheModeProp dn2idCacheMode;
        private EnumbackendId2childrenCacheModeProp id2childrenCacheMode;
        private EnumbackendId2subtreeCacheModeProp id2subtreeCacheMode;
        private EnumbackendDn2uriCacheModeProp dn2uriCacheMode;
        private List<EnumbackendPrimeMethodProp> primeMethod;
        private Integer primeThreadCount;
        private String primeTimeLimit;
        private Boolean primeAllIndexes;
        private List<EnumbackendSystemIndexToPrimeProp> systemIndexToPrime;
        private List<EnumbackendSystemIndexToPrimeInternalNodesOnlyProp> systemIndexToPrimeInternalNodesOnly;
        private Boolean backgroundPrime;
        private Integer indexEntryLimit;
        private Integer compositeIndexEntryLimit;
        private Integer id2childrenIndexEntryLimit;
        private Integer id2subtreeIndexEntryLimit;
        private String importTempDirectory;
        private Integer importThreadCount;
        private Integer exportThreadCount;
        private Integer dbImportCachePercent;
        private Boolean dbTxnWriteNoSync;
        private Integer deadlockRetryLimit;
        private EnumbackendExternalTxnDefaultBackendLockBehaviorProp externalTxnDefaultBackendLockBehavior;
        private EnumbackendSingleWriterLockBehaviorProp singleWriterLockBehavior;
        private Integer subtreeDeleteSizeLimit;
        private Integer numRecentChanges;
        private String offlineProcessDatabaseOpenTimeout;
        private String backendID;
        private Boolean enabled;
        private List<String> baseDN;
        private Boolean setDegradedAlertWhenDisabled;
        private Boolean returnUnavailableWhenDisabled;
        private String notificationManager;

        private CreateConfigRequestBuilder(String backendName) {
            this.backendName = backendName;
        }

        /**
         * Set description
         * @param description A description for this Backend (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set schemas
         * @param schemas  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder schemas(List<EnumlocalDbBackendSchemaUrn> schemas) {
            this.schemas = schemas;
            return this;
        }
        
        /**
         * Set uncachedId2entryCacheMode
         * @param uncachedId2entryCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder uncachedId2entryCacheMode(EnumbackendUncachedId2entryCacheModeProp uncachedId2entryCacheMode) {
            this.uncachedId2entryCacheMode = uncachedId2entryCacheMode;
            return this;
        }
        
        /**
         * Set uncachedAttributeCriteria
         * @param uncachedAttributeCriteria The criteria that will be used to identify attributes that should be written into the uncached-id2entry database rather than the id2entry database. This will only be used for entries in which the associated uncached-entry-criteria does not indicate that the entire entry should be uncached. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder uncachedAttributeCriteria(String uncachedAttributeCriteria) {
            this.uncachedAttributeCriteria = uncachedAttributeCriteria;
            return this;
        }
        
        /**
         * Set uncachedEntryCriteria
         * @param uncachedEntryCriteria The criteria that will be used to identify entries that should be written into the uncached-id2entry database rather than the id2entry database. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder uncachedEntryCriteria(String uncachedEntryCriteria) {
            this.uncachedEntryCriteria = uncachedEntryCriteria;
            return this;
        }
        
        /**
         * Set writabilityMode
         * @param writabilityMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder writabilityMode(EnumbackendWritabilityModeProp writabilityMode) {
            this.writabilityMode = writabilityMode;
            return this;
        }
        
        /**
         * Set setDegradedAlertForUntrustedIndex
         * @param setDegradedAlertForUntrustedIndex Determines whether the Directory Server enters a DEGRADED state when this Local DB Backend has an index whose contents cannot be trusted. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder setDegradedAlertForUntrustedIndex(Boolean setDegradedAlertForUntrustedIndex) {
            this.setDegradedAlertForUntrustedIndex = setDegradedAlertForUntrustedIndex;
            return this;
        }
        
        /**
         * Set returnUnavailableForUntrustedIndex
         * @param returnUnavailableForUntrustedIndex Determines whether the Directory Server returns UNAVAILABLE for any LDAP search operation in this Local DB Backend that would use an index whose contents cannot be trusted. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder returnUnavailableForUntrustedIndex(Boolean returnUnavailableForUntrustedIndex) {
            this.returnUnavailableForUntrustedIndex = returnUnavailableForUntrustedIndex;
            return this;
        }
        
        /**
         * Set processFiltersWithUndefinedAttributeTypes
         * @param processFiltersWithUndefinedAttributeTypes Determines whether the Directory Server should continue filter processing for LDAP search operations in this Local DB Backend that includes a search filter with an attribute that is not defined in the schema. This will only apply if check-schema is enabled in the global configuration. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder processFiltersWithUndefinedAttributeTypes(Boolean processFiltersWithUndefinedAttributeTypes) {
            this.processFiltersWithUndefinedAttributeTypes = processFiltersWithUndefinedAttributeTypes;
            return this;
        }
        
        /**
         * Set isPrivateBackend
         * @param isPrivateBackend Indicates whether this backend should be considered a private backend in the server. Private backends are meant for storing server-internal information and should not be used for user or application data. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder isPrivateBackend(Boolean isPrivateBackend) {
            this.isPrivateBackend = isPrivateBackend;
            return this;
        }
        
        /**
         * Set dbDirectory
         * @param dbDirectory Specifies the path to the filesystem directory that is used to hold the Berkeley DB Java Edition database files containing the data for this backend. The files for this backend are stored in a sub-directory named after the backend-id. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbDirectory(String dbDirectory) {
            this.dbDirectory = dbDirectory;
            return this;
        }
        
        /**
         * Set dbDirectoryPermissions
         * @param dbDirectoryPermissions Specifies the permissions that should be applied to the directory containing the backend database files and to directories and files created during backup or LDIF export of the backend. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbDirectoryPermissions(String dbDirectoryPermissions) {
            this.dbDirectoryPermissions = dbDirectoryPermissions;
            return this;
        }
        
        /**
         * Set compactCommonParentDN
         * @param compactCommonParentDN Provides a DN of an entry that may be the parent for a large number of entries in the backend. This may be used to help increase the space efficiency when encoding entries for storage. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder compactCommonParentDN(List<String> compactCommonParentDN) {
            this.compactCommonParentDN = compactCommonParentDN;
            return this;
        }
        
        /**
         * Set compressEntries
         * @param compressEntries Indicates whether the backend should attempt to compress entries before storing them in the database. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder compressEntries(Boolean compressEntries) {
            this.compressEntries = compressEntries;
            return this;
        }
        
        /**
         * Set hashEntries
         * @param hashEntries Indicates whether to calculate and store a message digest of the entry contents along with the entry data, in order to provide a means of verifying the integrity of the entry data. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder hashEntries(Boolean hashEntries) {
            this.hashEntries = hashEntries;
            return this;
        }
        
        /**
         * Set dbNumCleanerThreads
         * @param dbNumCleanerThreads Specifies the number of threads that the backend should maintain to keep the database log files at or near the desired utilization. A value of zero indicates that the number of cleaner threads should be automatically configured based on the number of available CPUs. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbNumCleanerThreads(Integer dbNumCleanerThreads) {
            this.dbNumCleanerThreads = dbNumCleanerThreads;
            return this;
        }
        
        /**
         * Set dbCleanerMinUtilization
         * @param dbCleanerMinUtilization Specifies the minimum percentage of \\\&quot;live\\\&quot; data that the database cleaner attempts to keep in database log files. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbCleanerMinUtilization(Integer dbCleanerMinUtilization) {
            this.dbCleanerMinUtilization = dbCleanerMinUtilization;
            return this;
        }
        
        /**
         * Set dbEvictorCriticalPercentage
         * @param dbEvictorCriticalPercentage Specifies the percentage over the configured maximum that the database cache is allowed to grow. It is recommended to set this value slightly above zero when the database is too large to fully cache in memory. In this case, a dedicated background evictor thread is used to perform evictions once the cache fills up reducing the possibility that server threads are blocked. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbEvictorCriticalPercentage(Integer dbEvictorCriticalPercentage) {
            this.dbEvictorCriticalPercentage = dbEvictorCriticalPercentage;
            return this;
        }
        
        /**
         * Set dbCheckpointerWakeupInterval
         * @param dbCheckpointerWakeupInterval Specifies the maximum length of time that should pass between checkpoints. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbCheckpointerWakeupInterval(String dbCheckpointerWakeupInterval) {
            this.dbCheckpointerWakeupInterval = dbCheckpointerWakeupInterval;
            return this;
        }
        
        /**
         * Set dbBackgroundSyncInterval
         * @param dbBackgroundSyncInterval Specifies the interval to use when performing background synchronous writes in the database environment in order to smooth overall write performance and increase data durability. A value of \\\&quot;0 s\\\&quot; will disable background synchronous writes. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbBackgroundSyncInterval(String dbBackgroundSyncInterval) {
            this.dbBackgroundSyncInterval = dbBackgroundSyncInterval;
            return this;
        }
        
        /**
         * Set dbUseThreadLocalHandles
         * @param dbUseThreadLocalHandles Indicates whether to use thread-local database handles to reduce contention in the backend. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbUseThreadLocalHandles(Boolean dbUseThreadLocalHandles) {
            this.dbUseThreadLocalHandles = dbUseThreadLocalHandles;
            return this;
        }
        
        /**
         * Set dbLogFileMax
         * @param dbLogFileMax Specifies the maximum size for a database log file. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbLogFileMax(String dbLogFileMax) {
            this.dbLogFileMax = dbLogFileMax;
            return this;
        }
        
        /**
         * Set dbLoggingLevel
         * @param dbLoggingLevel Specifies the log level that should be used by the database when it is writing information into the je.info file. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbLoggingLevel(String dbLoggingLevel) {
            this.dbLoggingLevel = dbLoggingLevel;
            return this;
        }
        
        /**
         * Set jeProperty
         * @param jeProperty Specifies the database and environment properties for the Berkeley DB Java Edition database serving the data for this backend. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder jeProperty(List<String> jeProperty) {
            this.jeProperty = jeProperty;
            return this;
        }
        
        /**
         * Set dbCachePercent
         * @param dbCachePercent Specifies the percentage of JVM memory to allocate to the database cache. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbCachePercent(Integer dbCachePercent) {
            this.dbCachePercent = dbCachePercent;
            return this;
        }
        
        /**
         * Set defaultCacheMode
         * @param defaultCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder defaultCacheMode(EnumbackendDefaultCacheModeProp defaultCacheMode) {
            this.defaultCacheMode = defaultCacheMode;
            return this;
        }
        
        /**
         * Set id2entryCacheMode
         * @param id2entryCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder id2entryCacheMode(EnumbackendId2entryCacheModeProp id2entryCacheMode) {
            this.id2entryCacheMode = id2entryCacheMode;
            return this;
        }
        
        /**
         * Set dn2idCacheMode
         * @param dn2idCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dn2idCacheMode(EnumbackendDn2idCacheModeProp dn2idCacheMode) {
            this.dn2idCacheMode = dn2idCacheMode;
            return this;
        }
        
        /**
         * Set id2childrenCacheMode
         * @param id2childrenCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder id2childrenCacheMode(EnumbackendId2childrenCacheModeProp id2childrenCacheMode) {
            this.id2childrenCacheMode = id2childrenCacheMode;
            return this;
        }
        
        /**
         * Set id2subtreeCacheMode
         * @param id2subtreeCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder id2subtreeCacheMode(EnumbackendId2subtreeCacheModeProp id2subtreeCacheMode) {
            this.id2subtreeCacheMode = id2subtreeCacheMode;
            return this;
        }
        
        /**
         * Set dn2uriCacheMode
         * @param dn2uriCacheMode  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dn2uriCacheMode(EnumbackendDn2uriCacheModeProp dn2uriCacheMode) {
            this.dn2uriCacheMode = dn2uriCacheMode;
            return this;
        }
        
        /**
         * Set primeMethod
         * @param primeMethod  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder primeMethod(List<EnumbackendPrimeMethodProp> primeMethod) {
            this.primeMethod = primeMethod;
            return this;
        }
        
        /**
         * Set primeThreadCount
         * @param primeThreadCount Specifies the number of threads to use when priming. At present, this applies only to the preload and cursor-across-indexes prime methods. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder primeThreadCount(Integer primeThreadCount) {
            this.primeThreadCount = primeThreadCount;
            return this;
        }
        
        /**
         * Set primeTimeLimit
         * @param primeTimeLimit Specifies the maximum length of time that the backend prime should be allowed to run. A duration of zero seconds indicates that there should not be a time limit. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder primeTimeLimit(String primeTimeLimit) {
            this.primeTimeLimit = primeTimeLimit;
            return this;
        }
        
        /**
         * Set primeAllIndexes
         * @param primeAllIndexes Indicates whether to prime all indexes associated with this backend, or to only prime the specified set of indexes (as configured with the system-index-to-prime property for the system indexes, and the prime-index property in the attribute index definition for attribute indexes). (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder primeAllIndexes(Boolean primeAllIndexes) {
            this.primeAllIndexes = primeAllIndexes;
            return this;
        }
        
        /**
         * Set systemIndexToPrime
         * @param systemIndexToPrime  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder systemIndexToPrime(List<EnumbackendSystemIndexToPrimeProp> systemIndexToPrime) {
            this.systemIndexToPrime = systemIndexToPrime;
            return this;
        }
        
        /**
         * Set systemIndexToPrimeInternalNodesOnly
         * @param systemIndexToPrimeInternalNodesOnly  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder systemIndexToPrimeInternalNodesOnly(List<EnumbackendSystemIndexToPrimeInternalNodesOnlyProp> systemIndexToPrimeInternalNodesOnly) {
            this.systemIndexToPrimeInternalNodesOnly = systemIndexToPrimeInternalNodesOnly;
            return this;
        }
        
        /**
         * Set backgroundPrime
         * @param backgroundPrime Indicates whether to attempt to perform the prime using a background thread if possible. If background priming is enabled, then the Directory Server may be allowed to accept client connections and process requests while the prime is in progress. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder backgroundPrime(Boolean backgroundPrime) {
            this.backgroundPrime = backgroundPrime;
            return this;
        }
        
        /**
         * Set indexEntryLimit
         * @param indexEntryLimit Specifies the maximum number of entries that are allowed to match a given index key before that particular index key is no longer maintained. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder indexEntryLimit(Integer indexEntryLimit) {
            this.indexEntryLimit = indexEntryLimit;
            return this;
        }
        
        /**
         * Set compositeIndexEntryLimit
         * @param compositeIndexEntryLimit Specifies the maximum number of entries that are allowed to match a given composite index key before that particular composite index key is no longer maintained. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder compositeIndexEntryLimit(Integer compositeIndexEntryLimit) {
            this.compositeIndexEntryLimit = compositeIndexEntryLimit;
            return this;
        }
        
        /**
         * Set id2childrenIndexEntryLimit
         * @param id2childrenIndexEntryLimit Specifies the maximum number of entry IDs to maintain for each entry in the id2children system index (which keeps track of the immediate children for an entry, to assist in otherwise unindexed searches with a single-level scope). A value of 0 means there is no limit, however this could have a big impact on database size on disk and on server performance. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder id2childrenIndexEntryLimit(Integer id2childrenIndexEntryLimit) {
            this.id2childrenIndexEntryLimit = id2childrenIndexEntryLimit;
            return this;
        }
        
        /**
         * Set id2subtreeIndexEntryLimit
         * @param id2subtreeIndexEntryLimit Specifies the maximum number of entry IDs to maintain for each entry in the id2subtree system index (which keeps track of all descendants below an entry, to assist in otherwise unindexed searches with a whole-subtree or subordinate subtree scope). A value of 0 means there is no limit, however this could have a big impact on database size on disk and on server performance. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder id2subtreeIndexEntryLimit(Integer id2subtreeIndexEntryLimit) {
            this.id2subtreeIndexEntryLimit = id2subtreeIndexEntryLimit;
            return this;
        }
        
        /**
         * Set importTempDirectory
         * @param importTempDirectory Specifies the location of the directory that is used to hold temporary information during the index post-processing phase of an LDIF import. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder importTempDirectory(String importTempDirectory) {
            this.importTempDirectory = importTempDirectory;
            return this;
        }
        
        /**
         * Set importThreadCount
         * @param importThreadCount Specifies the number of threads to use for concurrent processing during an LDIF import. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder importThreadCount(Integer importThreadCount) {
            this.importThreadCount = importThreadCount;
            return this;
        }
        
        /**
         * Set exportThreadCount
         * @param exportThreadCount Specifies the number of threads to use for concurrently retrieving and encoding entries during an LDIF export. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder exportThreadCount(Integer exportThreadCount) {
            this.exportThreadCount = exportThreadCount;
            return this;
        }
        
        /**
         * Set dbImportCachePercent
         * @param dbImportCachePercent The percentage of JVM memory to allocate to the database cache during import operations. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbImportCachePercent(Integer dbImportCachePercent) {
            this.dbImportCachePercent = dbImportCachePercent;
            return this;
        }
        
        /**
         * Set dbTxnWriteNoSync
         * @param dbTxnWriteNoSync Indicates whether the database should synchronously flush data as it is written to disk. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder dbTxnWriteNoSync(Boolean dbTxnWriteNoSync) {
            this.dbTxnWriteNoSync = dbTxnWriteNoSync;
            return this;
        }
        
        /**
         * Set deadlockRetryLimit
         * @param deadlockRetryLimit Specifies the number of times that the server should retry an attempted operation in the backend if a deadlock results from two concurrent requests that interfere with each other in a conflicting manner. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder deadlockRetryLimit(Integer deadlockRetryLimit) {
            this.deadlockRetryLimit = deadlockRetryLimit;
            return this;
        }
        
        /**
         * Set externalTxnDefaultBackendLockBehavior
         * @param externalTxnDefaultBackendLockBehavior  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder externalTxnDefaultBackendLockBehavior(EnumbackendExternalTxnDefaultBackendLockBehaviorProp externalTxnDefaultBackendLockBehavior) {
            this.externalTxnDefaultBackendLockBehavior = externalTxnDefaultBackendLockBehavior;
            return this;
        }
        
        /**
         * Set singleWriterLockBehavior
         * @param singleWriterLockBehavior  (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder singleWriterLockBehavior(EnumbackendSingleWriterLockBehaviorProp singleWriterLockBehavior) {
            this.singleWriterLockBehavior = singleWriterLockBehavior;
            return this;
        }
        
        /**
         * Set subtreeDeleteSizeLimit
         * @param subtreeDeleteSizeLimit Specifies the maximum number of entries that may be deleted from the backend when using the subtree delete control. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder subtreeDeleteSizeLimit(Integer subtreeDeleteSizeLimit) {
            this.subtreeDeleteSizeLimit = subtreeDeleteSizeLimit;
            return this;
        }
        
        /**
         * Set numRecentChanges
         * @param numRecentChanges Specifies the number of recent LDAP entry changes per replica for which the backend keeps a record to allow replication to recover in the event that the server is abruptly terminated. Increasing this value can lead to an increased peak server modification rate as well as increased replication throughput. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder numRecentChanges(Integer numRecentChanges) {
            this.numRecentChanges = numRecentChanges;
            return this;
        }
        
        /**
         * Set offlineProcessDatabaseOpenTimeout
         * @param offlineProcessDatabaseOpenTimeout Specifies a timeout duration which will be used for opening the database environment by an offline process, such as export-ldif. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder offlineProcessDatabaseOpenTimeout(String offlineProcessDatabaseOpenTimeout) {
            this.offlineProcessDatabaseOpenTimeout = offlineProcessDatabaseOpenTimeout;
            return this;
        }
        
        /**
         * Set backendID
         * @param backendID Specifies a name to identify the associated backend. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder backendID(String backendID) {
            this.backendID = backendID;
            return this;
        }
        
        /**
         * Set enabled
         * @param enabled Indicates whether the backend is enabled in the server. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder enabled(Boolean enabled) {
            this.enabled = enabled;
            return this;
        }
        
        /**
         * Set baseDN
         * @param baseDN Specifies the base DN(s) for the data that the backend handles. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder baseDN(List<String> baseDN) {
            this.baseDN = baseDN;
            return this;
        }
        
        /**
         * Set setDegradedAlertWhenDisabled
         * @param setDegradedAlertWhenDisabled Determines whether the Directory Server enters a DEGRADED state (and sends a corresponding alert) when this Backend is disabled. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder setDegradedAlertWhenDisabled(Boolean setDegradedAlertWhenDisabled) {
            this.setDegradedAlertWhenDisabled = setDegradedAlertWhenDisabled;
            return this;
        }
        
        /**
         * Set returnUnavailableWhenDisabled
         * @param returnUnavailableWhenDisabled Determines whether any LDAP operation that would use this Backend is to return UNAVAILABLE when this Backend is disabled. (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder returnUnavailableWhenDisabled(Boolean returnUnavailableWhenDisabled) {
            this.returnUnavailableWhenDisabled = returnUnavailableWhenDisabled;
            return this;
        }
        
        /**
         * Set notificationManager
         * @param notificationManager Specifies a notification manager for changes resulting from operations processed through this Backend (optional)
         * @return CreateConfigRequestBuilder
         */
        public CreateConfigRequestBuilder notificationManager(String notificationManager) {
            this.notificationManager = notificationManager;
            return this;
        }
        
        /**
         * Build call for createConfig
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend already exists </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AddLocalDbBackendRequest addLocalDbBackendRequest = buildBodyParams();
            return createConfigCall(addLocalDbBackendRequest, _callback);
        }

        private AddLocalDbBackendRequest buildBodyParams() {
            AddLocalDbBackendRequest addLocalDbBackendRequest = new AddLocalDbBackendRequest();
            return addLocalDbBackendRequest;
        }

        /**
         * Execute createConfig request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend already exists </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            AddLocalDbBackendRequest addLocalDbBackendRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = createConfigWithHttpInfo(addLocalDbBackendRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createConfig request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend already exists </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            AddLocalDbBackendRequest addLocalDbBackendRequest = buildBodyParams();
            return createConfigWithHttpInfo(addLocalDbBackendRequest);
        }

        /**
         * Execute createConfig request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend already exists </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            AddLocalDbBackendRequest addLocalDbBackendRequest = buildBodyParams();
            return createConfigAsync(addLocalDbBackendRequest, _callback);
        }
    }

    /**
     * Add a new Backend to the config
     * 
     * @param addLocalDbBackendRequest Create a new Backend in the config (required)
     * @return CreateConfigRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The Backend already exists </td><td>  -  </td></tr>
     </table>
     */
    public CreateConfigRequestBuilder createConfig(String backendName) throws IllegalArgumentException {
        if (backendName == null) throw new IllegalArgumentException("\"backendName\" is required but got null");
            

        return new CreateConfigRequestBuilder(backendName);
    }
    private okhttp3.Call deleteBackendCall(String backendName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backends/{backend-name}"
            .replace("{" + "backend-name" + "}", localVarApiClient.escapeString(backendName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteBackendValidateBeforeCall(String backendName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'backendName' is set
        if (backendName == null) {
            throw new ApiException("Missing the required parameter 'backendName' when calling deleteBackend(Async)");
        }

        return deleteBackendCall(backendName, _callback);

    }


    private ApiResponse<Void> deleteBackendWithHttpInfo(String backendName) throws ApiException {
        okhttp3.Call localVarCall = deleteBackendValidateBeforeCall(backendName, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteBackendAsync(String backendName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteBackendValidateBeforeCall(backendName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteBackendRequestBuilder {
        private final String backendName;

        private DeleteBackendRequestBuilder(String backendName) {
            this.backendName = backendName;
        }

        /**
         * Build call for deleteBackend
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteBackendCall(backendName, _callback);
        }


        /**
         * Execute deleteBackend request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteBackendWithHttpInfo(backendName);
        }

        /**
         * Execute deleteBackend request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteBackendWithHttpInfo(backendName);
        }

        /**
         * Execute deleteBackend request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The Backend cannot be deleted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteBackendAsync(backendName, _callback);
        }
    }

    /**
     * Delete a Backend
     * 
     * @param backendName Name of the Backend (required)
     * @return DeleteBackendRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The Backend cannot be deleted </td><td>  -  </td></tr>
     </table>
     */
    public DeleteBackendRequestBuilder deleteBackend(String backendName) throws IllegalArgumentException {
        if (backendName == null) throw new IllegalArgumentException("\"backendName\" is required but got null");
            

        return new DeleteBackendRequestBuilder(backendName);
    }
    private okhttp3.Call getAllObjectsCall(String filter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backends";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllObjectsValidateBeforeCall(String filter, final ApiCallback _callback) throws ApiException {
        return getAllObjectsCall(filter, _callback);

    }


    private ApiResponse<BackendListResponse> getAllObjectsWithHttpInfo(String filter) throws ApiException {
        okhttp3.Call localVarCall = getAllObjectsValidateBeforeCall(filter, null);
        Type localVarReturnType = new TypeToken<BackendListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAllObjectsAsync(String filter, final ApiCallback<BackendListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllObjectsValidateBeforeCall(filter, _callback);
        Type localVarReturnType = new TypeToken<BackendListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAllObjectsRequestBuilder {
        private String filter;

        private GetAllObjectsRequestBuilder() {
        }

        /**
         * Set filter
         * @param filter SCIM filter (optional)
         * @return GetAllObjectsRequestBuilder
         */
        public GetAllObjectsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Build call for getAllObjects
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAllObjectsCall(filter, _callback);
        }


        /**
         * Execute getAllObjects request
         * @return BackendListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public BackendListResponse execute() throws ApiException {
            ApiResponse<BackendListResponse> localVarResp = getAllObjectsWithHttpInfo(filter);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAllObjects request with HTTP info returned
         * @return ApiResponse&lt;BackendListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<BackendListResponse> executeWithHttpInfo() throws ApiException {
            return getAllObjectsWithHttpInfo(filter);
        }

        /**
         * Execute getAllObjects request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<BackendListResponse> _callback) throws ApiException {
            return getAllObjectsAsync(filter, _callback);
        }
    }

    /**
     * Returns a list of all Backend objects
     * 
     * @return GetAllObjectsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
     </table>
     */
    public GetAllObjectsRequestBuilder getAllObjects() throws IllegalArgumentException {
        return new GetAllObjectsRequestBuilder();
    }
    private okhttp3.Call getSingleCall(String backendName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backends/{backend-name}"
            .replace("{" + "backend-name" + "}", localVarApiClient.escapeString(backendName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSingleValidateBeforeCall(String backendName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'backendName' is set
        if (backendName == null) {
            throw new ApiException("Missing the required parameter 'backendName' when calling getSingle(Async)");
        }

        return getSingleCall(backendName, _callback);

    }


    private ApiResponse<Object> getSingleWithHttpInfo(String backendName) throws ApiException {
        okhttp3.Call localVarCall = getSingleValidateBeforeCall(backendName, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSingleAsync(String backendName, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSingleValidateBeforeCall(backendName, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSingleRequestBuilder {
        private final String backendName;

        private GetSingleRequestBuilder(String backendName) {
            this.backendName = backendName;
        }

        /**
         * Build call for getSingle
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSingleCall(backendName, _callback);
        }


        /**
         * Execute getSingle request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getSingleWithHttpInfo(backendName);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSingle request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getSingleWithHttpInfo(backendName);
        }

        /**
         * Execute getSingle request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getSingleAsync(backendName, _callback);
        }
    }

    /**
     * Returns a single Backend
     * 
     * @param backendName Name of the Backend (required)
     * @return GetSingleRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
     </table>
     */
    public GetSingleRequestBuilder getSingle(String backendName) throws IllegalArgumentException {
        if (backendName == null) throw new IllegalArgumentException("\"backendName\" is required but got null");
            

        return new GetSingleRequestBuilder(backendName);
    }
    private okhttp3.Call updateByNameCall(String backendName, UpdateRequest updateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateRequest;

        // create path and map variables
        String localVarPath = "/backends/{backend-name}"
            .replace("{" + "backend-name" + "}", localVarApiClient.escapeString(backendName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateByNameValidateBeforeCall(String backendName, UpdateRequest updateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'backendName' is set
        if (backendName == null) {
            throw new ApiException("Missing the required parameter 'backendName' when calling updateByName(Async)");
        }

        // verify the required parameter 'updateRequest' is set
        if (updateRequest == null) {
            throw new ApiException("Missing the required parameter 'updateRequest' when calling updateByName(Async)");
        }

        return updateByNameCall(backendName, updateRequest, _callback);

    }


    private ApiResponse<Object> updateByNameWithHttpInfo(String backendName, UpdateRequest updateRequest) throws ApiException {
        okhttp3.Call localVarCall = updateByNameValidateBeforeCall(backendName, updateRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateByNameAsync(String backendName, UpdateRequest updateRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateByNameValidateBeforeCall(backendName, updateRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateByNameRequestBuilder {
        private final List<Operation> operations;
        private final String backendName;

        private UpdateByNameRequestBuilder(List<Operation> operations, String backendName) {
            this.operations = operations;
            this.backendName = backendName;
        }

        /**
         * Build call for updateByName
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameCall(backendName, updateRequest, _callback);
        }

        private UpdateRequest buildBodyParams() {
            UpdateRequest updateRequest = new UpdateRequest();
            updateRequest.operations(this.operations);
            return updateRequest;
        }

        /**
         * Execute updateByName request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = updateByNameWithHttpInfo(backendName, updateRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateByName request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameWithHttpInfo(backendName, updateRequest);
        }

        /**
         * Execute updateByName request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            UpdateRequest updateRequest = buildBodyParams();
            return updateByNameAsync(backendName, updateRequest, _callback);
        }
    }

    /**
     * Update an existing Backend by name
     * 
     * @param backendName Name of the Backend (required)
     * @param updateRequest Update an existing Backend (required)
     * @return UpdateByNameRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Requestor cannot be authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Requestor does not have the required privileges </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The Backend does not exist </td><td>  -  </td></tr>
     </table>
     */
    public UpdateByNameRequestBuilder updateByName(List<Operation> operations, String backendName) throws IllegalArgumentException {
        if (operations == null) throw new IllegalArgumentException("\"operations\" is required but got null");
        if (backendName == null) throw new IllegalArgumentException("\"backendName\" is required but got null");
            

        return new UpdateByNameRequestBuilder(operations, backendName);
    }
}
